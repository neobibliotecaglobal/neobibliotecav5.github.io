<html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>Aprende a programar con Minecraft</title>
<link href="../styles/9781593276706.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:40af8c70-d268-482b-9282-0b537fc6ae71" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_261"></span><strong><span class="blue1"><span class="big">12</span></span></strong><br translate="no"/><strong>GANAR CLASE CON LA PROGRAMACIÓN ORIENTADA A</strong> OBJETOS</h2>
<div class="image1"><img alt="image" src="../images/common01.jpg" translate="no"/></div>
<p class="noindent">La reutilización es un aspecto muy importante de la programación. Ahorra tiempo y esfuerzo. Ya lo has visto con los bucles y las funciones, y ahora aprenderás sobre la programación orientada a <em>objetos</em>.</p>
<p class="indent">La programación orientada a objetos es un enfoque de la programación que agrupa funciones y variables para crear <em>clases</em>. Cada clase puede utilizarse para crear <em>objetos</em> que comparten las mismas variables y funciones que la clase. Puedes crear muchos objetos a partir de la misma clase, haciendo que las variables y funciones de la clase sean reutilizables.</p>
<p class="indent">Cuando una función forma parte de una clase, se denomina <em>método</em>, y una variable que forma parte de una clase se denomina <em>atributo</em>.</p>
<p class="indent">En este capítulo, aprenderás programación orientada a objetos y a utilizar clases para reutilizar código. Dominar la programación orientada a objetos y las clases hace que construir programas sea pan comido, e incluso puedes utilizar la programación orientada a objetos para crear juegos. En las misiones de este capítulo, utilizarás clases para crear algunos programas básicos. Empezarás creando un edificio sencillo, pero pronto construirás una ciudad entera.</p>
<h3 class="h3" id="ch12lev1sec01"><span epub:type="pagebreak" id="page_262"></span><strong><span class="blue1">Conceptos básicos orientados a objetos</span></strong></h3>
<p class="noindent">La programación orientada a objetos es muy popular, y puedes utilizarla para crear todo tipo de programas geniales, pero puede ser un concepto difícil de entender. Vamos a relacionarlo con algo que te resulte más familiar: tú.</p>
<p class="indent">Eres una persona. Tienes una serie de métodos: puedes comer, respirar, dormir, contar hasta 10 y hacer muchas otras cosas. También tienes atributos: nombre, edad, altura, número de calzado, etc.</p>
<p class="indent">Tu amiga María tiene los mismos métodos que tú; ella también puede comer, respirar, dormir, contar hasta 10 y hacer muchas otras cosas. También tiene los mismos atributos (nombre, edad, etc.), aunque contengan valores distintos.</p>
<p class="indent">De hecho, todo el mundo tiene estos métodos y atributos. Puedes describir a las personas como una clase. Tú y María sois personas, por lo que podría decirse que ambos sois objetos de la clase <span class="literal">Persona</span>.</p>
<p class="indent">En programación orientada a objetos, los objetos se denominan <em>instancias</em> de una clase. Todos los objetos comparten los métodos y atributos de la clase, pero los valores de los atributos pueden ser diferentes para cada objeto.</p>
<p class="indent">Entremos en Python y creemos una clase.</p>
<h3 class="h3" id="ch12lev1sec02"><strong><span class="blue1">Crear una clase</span></strong></h3>
<p class="noindent">Empezarás creando una clase y luego crearás todos tus objetos a partir de esa clase. Para crear una clase, utiliza la palabra clave <span class="literal">class</span>, el nombre con el que quieras llamar a la clase y la clase <span class="literal">objeto</span> entre paréntesis (explicaré la clase <span class="literal">objeto</span> en "<a href="ch12.xhtml#ch12lev2sec07">Heredar una clase</a>" en <a href="ch12.xhtml#page_278">la página 278</a>):</p>
<p class="programs" translate="no"><span class="orange">class</span> <span class="blue1">ClassName</span>(<span class="rose">object</span>):<br translate="no"/> <span class="orange">def</span> <span class="blue1">__init_</span>_(self):<br translate="no"/> <span class="red"># Body of init</span></p>
<p class="indent">Es una buena práctica poner en mayúsculas los nombres de tus clases. Así es más fácil distinguir las clases de las funciones, que deben empezar por minúscula.</p>
<p class="indent">Cuando crees una nueva clase, debes incluir el método <span class="literal">__init__()</span> y pasarle <span class="literal">self</span> como argumento. El argumento <span class="literal">self</span> es necesario para todos los métodos de una clase. Hace referencia a la clase a la que pertenece el método. El método <span class="literal">__init__</span> () indica a Python lo que quieres que haga la clase cuando la utilices por primera vez en un programa. Esto se llama <em>inicializar</em> la clase, que es la abreviatura de <span class="literal">__init__()</span>.</p>
<p class="indent">Por ejemplo, vamos a crear una clase llamada <span class="literal">Gato</span> y a crear algunos objetos gato. La clase <span class="literal">Gato</span> almacenará dos atributos para cada gato, su <span class="literal">nombre</span> y su <span class="literal">peso</span> en kilogramos. Cada objeto gato tendrá sus propios valores de <span class="literal">nombre</span> y <span class="literal">peso</span>. Abre un nuevo archivo en el editor de texto de IDLE y guárdalo como claseGato <em>.py</em> en una nueva carpeta llamada <em>clases</em>. Introduce el siguiente código para crear una clase llamada <span class="literal">Gato</span>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br translate="no"/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, weight):<br translate="no"/><span class="ent">➋</span>         self.name = name<br translate="no"/><span class="ent">➌</span>         self.weight = weight</p>
<p class="indent"><span epub:type="pagebreak" id="page_263"></span>En este ejemplo, el método <span class="literal">__init__(</span> ) toma tres argumentos <span class="ent">➊.</span> El primero es <span class="literal">self</span>, que es un argumento obligatorio en todo método de clase. El segundo argumento, <span class="literal">nombre</span>, y el último argumento, <span class="literal">peso</span>, son argumentos adicionales para crear atributos para todos los gatos.</p>
<p class="indent">Las dos últimas líneas crean los atributos <span class="literal">nombre</span> <span class="ent">➋</span> y <span class="literal">peso</span> <span class="ent">➌</span> y los establecen en los valores de los argumentos <span class="literal">nombre</span> y <span class="literal">peso</span>. Cuando creas atributos dentro de una clase, utilizas la notación de puntos con <span class="literal">self</span>. Los atributos siempre se identifican con un <span class="literal">self</span>, que indica a Python que un atributo pertenece a la clase.</p>
<p class="indent">A continuación, aprenderás a utilizar esta clase para crear instancias de objetos.</p>
<h4 class="h4" id="ch12lev2sec01"><strong><span class="blue1">Crear un objeto</span></strong></h4>
<p class="noindent">Utilizando la clase recién creada, vamos a crear algunos objetos gato, o instancias de la clase <span class="literal">Gato</span>.</p>
<p class="indent">Inicializar un objeto es similar a crear una variable. Para inicializar un objeto, introduces el nombre del objeto, un signo igual<span class="literal">(=</span>) y el nombre de la clase. Pasas argumentos a la clase entre paréntesis, igual que haces con una llamada a una función.</p>
<p class="indent">Por ejemplo, adoptemos un gato y llamémosle Pelusa. Utilizando la clase <span class="literal">Gato</span>, podemos crear un objeto gato llamado <span class="literal">pelusa</span> añadiendo el código siguiente en la última línea de <em>catClass.</em> py (fíjate en que no tiene sangría):</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">class Cat(object):</span><br translate="no"/> <span class="ash">def __init__(self, name, weight):</span><br translate="no"/> <span class="ash">self.name = name</span><br translate="no"/> <span class="ash">self.weight = weight</span><br translate="no"/><br translate="no"/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)</p>
<p class="indent">Cuando creas un objeto, el número de argumentos que proporcionas depende de los argumentos de su función <span class="literal">__init__()</span>. Aquí incluimos dos argumentos, uno para el <span class="literal">nombre</span> (<span class="literal">"Pelusa"</span>) y otro para el <span class="literal">peso</span><span class="literal">(4,5</span>). No necesitas incluir el argumento <span class="literal">self</span> al crear un objeto porque Python lo añade automáticamente.</p>
<p class="indent">Crear un objeto también se conoce como <em>llamar a un constructor</em>. El método <span class="literal">__init__</span> () suele denominarse constructor porque construye una clase cuando se le llama. El método <span class="literal">__init__</span> () es un tipo especial de método porque no haces referencia a él por su nombre. En cambio, se ejecuta cuando creas un objeto utilizando el nombre de la clase. Por ejemplo, aquí el código <span class="literal">pelusa = Gato("Pelusa", 4.5)</span> llama al método __init__ <span class="literal">()</span>, que construye un objeto <span class="literal">Gato</span> llamado <span class="literal">pelusa</span>.</p>
<p class="indent">A continuación, aprenderás a acceder a los atributos del objeto <span class="literal">pelusa</span>.</p>
<h4 class="h4" id="ch12lev2sec02"><strong><span class="blue1">Acceder a los atributos</span></strong></h4>
<p class="noindent">Puedes acceder a los atributos de un objeto para obtener más información sobre él. Por ejemplo, añade el siguiente código a <em>catClass.</em> py después del objeto <span class="literal">pelusa</span> para imprimir el atributo <span class="literal">peso</span> del objeto <span class="literal">pelusa</span>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="rose">print</span>(fluff.weight)</p>
<p class="indent"><span epub:type="pagebreak" id="page_264"></span>El valor que se imprime al ejecutar el programa debe ser 4,5, porque ése es el valor que le pusiste al atributo <span class="literal">peso</span> cuando creaste el objeto.</p>
<p class="indent">Observa que estamos utilizando la notación de puntos entre el nombre del objeto, <span class="literal">pelusa</span>, y el atributo <span class="literal">peso</span>. El punto significa que quieres utilizar el atributo que pertenece a un objeto concreto. En este caso, el valor del atributo <span class="literal">peso</span> pertenece al objeto <span class="literal">pelusa</span>. Siempre que obtengas o establezcas el valor del atributo de un objeto, utilizarás la notación de punto.</p>
<p class="indent">Puedes cambiar el valor de un atributo como lo harías con cualquier otra variable, utilizando un signo igual<span class="literal">(=</span>). Por ejemplo, cambiemos el peso de Pelusa a 5 porque ha engordado durante las vacaciones de invierno. Para ello, cambia el atributo <span class="literal">peso</span> del objeto <span class="literal">pelusa</span> a 5:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no">fluff.weight = 5</p>
<p class="indent">Ahora, siempre que accedas al atributo <span class="literal">peso</span> del objeto <span class="literal">pelusa</span>, será 5.</p>
<p class="indent">Utilizando los conocimientos que ahora tienes sobre cómo crear una clase y crear una instancia de la misma, vamos a hacer cosas chulas en Minecraft.</p>
<h4 class="h4a" id="ch12lev2sec03"><strong>Misión nº 68: Objetos de Ubicación</strong></h4>
<p class="noindent">A lo largo del libro, has almacenado ubicaciones, como tu casa, un castillo o un palacio, en tu mundo Minecraft. Has utilizado variables, listas, tuplas y diccionarios para hacerlo de diversas formas.</p>
<p class="indent">También puedes crear y almacenar información relacionada, como ubicaciones, utilizando la programación orientada a objetos. Por ejemplo, puedes utilizar objetos para almacenar las coordenadas de un montón de ubicaciones diferentes.</p>
<p class="indent">Cada ubicación tiene una coordenada x, y y z, pero los valores de cada ubicación son diferentes. Creando una clase de ubicación, puedes almacenar y acceder a las coordenadas de distintas ubicaciones. Eso te ayudará a llevar un registro de todas las cosas increíbles que construyas en Minecraft. ¡Podrás acceder fácilmente a las coordenadas de todas tus creaciones Minecraft para poder teletransportar al jugador a ellas en un instante!</p>
<p class="indent"><a href="ch12.xhtml#ch12ex1">El listado 12-1</a> contiene el inicio de la clase <span class="literal">Ubicación</span>. Cuando el código esté terminado, se podrá utilizar para almacenar las coordenadas de una ubicación en un único objeto. Copia el código en un nuevo archivo llamado <em>locationClass.py</em> en la carpeta de <em>clases</em>.</p>
<p class="sidenote" translate="no"><span class="blue"><em>locationClass.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Location</span>(<span class="rose">object</span>):<br translate="no"/> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, x, y, z):<br translate="no"/><span class="ent">➋</span>         self.x = x<br translate="no"/><span class="ent">➌</span> <span class="red"># Add the y and z attributes here</span><br translate="no"/><br translate="no"/><span class="ent">➍</span> bedroom = Location(64, 52, -8)<br translate="no"/><span class="ent">➎</span> mc.player.setTilePos(bedroom.x, bedroom.y, bedroom.z)</p>
<p class="examplet"><a id="ch12ex1"></a><em>Listado 12-1: El inicio de la</em> <em>clase</em> <span class="literal"><span class="codeitalic">Ubicación</span></span> </p>
<p class="indent"><span epub:type="pagebreak" id="page_265"></span>Para iniciar la clase, he incluido la palabra clave <span class="literal">class</span> y he llamado a la clase <span class="literal">Ubicación</span> <span class="ent">➊.</span> En <span class="ent">➍</span> está el código para inicializar un objeto llamado <span class="literal">dormitorio</span>, que almacenará la ubicación del dormitorio en mi casa de Minecraft. El método <span class="literal">setTilePos(</span> ) establece la posición del jugador en la ubicación del <span class="literal">dormitorio</span> -los atributos <span class="literal">x</span>, <span class="literal">y</span> y <span class="literal">z</span> del objeto dormitorio <span class="ent">➎.</span> Sin embargo, el programa está incompleto. Tienes que terminar el método <span class="literal">__init__(</span> ) de la clase y establecer los atributos <span class="literal">y</span> y <span class="literal">z</span> a los valores de los argumentos pasados al método <span class="literal">__init__()</span>. Yo he fijado el valor del atributo <span class="literal">x</span> <span class="ent">➋,</span> pero es tarea tuya hacer lo mismo con los atributos <span class="literal">y</span> y <span class="literal">z</span> <span class="ent">➌.</span> ¡No olvides utilizar la ubicación de tu propio dormitorio en <span class="ent">➍!</span></p>
<p class="indent"><a href="ch12.xhtml#ch12fig1">La Figura 12-1</a> muestra el programa completado en acción, ya que teletransporta al jugador a mi dormitorio.</p>
<div class="image"><img alt="image" src="../images/f12-01.jpg" translate="no"/></div>
<p class="figcap"><a id="ch12fig1"></a><em>Figura 12-1: El programa ha teletransportado al jugador a mi dormitorio.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb01"><strong>OBJETIVO EXTRA: HOGAR DULCE HOGAR</strong></p>
<p class="noindent">¿A qué otras habitaciones de tu casa quieres teletransportarte? Crea más objetos con la clase <span class="literal">Ubicación</span> para recorrer tu casa con estilo.</p>
</div>
<h3 class="h3" id="ch12lev1sec03"><strong><span class="blue1">Entender los métodos</span></strong></h3>
<p class="noindent">Las clases pueden contener métodos, que son funciones asociadas a la clase. Escribir métodos de clase te permite crear funciones que pueden utilizar todas las instancias de esa clase. Es una forma estupenda de ahorrar tiempo y reutilizar código, porque sólo tendrás que escribir un método.</p>
<p class="indent">Para crear un método, escribe una función en el cuerpo de una clase utilizando la palabra clave <span class="literal">def</span>. Ya has utilizado la palabra clave <span class="literal">def</span> en capítulos anteriores para crear funciones. Los métodos también se crean con la palabra clave <span class="literal">def</span>, pero están sangrados bajo la clase a la que pertenecen. Por ejemplo, vamos a actualizar la clase <span class="literal">Gato</span> en <span epub:type="pagebreak" id="page_266"></span><em>catClass.py</em>. Queremos que el gato pueda comer, así que añadamos un método llamado <span class="literal">comer()</span> a la clase <span class="literal">Gato</span>. Introduce el código y realiza los cambios en catClass <em>.</em> py a medida que vayas avanzando:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">class Cat(object):</span><br translate="no"/> <span class="ash">def __init__(self, name, weight):</span><br translate="no"/> <span class="ash">self.name = name</span><br translate="no"/> <span class="ash">self.weight = weight</span><br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br translate="no"/>        self.weight = self.weight + 0.05<br translate="no"/> <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)</p>
<p class="indent">Observa que la definición del método y el cuerpo del método están sangrados con cuatro espacios extra para que Python sepa que pertenecen a la clase.</p>
<p class="indent">Al igual que las funciones, los métodos pueden recibir argumentos. Aquí el método <span class="literal">comer(</span> ) toma un argumento llamado <span class="literal">comida</span> que indica lo que está comiendo el gato. El método <span class="literal">comer</span> () aumenta el atributo <span class="literal">peso</span> del gato en <span class="literal">0,05</span> y luego imprime un mensaje indicando que el gato se está comiendo la comida.</p>
<p class="indent">Tras crear un objeto, puedes llamar a cualquiera de los métodos de su clase. Por ejemplo, puedes llamar al método <span class="literal">comer()</span> utilizando el objeto <span class="literal">pelusa</span>. Añade este código al final de <em>catClass.py</em>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">fluff = Cat("Fluff", 4.5)</span><br translate="no"/>fluff.eat(<span class="green">"tuna"</span>)</p>
<p class="indent">Aquí vemos nuestro código anterior, en el que creamos un objeto llamado <span class="literal">pelusa</span> que forma parte de la clase <span class="literal">Gato</span>. Luego llamamos al método <span class="literal">comer()</span> y le damos el argumento <span class="literal">"atún"</span>. Cuando ejecutes el programa, la salida tendrá este aspecto:</p>
<p class="programs" translate="no"><span class="blue1">Fluff is eating tuna</span></p>
<p class="indent">Ahora Pelusa está feliz comiendo atún. Recuerda que el método <span class="literal">comer</span> () también aumenta el atributo peso. Después de llamar al método comer( <span class="literal">)</span>, añade el código para imprimir el peso de <span class="literal">Pelusa</span>.</p>
<p class="indent">También puedes llamar a métodos desde dentro de la clase llamando a un método dentro de otro método. Vamos a crear otro método llamado comerYDormir( <span class="literal">)</span> dentro de la clase <span class="literal">Gato</span>. El método <span class="literal">comerYDormir</span> () llama al método <span class="literal">comer()</span> y luego imprime que el gato está durmiendo. Añade este código a <em>catClass.py</em>, justo después del método eat( <span class="literal">)</span> (asegúrate de que indentas el nuevo método como se muestra para que Python sepa que forma parte de la clase):</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br translate="no"/>       self.eat(food)<br translate="no"/> <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)</p>
<p class="indent">Para llamar a un método desde dentro de la clase a la que pertenece, añade <span class="literal">self.</span> al principio del nombre del método. Aquí se llama al método <span class="literal">comer(</span> ) utilizando self. <span class="literal">comer()</span>. Ten en cuenta que esto es diferente de llamar a un método fuera de <span epub:type="pagebreak" id="page_267"></span>una clase. Cuando haces eso, sólo tienes que introducir el nombre del objeto y el método al que llamas. Por ejemplo, el siguiente código llama al nuevo método <span class="literal">comerYDormir</span> () del objeto <span class="literal">pelusa</span>. Añádelo a tu archivo <em>catClass.py</em>. Debe ser la última línea de código de tu programa:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no">fluff.eatAndSleep(<span class="green">"tuna"</span>)</p>
<p class="indent">Esta es la salida que deberías obtener al ejecutar el programa:</p>
<p class="programs" translate="no"><span class="blue1">Fluff is eating tuna</span><br translate="no"/><span class="blue1">Fluff is now sleeping...</span></p>
<p class="indent">Aquí tienes el programa completo para que veas dónde están todas las piezas:</p>
<p class="programs" translate="no"><span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br translate="no"/> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, weight):<br translate="no"/>        self.name = name<br translate="no"/>        self.weight = weight<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br translate="no"/>        self.weight = self.weight + 0.05<br translate="no"/> <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br translate="no"/>        self.eat(food)<br translate="no"/> <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)<br translate="no"/><br translate="no"/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)<br translate="no"/><span class="rose">print</span>(fluff.weight)<br translate="no"/>fluff.eat(<span class="green">"tuna"</span>)<br translate="no"/>fluff.eatAndSleep(<span class="green">"tuna"</span>)</p>
<p class="indent">¡Llevemos las nuevas habilidades que has aprendido al mundo de Minecraft!</p>
<h4 class="h4a" id="ch12lev2sec04"><strong>Misión nº 69: Casa Fantasma</strong></h4>
<p class="noindent">Lo mejor de programar con Python y Minecraft es que puedes empezar con una idea tonta y correr con ella. Tu idea puede empezar siendo pequeña, pero con sólo unas pocas líneas de código, puedes construir un programa divertido muy rápidamente.</p>
<p class="indent">¿No sería divertido construir una casa fantasma que apareciera en un juego, sólo para desaparecer 30 segundos después? La casa podría reaparecer en otro lugar y volver a desaparecer si tú quisieras.</p>
<p class="indent">Aquí tienes la primera versión del programa de la casa fantasma. Guarda <a href="ch12.xhtml#ch12ex2">el Listado 12-2</a> en un archivo llamado <em>casafantasma.py</em> en la carpeta de <em>clases</em>.</p>
<p class="sidenote" translate="no"><span class="blue"><em>ghostHouse.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/><br translate="no"/> <span class="orange">import</span> time<br translate="no"/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Building</span>(<span class="rose">object</span>):<br translate="no"/><span class="ent">➋</span> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, x, y, z, width, height, depth):<br translate="no"/>           self.x = x<br translate="no"/>           self.y = y<br translate="no"/>           self.z = z<br translate="no"/><br translate="no"/>           self.width = width<br translate="no"/>           self.height = height<br translate="no"/>           self.depth = depth<br translate="no"/><br translate="no"/><span class="ent">➌</span> <span class="orange">def</span> <span class="blue1">build</span>(self):<br translate="no"/>           mc.setBlocks(self.x, self.y, self.z,<br translate="no"/>                        self.x + self.width, self.y + self.height,<br translate="no"/>                        self.z + self.depth, 4)<br translate="no"/><br translate="no"/>           mc.setBlocks(self.x + 1, self.y + 1, self.z + 1,<br translate="no"/>                        self.x + self.width - 1, self.y + self.height - 1,<br translate="no"/>                        self.z + self.depth - 1, 0)<br translate="no"/><span class="ent">➍</span> <span class="red"># Call the buildDoor() and buildWindows() methods here</span><br translate="no"/><br translate="no"/><span class="ent">➎</span> <span class="orange">def</span> <span class="blue1">clear</span>(self):<br translate="no"/>           mc.setBlocks(self.x, self.y, self.z,<br translate="no"/>                        self.x + self.width, self.y + self.height,<br translate="no"/>                        self.z + self.depth, 0)<br translate="no"/><span class="ent">➏</span> <span class="red"># Remove the doors and windows here</span><br translate="no"/><br translate="no"/>   pos = mc.player.getTilePos()<br translate="no"/>   x = pos.x<br translate="no"/>   y = pos.y<br translate="no"/>   z = pos.z<br translate="no"/><br translate="no"/><span class="ent">➐</span> ghostHouse = Building(x, y, z, 10, 6, 8) ghostHouse.build()<br translate="no"/>   time.sleep(30)<br translate="no"/><br translate="no"/>   ghostHouse.clear()<br translate="no"/><span class="ent">➑</span> ghostHouse.x = 8</p>
<p class="sidenote" translate="no"><span class="blue"><em>ghostHouse.py</em></span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_268"></span><a id="ch12ex2"></a>Listado 12-2<em>: La</em> clase <span class="literal"><span class="codeitalic">Edificio</span></span> <em>crea un edificio.</em></p>
<p class="indent"><a href="ch12.xhtml#ch12ex2">El</a> listado 12-2 utiliza una clase llamada <span class="literal">Edificio</span> <span class="ent">➊</span> con un método <span class="literal">__init__(</span> ) para establecer la posición y el tamaño de la casa <span class="ent">➋.</span> Crea un objeto <span class="literal">Edificio</span> con el nombre <span class="literal">CasaFantasma</span> <span class="ent">➐.</span> El edificio aparece y luego desaparece misteriosamente al cabo de 30 segundos utilizando los métodos <span class="literal">build()</span> <span class="ent">➌</span> y <span class="literal">clear()</span> <span class="ent">➎</span>. El único problema es que no parece una casa. Ahora mismo parece un gran cascarón vacío hecho de adoquines.</p>
<p class="indent">Tienes que hacer que la casa fantasma se parezca más a una casa y menos a un cascarón, porque los cascarones fantasma no dan tanto miedo como las casas fantasma. Para que el edificio parezca más una casa, tu misión es añadir un método que construya una puerta en la parte delantera de la casa y un segundo método que añada ventanas. Llama a estos dos métodos desde dentro del método <span class="literal">build(</span> ) para que se construyan al mismo tiempo <span class="ent">➍.</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_269"></span>Después de añadir los métodos para construir la puerta y las ventanas, tendrás que actualizar el método <span class="literal">clear</span> () para eliminarlos ➏; de lo contrario, se quedarán atrás cuando desaparezca la casa.</p>
<p class="indent">Cuando hayas añadido los métodos adicionales, traslada el edificio a una nueva ubicación cambiando los atributos <span class="literal">x</span>, <span class="literal">y</span> y <span class="literal">z</span> del objeto <span class="literal">ghostHouse</span> y añadiendo más llamadas a los métodos <span class="literal">build()</span> y clear <span class="literal">(</span> ). He empezado esto por ti cambiando la posición <span class="literal">x</span> de la casa ➑.</p>
<p class="indent">Cuando ejecutes el programa, la casa fantasma debería aparecer de repente y desaparecer 30 segundos después, para reaparecer en otro lugar. ¡Espeluznante!</p>
<p class="indent"><a href="ch12.xhtml#ch12fig2">La Figura 12-2</a> muestra mi casa fantasma.</p>
<div class="image"><img alt="image" src="../images/f12-02.jpg" translate="no"/></div>
<p class="figcap"><a id="ch12fig2"></a><em>Figura 12-2: La casa fantasma aparece y luego desaparece.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb02"><span epub:type="pagebreak" id="page_270"></span><strong>OBJETIVO EXTRA: MEJORA DE LA CASA</strong></p>
<p class="noindent">De momento, la casa fantasma es muy básica. Utilizando las increíbles habilidades de Python que has aprendido en este libro, añade lo que quieras a la función <span class="literal">build(</span> ) para personalizar tu casa.</p>
</div>
<h3 class="h3" id="ch12lev1sec04"><strong><span class="blue1">Devolver valores con métodos</span></strong></h3>
<p class="noindent">Al igual que las funciones, los métodos también pueden devolver valores, o los atributos de un objeto, utilizando la palabra clave <span class="literal">return</span>. Por ejemplo, supongamos que queremos convertir el peso del gato Fluff de kilogramos a gramos. Un kilogramo equivale a 1000 gramos, así que para hacer la conversión, multiplica el atributo <span class="literal">peso</span> por 1000 y devuélvelo. Añade el siguiente método <span class="literal">getPesoEnGramos()</span> a la clase <span class="literal">Gato</span> en <em>catClass.py</em>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">class Cat(object):</span><br translate="no"/> <span class="ash">def __init__(self, name, weight):</span><br translate="no"/> <span class="ash">self.name = name</span><br translate="no"/> <span class="ash">self.weight = weight</span><br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">getWeightInGrams</span>(self):<br translate="no"/> <span class="orange">return</span> self.weight * 1000</p>
<p class="indent">Para obtener el valor devuelto por el método, creas un objeto y llamas al método. En el código siguiente, se utiliza el objeto <span class="literal">pelusa</span>, y se llama al método dentro de una función <span class="literal">print(</span> ) para obtener el peso del gato en gramos:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">fluff = Cat("Fluff", 4.5)</span><br translate="no"/><span class="rose">print</span>(fluff.getWeightInGrams())</p>
<p class="indent">Ahora, cuando ejecutes el archivo, saldrá lo siguiente:</p>
<p class="programs" translate="no"><span class="blue1">4500</span></p>
<p class="indent">En la próxima misión, ampliaremos el programa de la casa fantasma para incluir un método que devuelva información sobre el edificio.</p>
<h4 class="h4a" id="ch12lev2sec05"><strong>Misión nº 70: Castillo fantasma</strong></h4>
<p class="noindent">Tengo en mente todo tipo de nombres para los distintos lugares que he construido en mi mundo Minecraft: la casa de la playa, la granja de plantas, la granja de animales, el almacén, el palacio, el palacio submarino, el palacio subterráneo, y un montón más. ¡El problema es que los nombres sólo existen en mi cabeza!</p>
<p class="indent">Con las clases, puedes crear atributos como ubicación y tamaño para las cosas que construyas, como viste en la Misión 69<a href="ch12.xhtml#page_267">(página 267</a>). ¡También puedes incluir nombres!</p>
<p class="indent"><span epub:type="pagebreak" id="page_271"></span>Pongamos un nombre a la casa fantasma y hagamos que Python lo recuerde por nosotros. Actualizaremos la clase <span class="literal">Edificio</span> de la Misión nº 69 para añadir un método extra que devuelva el nombre del edificio. Copia <a href="ch12.xhtml#ch12ex3">el Listado 12-3</a> en un nuevo archivo llamado <em>castillofantasma.py</em> en la carpeta de <em>clases</em>.</p>
<p class="sidenote" translate="no"><span class="blue"><em>ghostCastle.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/> <span class="orange">import</span> time<br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">NamedBuilding</span>(<span class="rose">object</span>):<br translate="no"/><span class="ent">➋</span> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, x, y, z, width, height, depth, name):<br translate="no"/>           self.x = x<br translate="no"/>           self.y = y<br translate="no"/>           self.z = z<br translate="no"/><br translate="no"/>           self.width = width<br translate="no"/>           self.height = height<br translate="no"/>           self.depth = depth<br translate="no"/><br translate="no"/><span class="ent">➌</span>         self.name = name<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">build</span>(self):<br translate="no"/>           mc.setBlocks(self.x, self.y, self.z,<br translate="no"/>                        self.x + self.width, self.y + self.height,<br translate="no"/>                        self.z + self.depth, 4)<br translate="no"/><br translate="no"/>           mc.setBlocks(self.x + 1, self.y + 1, self.z + 1,<br translate="no"/>                        self.x + self.width - 1, self.y + self.height - 1,<br translate="no"/>                        self.z + self.depth - 1, 0)<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">clear</span>(self):<br translate="no"/>           mc.setBlocks(self.x, self.y, self.z,<br translate="no"/>                        self.x + self.width, self.y + self.height,<br translate="no"/>                        self.z + self.depth, 0)<br translate="no"/><br translate="no"/><span class="ent">➍</span> <span class="orange">def</span> <span class="blue1">getInfo</span>():<br translate="no"/> <span class="red"># Add the body of the getInfo() method here</span><br translate="no"/><br translate="no"/>   pos = mc.player.getTilePos()<br translate="no"/>   x = pos.x<br translate="no"/>   y = pos.y<br translate="no"/>   z = pos.z<br translate="no"/>   ghostCastle = NamedBuilding(x, y, z, 10, 16, 16, <span class="green">"Ghost Castle"</span>)<br translate="no"/>   ghostCastle.build()<br translate="no"/><span class="ent">➎</span> mc.postToChat(ghostCastle.getInfo())<br translate="no"/><br translate="no"/>   time.sleep(30)<br translate="no"/><br translate="no"/>   ghostCastle.clear()</p>
<p class="examplet"><em><a id="ch12ex3"></a>Listado 12-3:</em> <span class="literal"><span class="codeitalic">EdificioNombrado</span></span> <em>es muy similar a la</em> <em>clase</em> <span class="literal"><span class="codeitalic">Edificio</span></span> <em>, salvo que tiene un atributo extra llamado</em> <span class="literal"><span class="codeitalic">nombre</span></span> <em>y un método extra que devuelve una descripción del edificio.</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_272"></span>En primer lugar, he cambiado el nombre de la clase a <span class="literal">EdificioNombrado</span> para que no la confundamos con la clase <span class="literal">Edificio</span> de la misión anterior <span class="ent">➊.</span> He añadido un argumento y un atributo extra al constructor llamado <span class="literal">nombre</span> <span class="ent">➋.</span> El argumento te permite dar un nombre al edificio, y el constructor asigna el <span class="literal">nombre</span> al atributo nombre <span class="ent">➌.</span></p>
<p class="indent">Tu misión es añadir un método llamado <span class="literal">getInfo()</span> a la nueva clase <span class="literal">EdificioNombrado</span> que devuelva el nombre y la posición del edificio. Te he añadido el inicio del método <span class="literal">getInfo</span> () en <span class="ent">➍.</span> Sólo tienes que añadir el cuerpo. El método <span class="literal">getInfo</span> () se invoca en el objeto <span class="literal">castillofantasma</span> en <span class="ent">➎</span> para que envíe la cadena devuelta por el método al chat de Minecraft. Por ejemplo, si el castillo fantasma está situado en <span class="literal">x = -310</span>, <span class="literal">y = 64</span>, <span class="literal">z = 1081</span>, el método getInfo <span class="literal">(</span> ) debe devolver la cadena "La <span class="literal"> ubicación del castillo fantasma está en -310, 64, 1081"</span>.</p>
<p class="indent"><a href="ch12.xhtml#ch12fig3">La Figura 12-3</a> muestra mi programa en funcionamiento. Aunque el castillo fantasma es más alto, se parece a la casa de la Misión nº 69. Esto se debe a que los métodos <span class="literal">build(</span> ) son los mismos para ambos, pero siéntete libre de cambiar tu versión del código para que tu edificio se parezca más a un castillo.</p>
<div class="image"><img alt="image" src="../images/f12-03.jpg" translate="no"/></div>
<p class="figcap"><a id="ch12fig3"></a><em>Figura 12-3: Aparece la descripción del castillo fantasma.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb03"><strong>OBJETIVO EXTRA: UNA CÁLIDA BIENVENIDA</strong></p>
<p class="noindent">¿No sería genial que el nombre de cualquier edificio al que entraras apareciera automáticamente en el chat? Bueno, es posible, pero es un poco difícil. Si quieres intentarlo, puedes utilizar el programa <em>ducha.py</em> de la Misión 32<a href="ch06.xhtml#page_124">(página 124</a>) como punto de partida. El archivo debe estar en tu carpeta <em>ifDeclaraciones</em>. Puedes utilizar el programa para detectar las coordenadas del jugador y, si está dentro del edificio, llamar al método <span class="literal">getInfo()</span> del objeto <span class="literal">edificio</span>.</p>
</div>
<h3 class="h3" id="ch12lev1sec05"><span epub:type="pagebreak" id="page_273"></span><strong><span class="blue1">Crear varios objetos</span></strong></h3>
<p class="noindent">Puedes crear varios objetos a partir de la misma clase creando objetos con nombres diferentes utilizando el mismo constructor de clase (recuerda que <em>constructor</em> es otro nombre para el método <span class="literal">__init__()</span> ). Por ejemplo, supongamos que encontramos una segunda gata llamada Stella que ahora es amiga de Fluff. Abre <em>catClass.py</em> e introduce el siguiente código para añadir a Stella:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">class Cat(object):</span><br translate="no"/> <span class="ash">def __init__(self, name, weight):</span><br translate="no"/> <span class="ash">self.name = name</span><br translate="no"/> <span class="ash">self.weight = weight</span><br translate="no"/><br translate="no"/><span class="ash">fluff = Cat("Fluff", 4.5)</span><br translate="no"/>stella = Cat(<span class="green">"Stella"</span>, 3.9)</p>
<p class="indent">Ahora tenemos dos objetos gato, <span class="literal">Pelusa</span> y <span class="literal">Stella</span>. Cada uno tiene los mismos atributos, <span class="literal">nombre</span> y <span class="literal">peso</span>, pero con valores diferentes.</p>
<p class="indent">Añade el siguiente código a <em>catClass.</em> py para imprimir los nombres de los gatos:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="rose">print</span>(fluff.name)<br translate="no"/><span class="rose">print</span>(stella.name)</p>
<p class="indent">Cuando ejecutes el archivo, obtendrás esta salida:</p>
<p class="programs" translate="no"><span class="blue1">Fluff</span><br translate="no"/><span class="blue1">Stella</span></p>
<p class="indent">Los dos objetos gato también tienen acceso a los mismos métodos. Ambos pueden llamar a la función <span class="literal">comer()</span>. Añade este código a <em>catClass.</em>py:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no">fluff.eat(<span class="green">"tuna"</span>)<br translate="no"/>stella.eat(<span class="green">"cake"</span>)</p>
<p class="indent">Y la salida tendrá este aspecto:</p>
<p class="programs" translate="no"><span class="blue1">Fluff is eating tuna</span><br translate="no"/><span class="blue1">Stella is eating cake</span></p>
<p class="indent">Escribir una clase facilita mucho la creación de muchos objetos. ¡Intentemos crear varios objetos con Minecraft!</p>
<h4 class="h4a" id="ch12lev2sec06"><strong>Misión nº 71: Ciudad Fantasma</strong></h4>
<p class="noindent">¿Qué da más miedo que una casa fantasma? Exacto, dos casas fantasma. Pero tres casas fantasma darían aún más miedo. ¿Y más de tres casas fantasma? Tengo que dejar de pensar en esto, ¡o no podré dormir esta noche!</p>
<p class="indent"><span epub:type="pagebreak" id="page_274"></span>En la Misión 69<a href="ch12.xhtml#page_267">(página 267</a>), creaste una clase que construye una casa que desaparece. Ahora puedes crear varios objetos utilizando la misma clase, y Python recordará cada uno de los atributos y métodos del objeto. Puedes hacer tantas casas como quieras, y puedes hacer que aparezcan y desaparezcan con facilidad.</p>
<p class="indent">Tu misión es crear cuatro o más objetos casa fantasma y disponerlos en un pueblo. Al cabo de cierto tiempo, haz que desaparezcan todas y reaparezcan en otro lugar del mapa, como en un verdadero pueblo fantasma.</p>
<p class="indent">Abre <em>ghostHouse.py</em> en IDLE: lo utilizaremos como base. Cuando hayas creado una casa en el programa <em>ghostHouse.</em> py, tu código debería tener este aspecto:</p>
<p class="sidenote" translate="no"><span class="blue"><em>ghostHouse.py</em></span></p>
<p class="programs" translate="no">ghostHouse = Building(17, 22, -54, 10, 6, 8)<br translate="no"/>ghostHouse.build()<br translate="no"/><br translate="no"/>time.sleep(30)<br translate="no"/><br translate="no"/>ghostHouse.clear()</p>
<p class="indent">Guarda <em>ghostHouse</em>.py como un nuevo archivo llamado <em>ghostVillage.py</em>, y luego crea tres o más objetos en el archivo utilizando la clase <span class="literal">Edificio</span> para construir el pueblo. Para ayudarte a empezar, en <a href="ch12.xhtml#ch12ex4">el Listado 12-4</a> he creado un segundo objeto llamado <span class="literal">tienda</span>. También he establecido las variables <span class="literal">x</span>, <span class="literal">y</span> y <span class="literal">z</span> para que contengan la posición actual del jugador, que encontraremos utilizando <span class="literal">player.getTilePos()</span>. Esto facilita la construcción de la aldea a tu alrededor.</p>
<p class="sidenote" translate="no"><span class="blue"><em>ghostVillage.py</em></span></p>
<p class="programs" translate="no">pos = mc.player.getTilePos()<br translate="no"/>x = pos.x<br translate="no"/>y = pos.y<br translate="no"/>z = pos.z<br translate="no"/>ghostHouse = Building(x, y, z, 10, 6, 8)<br translate="no"/>shop = Building(x + 12, y, z, 8, 12, 10)<br translate="no"/><span class="red"># Create more ghost building objects here</span><br translate="no"/><br translate="no"/>ghostHouse.build()<br translate="no"/>shop.build()<br translate="no"/><span class="red"># Build more ghost building objects here</span><br translate="no"/><br translate="no"/>time.sleep(30)<br translate="no"/><br translate="no"/>ghostHouse.clear()<br translate="no"/>shop.clear()</p>
<p class="examplet"><a id="ch12ex4"></a><em>Listado 12-4: Creación de múltiples objetos de construcción fantasma</em></p>
<p class="indent"><a href="ch12.xhtml#ch12fig4">La Figura 12-4</a> muestra mi aldea fantasma. Después de 30 segundos, los edificios fantasma desaparecen de repente.</p>
<div class="image"><span epub:type="pagebreak" id="page_275"></span><img alt="image" src="../images/f12-04.jpg" translate="no"/></div>
<p class="figcap"><a id="ch12fig4"></a><em>Figura 12-4: ¡Mira todos los edificios fantasma del pueblo fantasma!</em></p>
<h3 class="h3" id="ch12lev1sec06"><strong><span class="blue1">Atributos de clase</span></strong></h3>
<p class="noindent">A veces puedes querer establecer atributos que tengan el mismo valor para cada instancia de objeto de una clase. Sería redundante pasar el mismo argumento a la clase cada vez que se crea un objeto. En su lugar, puedes crear un atributo preestablecido en la clase, y todas las instancias de objetos de esa clase compartirán esos atributos.</p>
<p class="indent">Cuando varios objetos comparten el mismo atributo, se denomina <em>atributo de</em> clase. Por ejemplo, todos los objetos gato que hemos creado pertenecen a Craig (yo). Puedo volver a visitar la clase <span class="literal">Gato</span> en el archivo <em>catClass.py</em>, crear un atributo de clase llamado <span class="literal">propietario</span> y establecerlo como <span class="literal">"Craig"</span>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">class Cat(object):</span><br translate="no"/>    owner = <span class="green">"Craig"</span><br translate="no"/><br translate="no"/> <span class="ash">def __init__(self, name, weight):</span><br translate="no"/> <span class="ash">self.name = name</span><br translate="no"/> <span class="ash">self.weight = weight</span></p>
<p class="indent">Como puedes ver, los atributos de clase no utilizan <span class="literal">self</span> antes de su nombre. En este ejemplo, <span class="literal">owner</span> es un atributo de clase y <span class="literal">self.name</span> es un atributo. Observa que defines los atributos de clase fuera de la función <span class="literal">__init__()</span>.</p>
<p class="indent">Los atributos de clase funcionan igual que cualquier otro atributo de un objeto. Por ejemplo, puedes acceder al valor de un atributo de clase como lo harías con un atributo normal. En este caso, para encontrar al propietario de Fluff, podemos imprimir el atributo de clase <span class="literal">propietario</span> del objeto <span class="literal">Fluff</span>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">fluff = Cat("Fluff", 4.5)</span><br translate="no"/><span class="rose">print</span>(fluff.owner)</p>
<p class="indent"><span epub:type="pagebreak" id="page_276"></span>El valor impreso debería ser <span class="literal">"Craig"</span>. Si imprimiéramos el propietario de Stella, el valor sería el mismo porque los atributos de clase son iguales para todos los objetos de esa clase:</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="ash">stella = Cat("Stella", 3.9)</span><br translate="no"/><span class="rose">print</span>(stella.owner)</p>
<p class="indent">El valor impreso aquí también es " <span class="literal">Craig</span>".</p>
<p class="indent">Puedes cambiar el valor de los atributos de clase para objetos individuales. Esto cambiará el valor del atributo para ese objeto, pero no para otros objetos de la clase. Por ejemplo, Stella ha sido adoptada por mi amigo Matthew, así que tenemos que cambiar el propietario de Stella a <span class="literal">"Matthew</span>":</p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no">stella.owner = <span class="green">"Matthew"</span><br translate="no"/><span class="ash">print(stella.owner)</span><br translate="no"/><span class="ash">print(fluff.owner)</span></p>
<p class="indent">Cuando se imprime el atributo <span class="literal">propietario</span> de <span class="literal">stella</span>, aparece <span class="literal">"</span>Matthew", pero el propietario de <span class="literal">fluff</span>sigue siendo <span class="literal">"Craig"</span>.</p>
<p class="indent">Después de todos los cambios que hemos hecho en <em>catClass.py</em>, el programa final tiene el siguiente aspecto. También está disponible en los recursos del libro en <em><a href="https://www.nostarch.com/programwithminecraft/">https://www.nostarch.com/programwithminecraft/.</a></em></p>
<p class="sidenote" translate="no"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs" translate="no"><span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br translate="no"/>    owner = <span class="green">"Craig"</span><br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, weight):<br translate="no"/>        self.name = name<br translate="no"/>        self.weight = weight<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br translate="no"/>        self.weight = self.weight + 0.05<br translate="no"/> <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br translate="no"/>        self.eat(food)<br translate="no"/> <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">getWeightInGrams</span>(self):<br translate="no"/> <span class="orange">return</span> self.weight * 1000<br translate="no"/><br translate="no"/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)<br translate="no"/><span class="rose">print</span>(fluff.owner)<br translate="no"/>stella = Cat(<span class="green">"Stella"</span>, 3.9)<br translate="no"/><span class="rose">print</span>(stella.owner)<br translate="no"/><br translate="no"/><span class="rose">print</span>(fluff.weight)<br translate="no"/>fluff.eat(<span class="green">"tuna"</span>)<br translate="no"/>fluff.eatAndSleep(<span class="green">"tuna"</span>)<br translate="no"/><br translate="no"/><span class="rose">print</span>(fluff.getWeightInGrams())<br translate="no"/><span class="rose">print</span>(fluff.name)<br translate="no"/><span class="rose">print</span>(stella.name)<br translate="no"/><br translate="no"/>fluff.eat(<span class="green">"tuna"</span>)<br translate="no"/>stella.eat(<span class="green">"cake"</span>)<br translate="no"/><br translate="no"/>stella.owner = <span class="green">"Matthew"</span><br translate="no"/><span class="rose">print</span>(stella.owner)<br translate="no"/><span class="rose">print</span>(fluff.owner)</p>
<p class="indent"><span epub:type="pagebreak" id="page_277"></span>Ahora que ya has visto cómo utilizar objetos, vamos a ver cómo hacerlos aún más potentes con la herencia.</p>
<h3 class="h3" id="ch12lev1sec07"><strong><span class="blue1">Entender la herencia</span></strong></h3>
<p class="noindent">La<em>herencia</em> se produce cuando las clases comparten los mismos métodos y atributos que otras clases. Por ejemplo, los patos son un tipo de ave. Comparten los mismos métodos que otras aves (volar, comer, etc.) y tienen los mismos atributos que otras aves (peso, envergadura, etc.). Así que se podría decir que <em>los patos</em> heredan sus atributos y métodos de la clase <em>aves</em>. <a href="ch12.xhtml#ch12fig5">La figura 12-5</a> muestra esta relación en un diagrama.</p>
<div class="image"><img alt="image" src="../images/f12-05.jpg" translate="no"/></div>
<p class="figcap"><a id="ch12fig5"></a><em>Figura 12-5: Tanto los pingüinos como los patos son clases de aves.</em></p>
<p class="indent">La clase de la que heredan otras clases se llama <em>superclase</em>; la clase que hereda de la superclase se llama <em>subclase</em>.</p>
<p class="indent">La herencia es útil porque permite crear diferencias sutiles entre objetos similares. Por ejemplo, los pingüinos también son un tipo de ave, pero pueden nadar bajo el agua, a diferencia de la mayoría de las aves. Para representar a los pingüinos, tienes que crear una subclase que herede de la clase pájaro pero que tenga adaptaciones para que los pingüinos puedan nadar bajo el agua. Estas adaptaciones son la razón por la que creas subclases: puedes conservar las características principales de la superclase para evitar tener que escribir el código de nuevo, y sólo tienes que añadir los métodos y atributos que necesites en la subclase.</p>
<h4 class="h4" id="ch12lev2sec07"><span epub:type="pagebreak" id="page_278"></span><strong><span class="blue1">Heredar una clase</span></strong></h4>
<p class="noindent">Cuando una subclase hereda de una superclase, la subclase puede utilizar todos los métodos y atributos de la superclase. La subclase también puede añadir clases y atributos adicionales sin alterar la superclase original.</p>
<p class="indent">Utilicemos el ejemplo de los pájaros para ilustrarlo. Primero escribiremos el código de la superclase <span class="literal">Pájaro</span>. Abre un nuevo archivo en IDLE, llámalo <em>clasepájaro.py</em> y añade el siguiente código para crear la clase:</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no"><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Bird</span>(<span class="rose">object</span>):<br translate="no"/><span class="ent">➋</span> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, wingspan):<br translate="no"/>           self.name = name<br translate="no"/>           self.wingspan = wingspan<br translate="no"/><br translate="no"/><span class="ent">➌</span> <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"chirp"</span>)<br translate="no"/><span class="ent">➍</span> <span class="orange">def</span> <span class="blue1">fly</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"flap"</span>)</p>
<p class="indent">Creamos una clase llamada <span class="literal">Ave</span> <span class="ent">➊,</span> pero fíjate en que la clase <span class="literal">Ave</span> hereda de <span class="literal">objeto</span>. La clase <span class="literal">objeto</span> es una clase base sobre la que se construirán todas las demás clases. Todas las clases heredan de la clase <span class="literal">objeto</span>, y se utiliza cuando no hay otras superclases de las que heredar. Aunque haya varios niveles de herencia en los que muchas clases hereden unas de otras, la clase <span class="literal">objeto</span> siempre será la superclase utilizada en el nivel más alto de herencia.</p>
<p class="indent">El método <span class="literal">__init__()</span> de la clase <span class="literal">Pájaro</span> toma dos argumentos que establecen dos atributos: el <span class="literal">nombre</span> del pájaro y su <span class="literal">envergadura</span> <span class="ent">➋.</span> Tiene dos métodos: <span class="literal">birdcall()</span> <span class="ent">➌</span> y <span class="literal">fly()</span> <span class="ent">➍.</span> De momento, el método <span class="literal">birdcall</span> () sólo imprime <span class="literal">"chirrido"</span> y el método <span class="literal">fly</span> () sólo imprime <span class="literal">"aleteo"</span>.</p>
<p class="indent">En el mismo archivo, crea un objeto llamado <span class="literal">pájarojardín</span> utilizando la clase <span class="literal">Pájaro</span>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no">gardenBird = Bird(<span class="green">"Geoffrey"</span>, 12)<br translate="no"/>gardenBird.birdcall()<br translate="no"/>gardenBird.fly()</p>
<p class="indent">Este código imprimirá</p>
<p class="programs" translate="no"><span class="blue1">chirp</span><br translate="no"/><span class="blue1">flap</span></p>
<p class="indent">Ahora que has creado una superclase, puedes crear una subclase que herede de la superclase pero que tenga su propio método. Lo harás en la siguiente sección.</p>
<h4 class="h4" id="ch12lev2sec08"><span epub:type="pagebreak" id="page_279"></span><strong><span class="blue1">Añadir nuevos métodos a las subclases</span></strong></h4>
<p class="noindent">Añadamos una clase para pingüinos a <em>birdClass.py</em> y llamémosla <span class="literal">Pingüino</span>. Como los pingüinos pueden nadar bajo el agua, puedes añadir un método extra a la clase <span class="literal">Pingüino</span> llamado <span class="literal">nadar()</span>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no"><span class="orange">class</span> <span class="blue1">Penguin</span>(Bird):<br translate="no"/> <span class="orange">def</span> <span class="blue1">swim</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"swimming"</span>)</p>
<p class="indent">Cuando defines una subclase y quieres que herede de otra superclase en lugar de <span class="literal">un objeto</span>, pones entre paréntesis el nombre de la superclase de la que hereda. Observa que no he creado un método <span class="literal">__init__()</span> para la clase <span class="literal">Pingüino</span>. La razón es que hereda de la clase <span class="literal">Pájaro</span>, por lo que utiliza el método __init__( <span class="literal">)</span> de la clase <span class="literal">Pájaro</span>. Utilicemos ese método __init__( <span class="literal">)</span> y probemos la función <span class="literal">swim(</span> ) creando un pingüino:</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no">sarahThePenguin = Penguin(<span class="green">"Sarah"</span>, 10)<br translate="no"/>sarahThePenguin.swim()</p>
<p class="indent">Este código mostrará lo siguiente:</p>
<p class="programs" translate="no"><span class="blue1">swimming</span></p>
<p class="indent">La clase <span class="literal">Pingüino</span> también puede utilizar los métodos <span class="literal">fly()</span> y <span class="literal">birdcall()</span> porque los hereda de <span class="literal">Bird</span>.</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no">sarahThePenguin.fly()<br translate="no"/>sarahThePenguin.birdcall()</p>
<p class="indent">En este caso, el resultado será el siguiente:</p>
<p class="programs" translate="no"><span class="blue1">flap</span><br translate="no"/><span class="blue1">chirp</span></p>
<p class="indent">Pero <span class="literal">aletear</span> y <span class="literal">piar</span> no tienen sentido para un pingüino, porque los pingüinos no pueden volar y su canto de pájaro es más bien un graznido. Aprenderemos a anular métodos heredados y a solucionar esto en "<a href="ch12.xhtml#ch12lev1sec08">Anular métodos y atributos</a>", en la <a href="ch12.xhtml#page_282">página 282</a>.</p>
<p class="indent">Pero antes, volvamos a Minecraft y creemos unos nuevos edificios fantasma utilizando la herencia.</p>
<h4 class="h4a" id="ch12lev2sec09"><strong>Misión nº 72: Hotel Fantasma</strong></h4>
<p class="noindent">Tanto las casas como los hoteles son tipos de edificios: tienen puertas, ventanas, habitaciones, escaleras y paredes. Los hoteles no son más que casas elegantes con extras como balcones, muchas habitaciones y una bonita entrada.</p>
<p class="indent"><span epub:type="pagebreak" id="page_280"></span>¿Cómo puedes programar unos hoteles fantasma utilizando el código que ya has creado para las casas fantasma? La estructura básica de los edificios es la misma. Digamos que la única diferencia es que los hoteles fantasma tienen métodos adicionales para crear alfombras dentro de las habitaciones y añadir flores alrededor del borde del edificio. Eso significa que la clase hotel fantasma puede heredar todos los métodos de la clase casa fantasma. Entonces, lo único que necesita la clase hotel fantasma son dos métodos extra para las alfombras y las flores.</p>
<p class="indent">En IDLE, crea un nuevo archivo y guárdalo como hotelfantasma <em>.py</em> en la carpeta <em>clases</em>. Copia y pega en el archivo el código de la clase <span class="literal">Edificio</span> del programa <em>ghostHotel</em>.py.</p>
<p class="indent">Crea una nueva clase llamada <span class="literal">FancyBuilding</span> que herede de la clase <span class="literal">Building</span>. La clase <span class="literal">FancyBuilding</span> debe tener un nuevo método llamado <span class="literal">upgrade()</span> que añada alfombra dentro del edificio y flores alrededor de las paredes. <a href="ch12.xhtml#ch12ex5">El listado 12-5</a> muestra mi código para el método upgrade( <span class="literal">)</span>, pero siéntete libre de personalizar tus hoteles.</p>
<p class="sidenote" translate="no"><span class="blue"><em>ghostHotel.py</em></span></p>
<p class="programs" translate="no"><span class="red"># Create a FancyBuilding class here</span><br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">upgrade</span>(self):<br translate="no"/> <span class="red"># Carpet</span><br translate="no"/>        mc.setBlocks(self.x + 1, self.y, self.z + 1,<br translate="no"/>                     self.x + self.width - 1, self.y, self.z + self.depth - 1,<br translate="no"/>                     35, 6)<br translate="no"/><br translate="no"/> <span class="red"># Flowers</span><br translate="no"/>    mc.setBlocks(self.x - 1, self.y, self.z -1,<br translate="no"/>                 self.x - 1, self.y, self.z + self.depth + 1,<br translate="no"/>                 37)<br translate="no"/>    mc.setBlocks(self.x - 1, self.y, self.z - 1,<br translate="no"/>                 self.x + self.width + 1, self.y, self.z – 1,<br translate="no"/>                 37)<br translate="no"/>    mc.setBlocks(self.x + self.width + 1, self.y, self.z - 1,<br translate="no"/>                 self.x + self.width + 1, self.y, self.z + self.depth + 1,<br translate="no"/>                 37)<br translate="no"/>    mc.setBlocks(self.x - 1, self.y, self.z + self.depth + 1,<br translate="no"/>                 self.x + self.width + 1, self.y, self.z + self.depth = 1,<br translate="no"/>                 37)<br translate="no"/><br translate="no"/><span class="red"># Create an instance of the FancyBuilding class</span><br translate="no"/><span class="red"># Call the build() and upgrade() methods</span></p>
<p class="examplet"><a id="ch12ex5"></a><em>Listado 12-5: Un método de la</em> <em>clase</em> <span class="literal"><span class="codeitalic">FancyBuilding</span></span> que añade alfombra <em>y</em> flores al edificio</p>
<p class="indent">Cuando hayas creado la clase y añadido el nuevo método, crea una instancia de la clase <span class="literal">FancyBuilding</span> y llámala hotel <span class="literal">fantasma</span>. Construye el hotel fantasma con el método <span class="literal">build(</span> ) y, a continuación, añade los elementos adicionales con el método <span class="literal">upgrade()</span>.</p>
<p class="indent"><a href="ch12.xhtml#ch12fig6">La Figura 12-6</a> muestra mi elegante hotel fantasma.</p>
<div class="image"><span epub:type="pagebreak" id="page_281"></span><img alt="image" src="../images/f12-06.jpg" translate="no"/></div>
<p class="figcap"><a id="ch12fig6"></a><em>Figura 12-6: ¡Mira qué flores y qué alfombra!</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb04"><strong>OBJETIVO EXTRA: ALDEA FANTASMA</strong></p>
<p class="noindent">En la Misión nº 71, creaste un pueblo fantasma en el que todos los edificios parecían más o menos iguales. Es raro ver edificios idénticos en los pueblos reales. Cambia el programa del pueblo fantasma creando varias clases que hereden de la clase <span class="literal">Edificio</span>. Podrías crear una clase <span class="literal">Tienda</span>, una clase <span class="literal">Hospital</span> y una clase <span class="literal">Restaurante</span>, por ejemplo. Luego, cuando crees los objetos, podrás elegir qué tipo de edificio crear utilizando las distintas clases.</p>
</div>
<h3 class="h3" id="ch12lev1sec08"><span epub:type="pagebreak" id="page_282"></span><strong><span class="blue1">Sobrescribir métodos y atributos</span></strong></h3>
<p class="noindent">Una subclase puede redefinir métodos y atributos de su superclase. Esto es útil cuando quieres utilizar el mismo nombre para un método pero quieres que se comporte de forma diferente en la subclase.</p>
<p class="indent">En "<a href="ch12.xhtml#ch12lev1sec07">Comprender la herencia</a>", en <a href="ch12.xhtml#page_277">la página 277</a>, creamos una clase <span class="literal">Pájaro</span> y una clase <span class="literal">Pingüino</span>. La clase <span class="literal">Pingüino</span> heredó de <span class="literal">Ave</span>, por lo que compartió todos sus métodos. Pero los pingüinos no pueden volar, y su canto de pájaro es más un graznido que un gorjeo. Así que debemos cambiar los métodos <span class="literal">fly()</span> y <span class="literal">birdcall()</span> para reflejar esto. Abre <em>birdClass.py</em> y añade este código:</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no"> <span class="ash">class Penguin(Bird):</span><br translate="no"/> <span class="ash">def swim(self):</span><br translate="no"/> <span class="ash">print("swimming")</span><br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"sort of a quack"</span>)<br translate="no"/><br translate="no"/><span class="ent">➋</span> <span class="orange">def</span> <span class="blue1">fly</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"Penguins cannot fly :("</span>)</p>
<p class="indent">He hecho dos cambios en la clase <span class="literal">Pingüino</span>. He añadido un método birdcall( <span class="literal">)</span> <span class="ent">➊</span> y un método fly <span class="literal">()</span> <span class="ent">➋</span>. Como ambos métodos se escriben igual que en la superclase <span class="literal">Pájaro</span>, anularán los métodos de la superclase.</p>
<p class="indent">Llama a los métodos añadiendo este código a <em>clasepájaro.py</em>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no">sarahThePenguin.fly()<br translate="no"/>sarahThePenguin.birdcall()</p>
<p class="indent">Ahora, cuando ejecutes el programa, obtendrás este resultado:</p>
<p class="programs" translate="no"><span class="blue1">Penguins cannot fly :(</span><br translate="no"/><span class="blue1">sort of a quack</span></p>
<p class="indent">Anular un método de una superclase cambiará lo que hace el método para la subclase, pero no para la superclase. Así, los pingüinos no podrán volar, pero otros pájaros que hereden de <span class="literal">Pájaro</span> podrán volar.</p>
<p class="indent">También puedes sobrescribir el método <span class="literal">__init__()</span> en una subclase. Esto significa que cuando se crea el objeto de la subclase, puede tener atributos o comportamientos diferentes a los de la superclase.</p>
<p class="indent">Por ejemplo, creemos una subclase <span class="literal">Loro</span> de <span class="literal">Pájaro</span> en el mismo archivo. Los loros pueden ser de distintos colores, así que incluyamos un argumento extra en el método <span class="literal">__init__()</span> para un atributo de <span class="literal">color</span>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">class</span> <span class="blue1">Parrot</span>(Bird):<br translate="no"/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, wingspan, color):<br translate="no"/>           self.name = name<br translate="no"/>           self.wingspan = wingspan<br translate="no"/>           self.color = color</p>
<p class="indent"><span epub:type="pagebreak" id="page_283"></span>He incluido un nuevo método <span class="literal">__init__</span> () para la clase <span class="literal">Loro</span> que tiene un argumento extra, <span class="literal">color</span> <span class="ent">➊,</span> en comparación con la clase original <span class="literal">Pájaro</span>.</p>
<p class="indent">Ahora, cuando creamos un nuevo objeto <span class="literal">Loro</span>, podemos acceder al atributo <span class="literal">color</span>. También podemos acceder a los métodos <span class="literal">birdcall()</span> y <span class="literal">fly(</span> ) porque se heredaron de la superclase <span class="literal">Bird</span>:</p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no">freddieTheParrot = Parrot(<span class="green">"Freddie"</span>, 12, <span class="green">"blue"</span>)<br translate="no"/><span class="rose">print</span>(freddieTheParrot.color)<br translate="no"/>freddieTheParrot.fly()<br translate="no"/>freddieTheParrot.birdcall()</p>
<p class="indent">Este código producirá lo siguiente:</p>
<p class="programs" translate="no"><span class="blue1">blue</span><br translate="no"/><span class="blue1">flap</span><br translate="no"/><span class="blue1">chirp</span></p>
<p class="indent">Recuerda que puedes sobrescribir cualquier método que una subclase herede de una superclase; incluso puedes sobrescribir el método <span class="literal">__init__()</span>. Esto te da mucho control sobre los objetos y sus numerosos atributos y métodos.</p>
<p class="indent">Después de todos los cambios que hemos hecho en <em>clasepájaro.py</em>, el programa final tiene el siguiente aspecto. También está disponible en los recursos del libro en <em><a href="https://www.nostarch.com/programwithminecraft/">https://www.nostarch.com/programwithminecraft/.</a></em></p>
<p class="sidenote" translate="no"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs" translate="no"><span class="orange">class</span> <span class="blue1">Bird</span>(<span class="rose">object</span>):<br translate="no"/> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, wingspan):<br translate="no"/>        self.name = name<br translate="no"/>        self.wingspan = wingspan<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"chirp"</span>)<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">fly</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"flap"</span>)<br translate="no"/><br translate="no"/><br translate="no"/><span class="orange">class</span> <span class="blue1">Penguin</span>(Bird):<br translate="no"/> <span class="orange">def</span> <span class="blue1">swim</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"swimming"</span>)<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"sort of a quack"</span>)<br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">fly</span>(self):<br translate="no"/> <span class="rose">print</span>(<span class="green">"Penguins cannot fly :("</span>)<br translate="no"/><br translate="no"/><br translate="no"/><span class="orange">class</span> <span class="blue1">Parrot</span>(Bird):<br translate="no"/> <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, wingspan, color):<br translate="no"/>        self.name = name<br translate="no"/>        self.wingspan = wingspan<br translate="no"/>        self.color = color<br translate="no"/><br translate="no"/>gardenBird = Bird(<span class="green">"Geoffrey"</span>, 12)<br translate="no"/>gardenBird.birdcall()<br translate="no"/>gardenBird.fly()<br translate="no"/><br translate="no"/>sarahThePenguin = Penguin(<span class="green">"Sarah"</span>, 10)<br translate="no"/>sarahThePenguin.swim()<br translate="no"/>sarahThePenguin.fly()<br translate="no"/>sarahThePenguin.birdcall()<br translate="no"/><br translate="no"/>freddieTheParrot = Parrot(<span class="green">"Freddie"</span>, 12, <span class="green">"blue"</span>)<br translate="no"/><span class="rose">print</span>(freddieTheParrot.color)<br translate="no"/>freddieTheParrot.fly()<br translate="no"/>freddieTheParrot.birdcall()</p>
<p class="indent"><span epub:type="pagebreak" id="page_284"></span>Probarás a anular métodos y atributos en la próxima misión.</p>
<h4 class="h4a" id="ch12lev2sec10"><strong>Misión nº 73: Árbol fantasma</strong></h4>
<p class="noindent">Has creado varias formas de edificios fantasma. Llevémoslo al siguiente nivel y creemos un árbol fantasma. Es una idea increíble, pero ¿cómo podemos hacerlo? La clase <span class="literal">Edificio</span> es para edificios, que tienen paredes y techos; los árboles no tienen paredes ni techos. ¡No te preocupes! Puedes evitarlo modificando tu clase <span class="literal">Edificio</span> fantasma.</p>
<p class="indent">Al igual que los edificios fantasma, el árbol fantasma aparecerá y desaparecerá utilizando los métodos <span class="literal">build()</span> y <span class="literal">clear()</span>. Pero los métodos tienen que funcionar de forma diferente porque los árboles tienen un aspecto distinto al de las casas. Así que tienes que crear una clase que herede de la clase <span class="literal">Edificio</span> y anular los métodos build( <span class="literal">)</span> y clear( <span class="literal">)</span>.</p>
<p class="indent">Para empezar, he cogido la función que crea un árbol del archivo <em>forest.py</em><a href="ch08.xhtml#page_153">(página 153</a>) y la he puesto en <a href="ch12.xhtml#ch12ex6">el Listado 12-6</a>. Cópiala en un nuevo archivo llamado <em>ghostTree.py</em> en la carpeta de <em>clases</em>.</p>
<p class="sidenote" translate="no"><span class="blue"><em>ghostTree.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/><br translate="no"/> <span class="red"># Paste the ghostHouse.py program here</span><br translate="no"/> <span class="red"># Create a Tree class here</span><br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue1">growTree</span>(x, y, z):<br translate="no"/> <span class="green">""" Creates a tree at the coordinates given """</span><br translate="no"/>       wood = 17<br translate="no"/>       leaves = 18<br translate="no"/><br translate="no"/> <span class="red"># Trunk</span><br translate="no"/>       mc.setBlocks(x, y, z, x, y + 5, z, wood)<br translate="no"/><br translate="no"/> <span class="red"># Leaves</span><br translate="no"/>       mc.setBlocks(x - 2, y + 6, z - 2, x + 2, y + 6, z + 2, leaves)<br translate="no"/>       mc.setBlocks(x - 1, y + 7, z - 1, x + 1, y + 7, z + 1, leaves)<br translate="no"/><br translate="no"/><span class="red"># Create build() and clear() methods for the Tree class here</span></p>
<p class="examplet"><a id="ch12ex6"></a><em>Listado 12-6: Una función para crear un árbol</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_285"></span>Para terminar el programa, copia y pega el código de la clase <span class="literal">Edificio</span> de <em>ghostHouse.</em> py en el nuevo archivo. A continuación, crea una nueva clase llamada <span class="literal">Árbol</span> que herede de la clase <span class="literal">Edificio</span>. Dentro de la clase <span class="literal">Árbol</span>, añade un método <span class="literal">build()</span> y un método <span class="literal">clear()</span> para anular los métodos de la clase <span class="literal">Edificio</span> y construir un árbol en lugar de una casa. Asegúrate de incluir el argumento <span class="literal">self</span> delante de los atributos en el método final <span class="literal">growTree()</span> <span class="ent">➊.</span></p>
<p class="indent">Cuando hayas creado el programa, crea un objeto <span class="literal">Árbol</span> llamado árbol <span class="literal">fantasma</span>. Llama al método <span class="literal">build(</span> ) para que aparezca el árbol, espera un poco y luego haz que desaparezca utilizando <span class="literal">clear()</span>.</p>
<p class="indent"><a href="ch12.xhtml#ch12fig7">La Figura 12-7</a> muestra el resultado de mi programa.</p>
<div class="image"><img alt="image" src="../images/f12-07.jpg" translate="no"/></div>
<p class="figcap"><a id="ch12fig7"></a><em>Figura 12-7: ¡Es un árbol espeluznante!</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb05"><span epub:type="pagebreak" id="page_286"></span><strong>OBJETIVO EXTRA: BOSQUE FANTASMA</strong></p>
<p class="noindent">Modifica el código de <em>ghostTree.py</em> para construir un bosque fantasma. ¿Qué tipo de tesoros crees que podrías encontrar en un bosque fantasma?</p>
</div>
<h3 class="h3" id="ch12lev1sec09"><strong><span class="blue1">Lo que has aprendido</span></strong></h3>
<p class="noindent">Acabas de aprender los fundamentos de uno de los conceptos más importantes de la programación actual: ¡la programación orientada a objetos! Has aprendido a escribir una clase y a crear objetos, y has aprendido a utilizar la herencia para personalizar las clases y el comportamiento de los objetos. Podrás aplicar esta habilidad tan útil no sólo en Minecraft, ¡sino también en cualquier tipo de aventura de programación que decidas emprender a continuación!</p>
</body>
</html>