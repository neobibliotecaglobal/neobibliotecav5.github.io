<html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>Aprende a programar con Minecraft</title>
<link href="../styles/9781593276706.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:40af8c70-d268-482b-9282-0b537fc6ae71" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_127"></span><strong><span class="blue1"><span class="big">7</span></span></strong><br translate="no"/><strong>FIESTAS DE BAILE Y DESFILES DE FLORES CON BUCLES WHILE</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg" translate="no"/></div>
<p class="noindent"><em>Los</em> bucles facilitan la repetición del código una y otra vez. En lugar de copiar y pegar el mismo código, puedes utilizar un bucle para repetir el código tantas veces como quieras. En este capítulo utilizarás bucles para hacer que tus programas se repitan sin tener que volver a ejecutarlos. Nos centraremos en un tipo de bucle de Python conocido como bucle <span class="literal">while</span>.</p>
<h3 class="h3" id="ch07lev1sec01"><strong><span class="blue1">Un bucle while sencillo</span></strong></h3>
<p class="noindent">Los bucles <span class="literal">while</span> se utilizan para repetir bloques de código. Similar a las sentencias <span class="literal">if</span>, un bucle <span class="literal">while</span> ejecutará el código que contiene mientras una condición sea <span class="literal">Verdadera</span>. Es decir, debe cumplirse una condición para que se ejecute el cuerpo de la sentencia.</p>
<p class="indent">La diferencia entre un bucle <span class="literal">while</span> y una sentencia <span class="literal">if</span> es que el código de la sentencia <span class="literal">if</span> sólo se ejecuta una vez como máximo, mientras que el código del bucle <span class="literal">while</span> puede repetirse muchas veces. Los programadores llaman <em>iteración</em> a la repetición del código <em>.</em> Cuando un bucle se repite, se dice que <em>itera</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_128"></span>Por ejemplo, este código utiliza un bucle <span class="literal">while</span> para imprimir los números del 1 al 5:</p>
<p class="programs" translate="no">count = 1<br translate="no"/><span class="orange">while</span> count &lt;= 5:<br translate="no"/> <span class="rose">print</span>(count)<br translate="no"/>    count += 1<br translate="no"/><span class="rose">print</span>(<span class="green">"Loop finished"</span>)</p>
<p class="indent">La variable <span class="literal">count</span> registra el número de veces que se ha repetido el bucle. Comienza con el valor 1. La condición del bucle <span class="literal">while</span> comprueba si la cuenta es menor o igual que 5.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTA</span></strong></p>
<p class="notep"><em>En</em> el<em> <a href="ch03.xhtml#ch03">Capítulo 3</a> aprendiste que</em> <span class="literal"><span class="codeitalic">+=</span></span> <em>es un operador abreviado. Podrías utilizar el operador estándar de suma</em> <span class="literal"><span class="codeitalic">cuenta = cuenta + 1</span></span> <em>para hacer</em> lo mismo.</p>
</div>
<p class="indent">La primera vez que se ejecuta el bucle, el valor de <span class="literal">cuenta</span> es <span class="literal">1</span>, que es menor que 5. La condición del bucle es <span class="literal">Verdadero</span>, y el cuerpo del bucle se ejecuta. A continuación, el programa imprime el valor de la <span class="literal">cuenta</span> en el intérprete de comandos de Python, y luego añade 1 al valor de la <span class="literal">cuenta</span>. El bucle <span class="literal">while</span> vuelve a empezar y comprueba de nuevo la condición, pasando por cada paso hasta que la variable <span class="literal">count</span> sea mayor que 5.</p>
<p class="indent">Fuera del bucle hay una última línea, que imprime <span class="literal">"Bucle finalizado"</span>.</p>
<p class="indent">Guarda este programa y ejecútalo; deberías ver la siguiente salida:</p>
<p class="programs" translate="no"><span class="blue1">1</span><br translate="no"/><span class="blue1">2</span><br translate="no"/><span class="blue1">3</span><br translate="no"/><span class="blue1">4</span><br translate="no"/><span class="blue1">5</span><br translate="no"/><span class="blue1">Loop finished</span></p>
<p class="indent">Prueba a experimentar un poco con el código. Cambia las condiciones para que aparezcan más de 5 números o cambia la cantidad en que aumenta la variable de <span class="literal">recuento</span>. Aquí tienes un repaso de cómo funciona el código. La sentencia <span class="literal">while</span> sigue estos pasos</p>
<ol>
<li class="noindent"><p class="list">Comprueba si la condición es <span class="literal">Verdadera</span>.</p></li>
<li class="noindent"><p class="list">Si la condición es <span class="literal">Verdadera</span>:</p>
<ol type="a">
<li class="noindent"><p class="list">Ejecuta el cuerpo del código.</p></li>
<li class="noindent"><p class="list">Repite el paso 1.</p></li>
</ol></li>
<li class="noindent"><p class="list">Si la condición es <span class="literal">Falsa</span>:</p>
<ol type="a">
<li class="noindent"><p class="list">Ignora el cuerpo de código.</p></li>
</ol></li>
<li class="noindent"><p class="list">Continúa en la línea siguiente al bloque del bucle <span class="literal">while</span>.</p></li>
</ol>
<p class="indent">¡Intentemos utilizar un bucle <span class="literal">while</span> en Minecraft para teletransportarnos a un montón de sitios nuevos!</p>
<h4 class="h4a" id="ch07lev2sec01"><span epub:type="pagebreak" id="page_129"></span><strong>Misión nº 33: Un viaje de teletransporte aleatorio</strong></h4>
<p class="noindent">En la Misión nº 3<a href="ch02.xhtml#page_44">(página 44</a>), teletransportaste al jugador a distintas posiciones del juego. Vamos a reescribir ese programa utilizando un bucle <span class="literal">while</span> para que puedas repetir el teletransporte una y otra vez.</p>
<p class="indent">Mediante un bucle de código que teletransportará al jugador a un lugar aleatorio, puedes hacer que el programa sea más potente <em>y</em> mucho más fácil de leer. Mola, ¿eh?</p>
<p class="indent">El siguiente código teletransportará al jugador a un lugar aleatorio una vez, eligiendo valores aleatorios en el mundo del juego para las variables <span class="literal">x</span>, <span class="literal">y</span> y <span class="literal">z</span>. Luego fijará la posición del jugador utilizando esas variables.</p>
<p class="programs" translate="no"> <span class="orange">import</span> random<br translate="no"/> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="red"># Add the count variable here</span><br translate="no"/><span class="ent">➋</span> <span class="red"># Start the while loop here</span><br translate="no"/><span class="ent">➌</span> x = random.randint(-127, 127)  <span class="red"># Indent the code from this line</span><br translate="no"/>   y = random.randint(0, 64)<br translate="no"/>   z = random.randint(-127, 127)<br translate="no"/><br translate="no"/>   mc.player.setTilePos(x, y, z)<br translate="no"/><span class="ent">➍</span> <span class="red"># Add 1 to the value of the count variable here</span></p>
<p class="indent">Ahora mismo, sin embargo, el código sólo teletransportará al jugador una vez. Aunque eso está muy bien, puedes hacerlo totalmente genial. Escribamos un bucle para que el código se repita cinco veces, convirtiéndolo en todo un viaje relámpago.</p>
<p class="indent">Para cambiar el código y utilizar un bucle, sigue estos cuatro pasos:</p>
<ol>
<li class="noindent"><p class="list">Crea una variable de <span class="literal">recuento</span> para controlar el bucle <span class="ent">➊.</span></p></li>
<li class="noindent"><p class="list">Añade un bucle <span class="literal">while</span> con una condición basada en <span class="literal">el</span> recuento <span class="ent">➋.</span></p></li>
<li class="noindent"><p class="list">Sangrar el cuerpo de la sentencia <span class="literal">while</span> <span class="ent">➌.</span></p></li>
<li class="noindent"><p class="list">Incrementa el valor de <span class="literal">count</span> con cada bucle <span class="ent">➍.</span></p></li>
</ol>
<p class="indent">La finalidad de la variable <span class="literal">count</span> y del incremento de <span class="literal">count</span> es llevar la cuenta del número de veces que se ha repetido el bucle. Hablaré más sobre ellos en la siguiente sección. Por ahora, todo lo que necesitas saber es que <span class="literal">count</span> nos permite controlar cuántas veces se repite este código.</p>
<p class="indent"><a href="ch07.xhtml#ch7ex1">El listado 7-1</a> muestra el código con los cambios añadidos.</p>
<p class="sidenote" translate="no"><span class="blue"><em>randomTeleport.py</em></span></p>
<p class="programs" translate="no"><span class="orange">import</span> random<br translate="no"/><span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>mc = Minecraft.create()<br translate="no"/><br translate="no"/>count = 0<br translate="no"/><span class="orange">while</span> count &lt; 5:<br translate="no"/>    x = random.randint(-127, 127)<br translate="no"/>    y = random.randint(0, 64)<br translate="no"/>    z = random.randint(-127, 127)<br translate="no"/>    mc.player.setTilePos(x, y, z)<br translate="no"/>    count += 1</p>
<p class="examplet"><span epub:type="pagebreak" id="page_130"></span><a id="ch7ex1"></a><em>Listado 7-1: Código para teletransportar aleatoriamente al jugador por el mundo del juego</em></p>
<p class="indent">Copia <a href="ch07.xhtml#ch7ex1">el Listado 7-1</a> en un nuevo archivo, guárdalo como <em>randomTeleport.py</em> en una nueva carpeta llamada <em>whileLoops</em>, y ejecuta el código. Deberías ver cómo el jugador se desplaza por el mundo de Minecraft. ¡Pero el código se ejecuta demasiado rápido! Todo el viaje termina en menos de un segundo. Vamos a arreglarlo juntos.</p>
<p class="indent">Utilizarás el módulo de <span class="literal">tiempo</span> para ralentizar el código. Sigue estos pasos:</p>
<ol>
<li class="noindent"><p class="list">En la primera línea del programa, añade la sentencia <span class="literal">import time</span>. Esto importa el módulo <span class="literal">tiempo</span> de Python, que contiene un conjunto de prácticas funciones relacionadas con el tiempo y otras cosas.</p></li>
<li class="noindent"><p class="list">Añade la línea <span class="literal">time.sleep(10)</span> al final del cuerpo de tu bucle <span class="literal">while</span> para añadir un retardo de 10 segundos a tu programa. ¡Asegúrate de sangrar esta nueva línea final de tu programa para que quede dentro del bucle <span class="literal">while</span>!</p></li>
</ol>
<p class="indent">Guarda el programa y ejecútalo. Ahora el jugador debería teletransportarse a un nuevo lugar aleatorio cada 10 segundos. <a href="ch07.xhtml#ch7fig1">La Figura 7-1</a> muestra mi programa en ejecución.</p>
<div class="image"><img alt="image" src="../images/f07-01.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig1"></a><em>Figura 7-1: Cada 10 segundos, el programa me teletransporta a un nuevo lugar.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch07sb01"><span epub:type="pagebreak" id="page_131"></span><strong>OBJETIVO EXTRA: DUERME TRANQUILO</strong></p>
<p class="noindent">De momento, el programa esperará 10 segundos al final de cada bucle. ¿Qué ocurre si mueves la sentencia <span class="literal">time.sleep(10)</span> al inicio del bucle?</p>
</div>
<h3 class="h3" id="ch07lev1sec02"><strong><span class="blue1">Controlar bucles con una variable de recuento</span></strong></h3>
<p class="noindent">Las variables de recuento son una forma habitual de almacenar el número de veces que se ha repetido un programa. Ya has visto estas variables en acción unas cuantas veces. Veamos otro ejemplo:</p>
<p class="programs" translate="no">count = 0<br translate="no"/><span class="orange">while</span> count &lt; 5:<br translate="no"/> <span class="rose">print</span>(count)<br translate="no"/>    count += 1</p>
<p class="indent">La condición del bucle <span class="literal">while</span> comprueba que el valor de la variable de <span class="literal">recuento</span> es menor que 5. En el cuerpo del bucle, he cambiado el valor de la variable <span class="literal">cuenta</span> para registrar el número de veces que se ha repetido la cuenta. Añadir al valor de una variable de <span class="literal">recuento</span> se llama <em>incrementar</em>.</p>
<p class="indent">La última línea de este código incrementa en 1 el valor de la variable de <span class="literal">recuento</span>. Cada vez que se repita el código, comprobará el nuevo valor de la variable de <span class="literal">recuento</span> para ver si es menor que 5. Cuando sea igual o mayor que 5, el bucle se detendrá.</p>
<p class="indent">Si te olvidas de incrementar la variable <span class="literal">count</span>, acabarás con un <em>bucle infinito</em>, que repetirá el bucle eternamente, como se muestra en el siguiente ejemplo:</p>
<p class="programs" translate="no">count = 0<br translate="no"/><span class="orange">while</span> count &lt; 5:<br translate="no"/> <span class="rose">print</span>(count)</p>
<p class="indent">El valor de <span class="literal">count</span> es siempre 0 porque nunca se incrementa. Por lo tanto, la condición del bucle siempre será <span class="literal">Verdadero</span>, y el bucle se repetirá <em>eternamente</em>. Si no me crees, ¡prueba a ejecutar el código!</p>
<p class="programs" translate="no"><span class="blue1">0</span><br translate="no"/><span class="blue1">0</span><br translate="no"/><span class="blue1">0</span><br translate="no"/><span class="blue1">0</span><br translate="no"/><span class="blue1">0</span><br translate="no"/>--<span class="codeitalic">snip</span>--</p>
<p class="indent"><span epub:type="pagebreak" id="page_132"></span>Para interrumpir la ejecución de este programa infinito, pulsa <small>CTRL-C</small>. Para corregir el código, sólo tienes que añadir la <span class="literal">cuenta de líneas += 1</span> al cuerpo del bucle. Ahora no quedarás atrapado en un bucle infinito. ¡Uf!</p>
<p class="indent">Los recuentos no siempre tienen que incrementarse en 1. En algunas situaciones puedes querer incrementar el recuento en un valor diferente. En el siguiente ejemplo, la cuenta se incrementa en 2 cada vez; el resultado es que el código imprime todos los números pares entre 0 y 100:</p>
<p class="programs" translate="no">count = 0<br translate="no"/><span class="orange">while</span> count &lt; 100:<br translate="no"/> <span class="rose">print</span>(count)<br translate="no"/>    count += 2</p>
<p class="indent">También puedes contar hacia atrás utilizando un número negativo para <em>disminuir</em> el valor de la cuenta. El siguiente código cuenta <em>hacia</em> atrás desde 100 hasta 1:</p>
<p class="programs" translate="no">count = 100<br translate="no"/><span class="orange">while</span> count &gt; 0:<br translate="no"/> <span class="rose">print</span>(count)<br translate="no"/>    count -= 1</p>
<p class="indent">La única diferencia entre este ejemplo y los anteriores es la condición. Aquí he utilizado un comparador mayor que<span class="literal">(&gt;)</span>. Mientras la cuenta sea mayor que 0, el bucle continúa; cuando la cuenta llega a 0, el bucle se detiene.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTA</span></strong></p>
<p class="notep"><em>La variable utilizada para controlar un bucle no siempre se llama</em> <span class="literal"><span class="codeitalic">recuento</span></span><em>.</em><em> Podrías llamarla</em> <span class="literal"><span class="codeitalic">repeticiones</span></span> <em>o cualquier otra cosa que desees. Si miras el código de otras personas, verás una gran variedad de nombres diferentes.</em></p>
</div>
<h4 class="h4a" id="ch07lev2sec02"><strong>Misión 34: La maldición acuosa</strong></h4>
<p class="noindent">Intentemos algo un poco desagradable y escribamos una maldición para el jugador que dure poco tiempo. Las maldiciones en los videojuegos pueden <em>debilitar</em> al personaje de alguna manera, como ralentizándolo o debilitándolo, a menudo sólo durante un rato.</p>
<p class="indent">Crearemos un programa de maldición que coloque un bloque de agua que fluya en la posición del jugador una vez por segundo durante 30 segundos. Esto hará que al jugador le resulte difícil moverse sin ser empujado por el agua que fluye.</p>
<p class="indent">El siguiente código coloca un bloque de agua que fluye en la posición del jugador:</p>
<p class="sidenote" translate="no"><span class="blue"><em>waterCurse.py</em></span></p>
<p class="programs" translate="no"><span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>mc = Minecraft.create()<br translate="no"/><br translate="no"/>pos = mc.player.getPos()<br translate="no"/>mc.setBlock(pos.x, pos.y, pos.z, 8)</p>
<p class="indent"><span epub:type="pagebreak" id="page_133"></span>Este código colocará un bloque de agua en la posición actual del jugador sólo una vez. Tu tarea es hacer que se repita. El código final debe repetirse 30 veces, y cada iteración del bucle debe durar 1 segundo.</p>
<p class="indent">Guarda este código como <em>waterCurse.py</em> en la carpeta <em>whileLoops</em> y ejecútalo una vez para asegurarte de que funciona. Deberías ver aparecer un único bloque de agua en la posición del jugador antes de que el programa se detenga.</p>
<p class="indent">Vamos a ver qué hay que añadir a continuación para que esta maldición dure. Utiliza lo que has aprendido sobre los bucles <span class="literal">while</span> y las variables de <span class="literal">recuento</span> para hacer lo siguiente:</p>
<ol>
<li class="noindent"><p class="list">Añade una variable de <span class="literal">recuento</span> al programa.</p></li>
<li class="noindent"><p class="list">Añade un bucle al programa para repetir las dos últimas líneas de código. El bucle debe repetirse 30 veces.</p></li>
<li class="noindent"><p class="list">Incrementa la variable <span class="literal">cuenta</span> al final del bucle.</p></li>
<li class="noindent"><p class="list">Importa el módulo de <span class="literal">tiempo</span> (en la primera línea de tu programa) y añade una suspensión de 1 segundo en la última línea del bucle <span class="literal">while</span>.</p></li>
</ol>
<p class="indent">Guarda el programa y pruébalo. Mientras caminas por el mundo del juego, el programa debería crear un bloque de agua cada segundo durante 30 segundos. Si te quedas atascado, vuelve a los pasos de la Misión nº 33<a href="ch07.xhtml#page_129">(página 129</a>) para obtener ayuda.</p>
<p class="indent">La<a href="ch07.xhtml#ch7fig2">Figura 7-2</a> muestra la maldición en acción.</p>
<div class="image"><img alt="image" src="../images/f07-02.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig2"></a><em>Figura 7-2: ¡Oh, no! Me persigue una pequeña inundación.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch07sb02"><strong>OBJETIVO EXTRA: UNA INUNDACIÓN MÁS RÁPIDA</strong></p>
<p class="noindent">¿Cómo harías que el bucle se repitiera el doble de rápido (cada medio segundo) sin dejar de durar 30 segundos?</p>
</div>
<h4 class="h4" id="ch07lev2sec03"><span epub:type="pagebreak" id="page_134"></span><strong><span class="blue1">Bucles while infinitos</span></strong></h4>
<p class="noindent">En la mayoría de los casos, es muy importante que la condición booleana de tu bucle <span class="literal">while</span> se convierta finalmente en <span class="literal">Falso</span>; de lo contrario, el bucle iterará eternamente y tu ordenador podría bloquearse.</p>
<p class="indent">Pero hay ocasiones en las que puedes querer programar un bucle infinito. Por ejemplo, los videojuegos suelen utilizar un bucle infinito para comprobar la entrada del usuario y gestionar el movimiento del jugador. Por supuesto, estos videojuegos incluyen un botón de Salir para que puedas pausar o detener los bucles infinitos cuando necesites tomarte un descanso.</p>
<p class="indent">Una forma sencilla de crear un bucle infinito es utilizar una condición <span class="literal">Verdadero</span> al definir un bucle <span class="literal">while</span>, como se muestra aquí:</p>
<p class="programs" translate="no"><span class="orange">while True</span>:<br translate="no"/> <span class="rose">print</span>(<span class="green">"Hello"</span>)</p>
<p class="indent">Este código se repetirá eternamente, imprimiendo la cadena <span class="literal">"Hola"</span> una y otra vez. Tanto si pretendías crear un bucle infinito como si no, pulsar <small>CTRL-C</small> en el intérprete de comandos de Python es una forma habitual de detenerlo. En IDLE puedes seleccionar <strong>Shell</strong> <img alt="image" src="../images/arrow.jpg" translate="no"/> <strong>Reiniciar Shell</strong> para detener también el bucle.</p>
<p class="indent">Ten en cuenta que cualquier código que se coloque <em>después de</em> un bucle <span class="literal">while</span> infinito nunca se ejecutará. En el siguiente ejemplo, la última línea de código es inalcanzable debido al bucle <span class="literal">while</span> infinito que le precede:</p>
<p class="programs" translate="no"><span class="orange">while True</span>:<br translate="no"/> <span class="rose">print</span>(<span class="green">"Hello"</span>)<br translate="no"/><span class="rose">print</span>(<span class="green">"This line is never reached"</span>)</p>
<p class="indent">Aunque los bucles infinitos a veces pueden ser complicados, también puedes crearlos para hacer un montón de cosas chulas. ¡Intentémoslo a continuación!</p>
<h4 class="h4a" id="ch07lev2sec04"><strong>Misión 35: Camino de flores</strong></h4>
<p class="noindent">El programa que escribirás en esta misión es como el de la Misión 34, pero en lugar de colocar bloques de agua, crearás un rastro de flores detrás del jugador. ¡Las flores son mucho más bonitas que las inundaciones!</p>
<p class="indent">Abre el archivo <em>waterCurse.py</em> en la carpeta <em>whileLoops</em> y guárdalo como <em>flowerTrail.py</em>.</p>
<p class="indent">Para que aparezca un rastro infinito de flores mientras el jugador camina por el juego, haz los siguientes cambios en el programa:</p>
<ol>
<li class="noindent"><p class="list">Cambia la condición del bucle <span class="literal">while</span> a <span class="literal">True</span>.</p></li>
<li class="noindent"><p class="list">Elimina la variable <span class="literal">cuenta</span> y el incremento.</p></li>
<li class="noindent"><p class="list">Cambia el argumento del tipo de bloque en la función <span class="literal">setBlock()</span> de <span class="literal">8</span> a <span class="literal">38</span>.</p></li>
<li class="noindent"><p class="list">Reduce el valor del argumento en la función <span class="literal">sleep</span> () a <span class="literal">0,2</span> para que aparezcan cinco flores cada segundo.</p></li>
<li class="noindent"><p class="list">Guarda el programa y ejecútalo. <a href="ch07.xhtml#ch7fig3">La Figura 7-3</a> muestra lo que deberías ver.</p></li>
</ol>
<div class="image"><span epub:type="pagebreak" id="page_135"></span><img alt="image" src="../images/f07-03.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig3"></a><em>Figura 7-3: ¡Mira qué flores más bonitas!</em></p>
<div class="sidebar">
<p class="sidebart" id="ch07sb03"><strong>OBJETIVO EXTRA: UN RASTRO DE DESTRUCCIÓN</strong></p>
<p class="noindent">El programa <em>flowerTrail.py</em> es muy flexible. Prueba a cambiar el tipo de bloque que coloca el programa. Un tipo de bloque divertido es el TNT explosivo<span class="literal">(setBlock(x, y, z, 46, 1)</span>). Fíjate en el argumento extra <span class="literal">1</span> después de <span class="literal">46</span>, que es el tipo de bloque TNT. El <span class="literal">1</span> establece el estado del TNT para que detone con sólo golpearlo, sin necesidad de pedernal y acero. ¡Sólo tienes que pulsar el botón izquierdo del ratón unas cuantas veces cuando apuntes a la TNT para hacerla explotar!</p>
</div>
<h3 class="h3" id="ch07lev1sec03"><strong><span class="blue1">Condiciones extravagantes</span></strong></h3>
<p class="noindent">Como los bucles <span class="literal">while</span> esperan un valor booleano para su condición, puedes utilizar cualquiera de los comparadores y operadores booleanos que has aprendido hasta ahora. Por ejemplo, ya has visto que los operadores mayor que y menor que funcionan igual que en capítulos anteriores.</p>
<p class="indent">Pero también puedes controlar los bucles <span class="literal">while</span> con comparadores y operadores booleanos de otras formas. ¡Echemos un vistazo!</p>
<p class="indent">Empezaremos escribiendo una condición más interactiva. El siguiente código crea la variable <span class="literal">continueAnswer</span> antes de que se inicie el bucle y comprueba que el valor es igual a <span class="literal">"Y"</span>. Ten en cuenta que no podemos utilizar la palabra <span class="literal">continuar</span> como nombre de variable porque es una palabra reservada en Python.</p>
<p class="programs" translate="no">continueAnswer <span class="green">= "Y"</span><br translate="no"/>coins = 0<br translate="no"/><span class="orange">while</span> continueAnswer == <span class="green">"Y"</span>:<br translate="no"/>    coins = coins + 1<br translate="no"/>    continueAnswer = input("C<span class="green">ontinue? Y/N")</span><br translate="no"/><span class="rose">print</span>(<span class="green">"You have</span> " + <span class="rose">str</span>(coins) <span class="green">+ " coins"</span>)</p>
<p class="indent"><span epub:type="pagebreak" id="page_136"></span>En la última línea del bucle <span class="literal">while</span>, el programa pide una entrada al usuario. Si el usuario pulsa algo más que <span class="literal">"Y</span> " como respuesta, el bucle saldrá. El usuario puede pulsar repetidamente Y y Y y Y, y cada vez el valor de la variable <span class="literal">monedas</span> aumentará en 1.</p>
<p class="indent">Observa que la variable que se comprueba, <span class="literal">continuarRespuesta</span>, se crea antes de que se inicie el bucle. Si no fuera así, el programa mostraría un error. Por eso, la variable que utilizamos para comprobar la condición debe existir antes de que intentemos utilizarla, y debe ser <span class="literal">Verdadera</span> cuando el programa llegue al bucle <span class="literal">while</span> la primera vez; de lo contrario, la condición no se cumplirá, y la sentencia del cuerpo del bucle while nunca se ejecutará.</p>
<h4 class="h4a" id="ch07lev2sec05"><strong>Misión 36: Concurso de inmersión</strong></h4>
<p class="noindent">Vamos a divertirnos un poco con los bucles <span class="literal">while</span> y el comparador igual a<span class="literal">(==</span>). En esta misión, crearás un minijuego en el que el jugador se sumerja bajo el agua todo el tiempo que pueda. El programa registrará cuántos segundos permanece bajo el agua y mostrará su puntuación al final del programa. Para felicitar al jugador, el programa le regalará flores si permanece bajo el agua más de 6 segundos.</p>
<p class="indent">Aquí tienes algo de código para empezar:</p>
<p class="sidenote" translate="no"><span class="blue"><em>divingContest.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/> <span class="orange">import</span> time<br translate="no"/><br translate="no"/>   score = 0<br translate="no"/>   pos = mc.player.getPos()<br translate="no"/><span class="ent">➊</span> blockAbove = mc.getBlock(pos.x, pos.y + 2, pos.z)<br translate="no"/><br translate="no"/><span class="ent">➋</span> <span class="red"># Add a while loop here</span><br translate="no"/>   time.sleep(1)<br translate="no"/>   pos = mc.player.getPos()<br translate="no"/><span class="ent">➌</span> blockAbove = mc.getBlock(pos.x, pos.y + 2, pos.z)<br translate="no"/><span class="ent">➍</span> score = score + 1<br translate="no"/>   mc.postToChat(<span class="green">"Current score: "</span> + <span class="rose">str</span>(score))<br translate="no"/><br translate="no"/>   mc.postToChat(<span class="green">"Final score: "</span> + <span class="rose">str</span>(score))<br translate="no"/><br translate="no"/><span class="ent">➎</span> <span class="orange">if</span> score &gt; 6:<br translate="no"/>       finalPos = mc.player.getTilePos()<br translate="no"/>       mc.setBlocks(finalPos.x - 5, finalPos.y + 10, finalPos.z - 5,<br translate="no"/>                    finalPos.x + 5, finalPos.y + 10, finalPos.z + 5, 38)</p>
<p class="indent">Guarda el programa como <em>divingContest.py</em> en tu carpeta <em>whileLoops</em>. La variable <span class="literal">puntuación</span> lleva la cuenta de cuántos segundos permanece el jugador bajo el agua.</p>
<p class="indent">Ejecuta el código para ver qué ocurre. De momento, el programa no está completo: sólo comprueba una vez si el jugador está bajo el agua y luego termina.</p>
<p class="indent"><span epub:type="pagebreak" id="page_137"></span>Antes de arreglar esto, veamos qué hace el resto del código. La variable <span class="literal">bloqueEncima</span> almacena el tipo de bloque situado en la cabeza del jugador <span class="ent">➊.</span> Por ejemplo, si la cabeza del jugador está bajo el agua, esta variable almacenará un valor de 8 (lo que significa que el bloque es agua). Más adelante en el código, volverás a establecer <span class="literal">blockAbove</span> para que almacene el valor del bloque situado encima de la cabeza del jugador <span class="ent">➌</span>, de modo que cuando crees tu bucle <span class="literal">while</span>, actualizará <span class="literal">blockAbove</span> con el bloque actual situado encima de la cabeza del jugador. En <span class="ent">➍,</span> el programa añade 1 punto al total por cada segundo que el jugador esté bajo el agua, y en <span class="ent">➎,</span> utiliza una sentencia <span class="literal">if</span> para crear una lluvia de flores sobre el jugador si la puntuación es superior a 6.</p>
<p class="indent">Te toca añadir un bucle al programa que utilice la variable <span class="literal">bloqueSobre</span> como condición en <span class="ent">➋.</span> Haz que el bucle <span class="literal">while</span> compruebe si <span class="literal">bloqueSobre</span> es igual a agua (bloque de tipo 8) o igual a agua corriente (bloque de tipo 9). Puedes utilizar la siguiente condición en el bucle while para comprobarlo: <span class="literal">while bloqueEncima == 8 o bloqueEncima == 9</span>. Esto comprueba si el jugador está actualmente bajo el agua y seguirá comprobando si el jugador está bajo el agua cada vez que se repita el bucle.</p>
<p class="indent">Para probar tu programa, busca un poco de agua que tenga al menos tres bloques de profundidad y sumérgete en ella. El programa sólo se ejecutará si ya estás bajo el agua. Cuando ejecutes el programa, debería empezar a mostrar cuántos segundos has estado bajo el agua. Al cabo de un rato, nada hasta la superficie. El programa mostrará tu puntuación y te colmará de flores si has estado bajo el agua 6 segundos o más. La <a href="ch07.xhtml#ch7fig4">Figura 7-4</a> muestra al jugador bajo el agua y la puntuación que se muestra. La Figura <a href="ch07.xhtml#ch7fig5">7-5</a> muestra las flores que aparecen cuando ganas.</p>
<div class="image"><img alt="image" src="../images/f07-04.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig4"></a><em>Figura 7-4: Estoy aguantando la respiración bajo el agua, y se muestra el número de segundos que he estado bajo el agua.</em></p>
<div class="image"><span epub:type="pagebreak" id="page_138"></span><img alt="image" src="../images/f07-05.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig5"></a><em>Figura 7-5: ¡He ganado mi propia celebración florida!</em></p>
<div class="sidebar">
<p class="sidebart" id="ch07sb04"><strong>OBJETIVO EXTRA: UN GANADOR ERES TÚ</strong></p>
<p class="noindent">Prueba a añadir premios extra escribiendo más código en la sentencia <span class="literal">if</span> al final del programa. Si el jugador obtiene una puntuación alta, podrías darle un bloque de oro. Prueba a añadir varios niveles de dificultad con premios diferentes para cada uno.</p>
</div>
<h4 class="h4" id="ch07lev2sec06"><strong><span class="blue1">Operadores booleanos y bucles while</span></strong></h4>
<p class="noindent">Puedes utilizar operadores booleanos como <em>y</em>, <em>o</em>, y <em>no</em> con un bucle <span class="literal">while</span> cuando quieras que el bucle utilice más de una condición. Por ejemplo, el siguiente bucle iterará mientras el usuario no haya introducido la contraseña correcta y haya hecho tres intentos o menos:</p>
<p class="programs" translate="no">   password = <span class="green">"cats"</span><br translate="no"/>   passwordInput = <span class="rose">input</span>(<span class="green">"Please enter the password: "</span>)<br translate="no"/>   attempts = 0<br translate="no"/><span class="ent">➊</span> <span class="orange">while</span> password != passwordInput <span class="orange">and</span> attempts &lt; 3:<br translate="no"/><span class="ent">➋</span>     attempts += 1<br translate="no"/><span class="ent">➌</span>     passwordInput = input(<span class="green">"Incorrect. Please enter the password: "</span>)<br translate="no"/><span class="ent">➍</span> <span class="orange">if</span> password == passwordInput:<br translate="no"/> <span class="rose">print</span>(<span class="green">"Password accepted."</span>)</p>
<p class="indent">La condición del bucle <span class="literal">while</span> <span class="ent">➊</span> realiza dos tareas: comprueba si la contraseña es diferente de la introducida por el usuario<span class="literal">(contraseña != contraseñaEntrada</span>) y comprueba si el usuario ha intentado introducir la contraseña tres veces o menos<span class="literal">(intentos &lt; 3</span>). El operador <span class="literal">and</span> permite que el bucle <span class="literal">while</span> compruebe ambas condiciones al mismo tiempo. Si la condición es <span class="literal">False</span>, el bucle incrementa la variable <span epub:type="pagebreak" id="page_139"></span><span class="literal">intent</span> os <span class="ent">➋</span> y pide al usuario que vuelva a introducir la contraseña <span class="ent">➌.</span> El bucle finalizará si el usuario introduce la contraseña correcta o la variable <span class="literal">intentos</span> es mayor que 3. Una vez finalizado el bucle, el programa mostrará <span class="literal">Contraseña aceptada</span> sólo si el usuario ha introducido la contraseña correcta <span class="ent">➍.</span></p>
<h4 class="h4" id="ch07lev2sec07"><strong><span class="blue1">Comprobar un rango de valores en bucles while</span></strong></h4>
<p class="noindent">También puedes comprobar valores en un rango determinado utilizando un bucle <span class="literal">while</span>. Por ejemplo, el siguiente código comprueba si el valor que ha introducido el usuario está entre 0 y 10. Si no lo está, el bucle saldrá.</p>
<p class="programs" translate="no">   position = 0<br translate="no"/><span class="ent">➊</span> <span class="orange">while</span> 0 &lt;= position &lt;= 10:<br translate="no"/>       position = <span class="rose">int</span>(<span class="rose">input</span>(<span class="green">"Enter your position 0-10: "</span>))<br translate="no"/> <span class="rose">print</span>(position)</p>
<p class="indent">Si la variable de <span class="literal">posición</span> es mayor que 10, el bucle no se repetirá <span class="ent">➊.</span> Lo mismo ocurrirá si el valor es menor que 0. Esto es útil en Minecraft cuando compruebas si la posición del jugador se encuentra en una determinada zona del juego, como verás en la siguiente misión.</p>
<h4 class="h4a" id="ch07lev2sec08"><strong>Misión 37: Hacer una pista de baile</strong></h4>
<p class="noindent">¡Es hora de bailar! Pero antes de que puedas hacer unos buenos movimientos, necesitarás una pista de baile. El programa de esta misión generará una pista de baile que parpadeará con colores diferentes cada medio segundo mientras el jugador permanezca en la pista.</p>
<p class="indent">A continuación se muestra el inicio del código. Crea una pista de baile en la posición actual del jugador y utiliza una sentencia <span class="literal">if</span> para cambiar los colores. Pero el código no está completo.</p>
<p class="sidenote" translate="no"><span class="blue"><em>danceFloor.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/> <span class="orange">import</span> time<br translate="no"/><br translate="no"/>   pos = mc.player.getTilePos()<br translate="no"/>   floorX = pos.x – 2<br translate="no"/>   floorY = pos.y - 1<br translate="no"/>   floorZ = pos.z – 2<br translate="no"/>   width = 5<br translate="no"/>   length = 5<br translate="no"/>   block = 41<br translate="no"/><span class="ent">➊</span> mc.setBlocks(floorX, floorY, floorZ,<br translate="no"/>                floorX + width, floorY, floorZ + length, block)<br translate="no"/><br translate="no"/><span class="ent">➋</span> <span class="orange">while</span> floorX &lt;= pos.x &lt;= floorX + width <span class="orange">and</span> <span class="red"># Check z is within the floor</span><br translate="no"/><span class="ent">➌</span> <span class="orange">if</span> block == 41:<br translate="no"/>           block = 57<br translate="no"/> <span class="orange">else</span>:<br translate="no"/>           block = 41<br translate="no"/><br translate="no"/>    mc.setBlocks(floorX, floorY, floorZ,<br translate="no"/>                 floorX + width, floorY, floorZ + length, block)<br translate="no"/>    pos = mc.player.getTilePos()<br translate="no"/>    time.sleep(0.5)</p>
<p class="indent"><span epub:type="pagebreak" id="page_140"></span>Abre IDLE, crea un nuevo archivo y guarda el programa como pista de <em>baile.py</em> en la carpeta <em>whileLoops</em>. El código construye la pista de baile basándose en la posición actual del jugador <span class="ent">➊</span> y almacena la ubicación y el tamaño de la pista de baile en las variables <span class="literal">floorX</span>, <span class="literal">floorY</span>, <span class="literal">floorZ</span>, <span class="literal">width</span> y <span class="literal">length</span>. Dentro del bucle <span class="literal">while</span>, el código utiliza una sentencia <span class="literal">if</span> para alternar los bloques de los que está hecha la pista de baile <span class="ent">➌,</span> haciendo que la pista de baile parezca que parpadea.</p>
<p class="indent">Para que el programa funcione correctamente, tienes que cambiar la condición del bucle <span class="literal">while</span> para comprobar si la coordenada z del jugador está en la pista de baile <span class="ent">➋.</span> En otras palabras, comprueba si <span class="literal">pos.z</span> es mayor o igual que <span class="literal">floorZ</span> y menor o igual que <span class="literal">floorZ</span> más <span class="literal">la longitud</span>. Como orientación, mira cómo he comprobado si pos. <span class="literal">x</span> está en la pista de baile utilizando<span class="literal">(sueloX &lt;= pos.x &lt;= sueloX + anchura</span>). ¡La <a href="ch07.xhtml#ch7fig6">Figura 7-6</a> muestra la pista de baile en acción!</p>
<div class="image"><img alt="image" src="../images/f07-06.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig6"></a><em>Figura 7-6: Mostrando mis movimientos en la pista de baile.</em></p>
<p class="indent">Cuando hayas terminado el programa, guárdalo y ejecútalo. Debería aparecer una pista de baile debajo del reproductor y cambiar cada medio segundo. Baila un poco en <span epub:type="pagebreak" id="page_141"></span>, ¡diviértete! Cuando hayas terminado, sal de la pista de baile y asegúrate de que deja de parpadear. No volverá a encenderse a menos que vuelvas a ejecutar el programa para crear una nueva pista de baile.</p>
<div class="sidebar">
<p class="sidebart" id="ch07sb05"><strong>OBJETIVO EXTRA: SE ACABÓ LA FIESTA</strong></p>
<p class="noindent">Cuando el jugador haya terminado de bailar en la pista de baile, haz que ésta desaparezca. Para ello, cambia la pista de baile a aire cuando termine el bucle.</p>
</div>
<h4 class="h4" id="ch07lev2sec09"><strong><span class="blue1">Sentencias if anidadas y bucles while</span></strong></h4>
<p class="noindent">Puedes escribir programas más potentes utilizando sentencias <span class="literal">if</span> y sentencias <span class="literal">if</span> anidadas dentro de bucles <span class="literal">while</span>. Puede que hayas visto una sentencia <span class="literal">if</span> anidada en el código de la Misión 37<a href="ch07.xhtml#page_139">(página 139</a>).</p>
<p class="indent">En el siguiente ejemplo, la sentencia <span class="literal">if</span> anidada comprueba la última palabra que se imprimió y decide si se imprimen las palabras <span class="literal">"mine"</span> y <span class="literal">"craft"</span>. El bucle se repite 50 veces.</p>
<p class="programs" translate="no">word = <span class="green">"mine"</span><br translate="no"/>count = 0<br translate="no"/><span class="orange">while</span> count &lt; 50:<br translate="no"/> <span class="rose">print</span>(word)<br translate="no"/> <span class="orange">if</span> word == <span class="green">"mine"</span>:<br translate="no"/>        word = <span class="green">"craft"</span><br translate="no"/> <span class="orange">else</span>:<br translate="no"/>        word = <span class="green">"mine"</span></p>
<p class="indent">La variable <span class="literal">palabra</span> almacena la primera palabra que se imprimirá. La sentencia <span class="literal">if</span> del bucle comprueba si la palabra actual es "mina <span class="literal">"</span> y, si lo es, cambia la palabra a "artesanía <span class="literal">"</span> y la imprime en la siguiente iteración del bucle. Si la palabra no es "mía <span class="literal">"</span>, se cambiará a "artesanía <span class="literal">"</span>. Se trata de un bucle infinito, ¡así que asegúrate de utilizar <small>CTRL-C</small> para escapar!</p>
<p class="indent">También puedes anidar sentencias <span class="literal">elif</span> y otros bucles <span class="literal">while</span> dentro de bucles <span class="literal">while</span>.</p>
<p class="indent">El siguiente programa pregunta al usuario si desea imprimir todos los números comprendidos entre uno y un millón:</p>
<p class="programs" translate="no">   userAnswer = <span class="rose">input</span>(<span class="green">"Print the numbers between 1 and 1000000? (yes/no): "</span>)<br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="orange">if</span> userAnswer = <span class="green">"yes"</span>:<br translate="no"/>       count = 1<br translate="no"/><span class="ent">➋</span> <span class="orange">while</span> count &lt;= 1000000:<br translate="no"/> <span class="rose">print</span>(count)<br translate="no"/>           count += 1</p>
<p class="indent">La sentencia <span class="literal">if</span> comprueba si la entrada del usuario es <span class="literal">sí</span> <span class="ent">➊.</span> Si lo es, el programa ejecuta el bucle anidado en la sentencia <span class="literal">if</span> <span class="ent">➋.</span> Si la entrada es cualquier otra, el programa no ejecutará el bucle y terminará.</p>
<h4 class="h4a" id="ch07lev2sec10"><span epub:type="pagebreak" id="page_142"></span><strong>Misión 38: El toque de Midas</strong></h4>
<p class="noindent">Midas es un rey de leyenda. Todo lo que tocaba se convertía en oro. Tu misión es escribir un programa que convierta en oro todos los bloques situados por debajo del jugador, excepto el aire y el agua, claro, ¡o estarías en un buen lío! Recuerda que el bloque dorado tiene un valor de 41, el agua es 9 y el aire es 0.</p>
<p class="sidenote" translate="no"><span class="blue"><em>midas.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/><br translate="no"/>   air = 0<br translate="no"/>   water = 9<br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="red"># Add an infinite while loop here</span><br translate="no"/>       pos = mc.player.getTilePos()<br translate="no"/>       blockBelow = mc.getBlock(pos.x, pos.y - 1, pos.z)<br translate="no"/><br translate="no"/><span class="ent">➋</span> <span class="red"># Add if statement here</span><br translate="no"/>           mc.setBlock(pos.x, pos.y - 1, pos.z, 41)</p>
<p class="indent">Abre IDLE y crea un nuevo archivo. Guarda el archivo como <em>midas.py</em> en la carpeta <em>whileLoops</em>. Tienes que añadir algo más al programa para que pueda hacer lo que necesitas. En primer lugar, añadirás un bucle <span class="literal">while</span> infinito <span class="ent">➊.</span> Recuerda que un bucle <span class="literal">while</span> infinito tiene una condición que siempre es <span class="literal">Verdadera</span>. También tienes que añadir una sentencia <span class="literal">if</span> que compruebe si el bloque situado debajo del jugador no es igual a aire y no es igual a agua estancada <span class="ent">➋.</span> El valor del bloque situado debajo del jugador se almacena en la variable <span class="literal">bloqueDebajo</span>, y los valores del aire y del agua se almacenan en las variables <span class="literal">aire</span> y <span class="literal">agua</span>.</p>
<p class="indent">Cuando hayas completado el programa, guárdalo y ejecútalo. El jugador debería dejar un rastro de oro tras de sí. Cuando salte al agua o vuele por el aire, los bloques que hay debajo no deberían cambiar. <a href="ch07.xhtml#ch7fig7">La Figura 7-7</a> muestra el programa en acción.</p>
<div class="image"><img alt="image" src="../images/f07-07.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig7"></a><em>Figura 7-7: Cada bloque que piso se convierte en oro.</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_143"></span>Para salir del bucle infinito, ve a <strong>Shell</strong> <img alt="image" src="../images/arrow.jpg" translate="no"/> <strong>Reiniciar Shell</strong> en tu shell IDLE o haz clic en el shell y pulsa <small>CTRL-C</small>.</p>
<div class="sidebar">
<p class="sidebart" id="ch07sb06"><strong>OBJETIVO EXTRA: SOY UN LABRADOR</strong></p>
<p class="noindent">Puedes cambiar <em>midas.</em> py para que sirva a diversos propósitos. ¿Qué tal si lo cambias para que cambie automáticamente los bloques de tierra por bloques de hierba? ¿Qué tal cambiar los bloques de tierra por bloques de hierba?</p>
</div>
<h3 class="h3" id="ch07lev1sec04"><strong><span class="blue1">Terminar un bucle while con break</span></strong></h3>
<p class="noindent">Con los bucles <span class="literal">while</span>, tienes control total sobre cómo y cuándo termina el bucle. Hasta ahora sólo has utilizado condiciones para terminar bucles, pero también puedes utilizar una sentencia <span class="literal">break</span>. La sentencia <span class="literal">break</span> permite que tu código salga inmediatamente de un bucle <span class="literal">while</span>. Veamos este concepto.</p>
<p class="indent">Una forma de utilizar las sentencias <span class="literal">break</span> es ponerlas en una sentencia <span class="literal">if</span> anidada en el bucle. Al hacerlo, el bucle se detiene inmediatamente cuando la condición de la sentencia <span class="literal">if</span> es <span class="literal">Verdadera</span>. El siguiente código pide continuamente la entrada del usuario hasta que escriba <span class="literal">"exit</span>":</p>
<p class="programs" translate="no"><span class="ent">➊</span> <span class="orange">while True</span>:<br translate="no"/><span class="ent">➋</span>     userInput = <span class="rose">input</span>(<span class="green">"Enter a command: "</span>)<br translate="no"/><span class="ent">➌</span> <span class="orange">if</span> userInput == <span class="green">"exit"</span>:<br translate="no"/><span class="ent">➍</span> <span class="orange">break</span><br translate="no"/> <span class="rose">print</span>(userInput)<br translate="no"/><span class="ent">➎</span> <span class="rose">print</span>(<span class="green">"Loop exited"</span>)</p>
<p class="indent">Se trata de un bucle infinito porque utiliza <span class="literal">while True</span> <span class="ent">➊.</span> Cada vez que se repite el bucle, pide al usuario que introduzca un comando <span class="ent">➋.</span> El programa comprueba si la entrada es " <span class="literal">salida"</span> <span class="ent">➌</span> utilizando una sentencia <span class="literal">if</span>. Si la entrada cumple la condición, la sentencia <span class="literal">break</span> detiene la repetición del bucle <span class="ent">➍,</span> y el programa continúa en la línea inmediatamente posterior al cuerpo del bucle, imprimiendo " <span class="literal">Bucle salido</span> " en la shell de Python <span class="ent">➎.</span></p>
<h4 class="h4a" id="ch07lev2sec11"><strong>Misión nº 39: Crear una conversación persistente con un bucle</strong></h4>
<p class="noindent">En la Misión nº 13<a href="ch04.xhtml#page_76">(página 76</a>), creaste un programa que publica el mensaje del usuario en el chat utilizando cadenas, entrada y salida. Aunque este programa era útil, estaba bastante limitado porque tenías que volver a ejecutar el programa cada vez que querías publicar un nuevo mensaje.</p>
<p class="indent">En esta misión, mejorarás tu programa de chat utilizando un bucle <span class="literal">while</span> para que los usuarios puedan publicar tantos mensajes como quieran sin reiniciar el programa.</p>
<p class="indent"><span epub:type="pagebreak" id="page_144"></span>Abre el archivo <em>userChat.py</em> en la carpeta <em>strings</em> y luego guárdalo como <em>chatLoop.py</em> en la carpeta <em>whileLoops</em>.</p>
<p class="indent">Para publicar un nuevo mensaje cada vez que quieras sin reiniciar el programa, añade lo siguiente a tu código:</p>
<ol>
<li class="noindent"><p class="list">Añade un bucle <span class="literal">while</span> infinito al programa.</p></li>
<li class="noindent"><p class="list">Añade una sentencia <span class="literal">if</span> al bucle para comprobar si la entrada del usuario es <span class="literal">"</span>exit". Si la entrada es "exit <span class="literal">"</span>, el bucle debería romperse.</p></li>
<li class="noindent"><p class="list">Asegúrate de que la variable <span class="literal">userName</span> está definida antes del inicio del bucle.</p></li>
</ol>
<p class="indent">Cuando hayas añadido los cambios, guarda tu programa y ejecútalo. Un prompt en el shell de Python te pedirá que escribas un nombre de usuario. Hazlo y pulsa <small>ENTER</small>. A continuación, el programa te pedirá que introduzcas un mensaje. Escribe un mensaje y pulsa <small>INTRO</small>. El programa seguirá pidiéndote que introduzcas un mensaje hasta que escribas <span class="literal">exit</span>. <a href="ch07.xhtml#ch7fig8">La Figura 7-8</a> muestra mi programa de chat en funcionamiento.</p>
<div class="image"><img alt="image" src="../images/f07-08.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig8"></a><em>Figura 7-8: Estoy chateando conmigo mismo.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch07sb07"><strong>OBJETIVO EXTRA: BLOQUEAR EL CHAT</strong></p>
<p class="noindent">Amplía la función de chat para que los usuarios puedan crear bloques. Por ejemplo, si el usuario introduce <span class="literal">"lana"</span>, el programa crea un bloque de lana. Puedes hacerlo añadiendo sentencias <span class="literal">elif</span> a tu sentencia <span class="literal">if</span> para comprobar la entrada del usuario.</p>
</div>
<h4 class="h4" id="ch07lev2sec12"><span epub:type="pagebreak" id="page_145"></span><strong><span class="blue1">Sentencias while-else</span></strong></h4>
<p class="noindent">Al igual que las sentencias <span class="literal">if</span>, los bucles <span class="literal">while</span> pueden tener condiciones secundarias activadas por sentencias <span class="literal">else</span>.</p>
<p class="indent">La sentencia <span class="literal">else</span> se ejecuta cuando la condición de una sentencia <span class="literal">while</span> es <span class="literal">False</span>. A diferencia del cuerpo de una sentencia <span class="literal">while</span>, la sentencia <span class="literal">else</span> se ejecutará sólo una vez, como se muestra aquí:</p>
<p class="programs" translate="no">message = <span class="rose">input</span>(<span class="green">"Please enter a message."</span>)<br translate="no"/><br translate="no"/><span class="orange">while</span> message != <span class="green">"exit"</span>:<br translate="no"/> <span class="rose">print</span>(message)<br translate="no"/>    message = <span class="rose">input</span>(<span class="green">"Please enter a message."</span>)<br translate="no"/><span class="orange">else</span>:<br translate="no"/> <span class="rose">print</span>(<span class="green">"User has left the chat."</span>)</p>
<p class="indent">Este bucle se repite mientras el <span class="literal">mensaje</span> introducido no sea igual a <span class="literal">"</span>exit". Si el <span class="literal">mensaje</span> es "exit <span class="literal">"</span>, el bucle dejará de repetirse, y el cuerpo de la <span class="literal">sentencia</span> else imprimirá "El <span class="literal"> usuario ha abandonado el chat".</span></p>
<p class="indent">Si utilizas una sentencia <span class="literal">break</span> en la sentencia <span class="literal">while</span>, la sentencia <span class="literal">else</span> no se ejecutará. El siguiente código es similar al ejemplo anterior, pero incluye una sentencia <span class="literal">if</span> anidada y una sentencia <span class="literal">break</span>. Cuando el usuario escriba <span class="literal">abort</span> en lugar de <span class="literal">exit</span>, el bucle de chat saldrá sin imprimir el mensaje "El <span class="literal"> usuario ha abandonado el chat.</span> " en el chat.</p>
<p class="programs" translate="no">message = <span class="rose">input</span>(<span class="green">"Please enter a message."</span>)<br translate="no"/><br translate="no"/><span class="orange">while</span> message != <span class="green">"exit"</span>:<br translate="no"/> <span class="rose">print</span>(message)<br translate="no"/>    message = <span class="rose">input</span>(<span class="green">"Please enter a message."</span>)<br translate="no"/> <span class="orange">if</span> message == <span class="green">"abort"</span>:<br translate="no"/> <span class="orange">break</span><br translate="no"/><span class="orange">else</span>:<br translate="no"/> <span class="rose">print</span>(<span class="green">"User has left the chat."</span>)</p>
<p class="indent">La sentencia <span class="literal">if</span> comprueba si el mensaje introducido es "abortar <span class="literal">"</span>. Si es <span class="literal">True</span>, se ejecuta la sentencia <span class="literal">break</span> y el bucle saldrá. Como se ha utilizado la sentencia <span class="literal">break</span>, el cuerpo de la sentencia <span class="literal">else</span> no se ejecutará y no se imprimirá "El usuario ha abandonado <span class="literal"> el</span> chat".</p>
<h4 class="h4a" id="ch07lev2sec13"><strong>Misión 40: Frío y caliente</strong></h4>
<p class="noindent">En esta misión, crearemos una partida de Frío y Caliente en Minecraft. Si nunca has jugado, la idea es que tu amigo esconde un objeto y tú tienes que encontrarlo. Tu amigo te da pistas en función de lo lejos que estés del objeto. Si estás cerca, tu amigo dirá "Caliente", y si estás lejos, dirá "Frío". Cuando estés justo al lado del objeto, dirá "¡Estás ardiendo!" y si estás muy lejos, dirá "¡Congelación!".</p>
<p class="indent"><span epub:type="pagebreak" id="page_146"></span>El objetivo del juego es encontrar y colocarte sobre el bloque de diamante que se ha colocado aleatoriamente en el mundo del juego. En esta versión del juego, jugarás tú solo, y el programa Python te dirá a qué distancia del bloque oculto te encuentras. El juego termina cuando te sitúas sobre el bloque diamante.</p>
<p class="indent">El listado<a href="ch07.xhtml#ch7ex2">7-2</a> coloca un bloque en un lugar aleatorio.</p>
<p class="sidenote" translate="no"><span class="blue"><em>blockHunter.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/> <span class="orange">import</span> math<br translate="no"/> <span class="orange">import</span> time<br translate="no"/> <span class="orange">import</span> random<br translate="no"/>   mc = Minecraft.create()<br translate="no"/><br translate="no"/>   destX = random.randint(-127, 127)<br translate="no"/>   destZ = random.randint(-127, 127)<br translate="no"/><span class="ent">➊</span> destY = mc.getHeight(destX, destZ)<br translate="no"/><br translate="no"/>   block = 57<br translate="no"/><span class="ent">➋</span> mc.setBlock(destX, destY, destZ, block)<br translate="no"/>   mc.postToChat(<span class="green">"Block set"</span>)<br translate="no"/><br translate="no"/> <span class="orange">while True</span>:<br translate="no"/>       pos = mc.player.getPos()<br translate="no"/><span class="ent">➌</span>     distance = math.sqrt((pos.x - destX) ** 2 + (pos.z - destZ) ** 2)<br translate="no"/><br translate="no"/><span class="ent">➍</span> <span class="orange">if</span> distance &gt; 100:<br translate="no"/>           mc.postToChat("Freez<span class="green">ing")</span><br translate="no"/> <span class="orange">elif</span> distance &gt; 50:<br translate="no"/>           mc.postToChat("Cold"<span class="green">)</span><br translate="no"/> <span class="orange">elif</span> distance &gt; 25:<br translate="no"/>           mc.postToChat("Warm"<span class="green">)</span><br translate="no"/> <span class="orange">elif</span> distance &gt; 12:<br translate="no"/>           mc.postToChat("Boili<span class="green">ng")</span><br translate="no"/> <span class="orange">elif</span> distance &gt; 6:<br translate="no"/>           mc.postToChat("On fi<span class="green">re!")</span><br translate="no"/> <span class="orange">elif</span> distance == 0:<br translate="no"/><span class="ent">➎</span>         mc.postToChat("Found <span class="green">it")</span></p>
<p class="examplet"><a id="ch7ex2"></a><em>Listado 7-2: Inicio del programa Frío y Caliente</em></p>
<p class="indent">Antes de colocar un bloque al azar, el programa se asegura de que el bloque no se colocará bajo tierra. Para ello, utiliza la función <span class="literal">getHeight()</span> <span class="ent">➊,</span> que encuentra el bloque que tiene la coordenada y más alta (es decir, en la superficie) para cualquier posición del juego. Luego coloca un bloque de diamante en una posición aleatoria <span class="ent">➋.</span></p>
<p class="indent">El código en <span class="ent">➌</span> calcula la distancia al bloque de diamante. Utiliza la función <span class="literal">sqrt</span> (), que está en el módulo <span class="literal">matemático</span>; por eso es necesario <span class="literal">importar matemática</span> al principio del programa. La función <span class="literal">sqrt</span> () calcula la raíz cuadrada de un número.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_147"></span><strong><span class="notes">NOTA</span></strong></p>
<p class="notep"><em><a href="ch07.xhtml#ch7ex2">El listado 7-2</a> utiliza una fórmula llamada</em> teorema de Pitágoras<em>. La fórmula utiliza dos lados de un triángulo para calcular la longitud del tercero. En este caso, utilizo la distancia del jugador al bloque oculto en el eje x y en el eje z para calcular la distancia al bloque oculto en línea recta.</em></p>
</div>
<p class="indent">El mensaje que muestra el programa depende de la distancia a la que te encuentres del bloque, que puedes averiguar utilizando una sentencia <span class="literal">if</span> y la variable de <span class="literal">distancia</span> <span class="ent">➍.</span> El programa muestra <span class="literal">"Congelación"</span> si estás muy lejos y " <span class="literal">¡En llamas!"</span> si estás muy cerca.</p>
<p class="indent">Copia <a href="ch07.xhtml#ch7ex2">el Listado 7-2</a> en un nuevo archivo en IDLE y guarda el programa como <em>blockHunter.py</em> en la carpeta <em>whileLoops</em>.</p>
<p class="indent">De momento el programa funciona, pero no termina cuando encuentras el bloque. Para terminar el código, tienes que añadir una sentencia <span class="literal">break</span> cuando la distancia del jugador al bloque sea 0 <span class="ent">➎.</span></p>
<p class="indent">Cuando hayas terminado el programa, guárdalo y ejecútalo. Se generará un bloque aleatorio y tendrás que encontrarlo. El programa debería detenerse cuando encuentres el bloque y te pares sobre él. <a href="ch07.xhtml#ch7fig9">La Figura 7-9</a> muestra que acabo de encontrar el bloque.</p>
<div class="image"><img alt="image" src="../images/f07-09.jpg" translate="no"/></div>
<p class="figcap"><a id="ch7fig9"></a><em>Figura 7-9: He encontrado el bloque y ahora sólo tengo que ponerme encima.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch07sb08"><strong>OBJETIVO EXTRA: TIEMPO AL TIEMPO</strong></p>
<p class="noindent">El programa <em>blockHunter.</em> py te da todo el tiempo que necesites para encontrar el bloque. ¿Se te ocurre alguna forma de mostrar el tiempo que tarda el jugador en encontrar el bloque o incluso de limitar el tiempo que tiene para jugar?</p>
</div>
<h3 class="h3" id="ch07lev1sec05"><span epub:type="pagebreak" id="page_148"></span><strong><span class="blue1">Lo que has aprendido</span></strong></h3>
<p class="noindent">¡Bien hecho! Has aprendido mucho sobre los bucles <span class="literal">while</span>. Puedes crear bucles <span class="literal">while</span> y bucles <span class="literal">while</span> infinitos, y puedes utilizar bucles con condiciones y operadores booleanos. Usando bucles, ahora puedes escribir programas que repiten código, lo que te ahorrará mucho tiempo para que puedas centrarte en dominar Minecraft. En <a href="ch08.xhtml#ch08">el Capítulo 8</a>, aprenderás otra forma de hacer código reutilizable utilizando funciones.</p>
</body>
</html>