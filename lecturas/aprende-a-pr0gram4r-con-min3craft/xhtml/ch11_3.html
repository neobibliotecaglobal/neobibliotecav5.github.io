<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/>
<title>Aprende a programar con Minecraft</title>
<link href="../styles/9781593276706.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:40af8c70-d268-482b-9282-0b537fc6ae71" name="Adept.expected.resource"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h3 class="h3" id="ch11lev1sec02"><span epub:type="pagebreak" id="page_242"></span><strong><span class="blue1">Uso de módulos</span></strong></h3>
<p class="noindent"><em>Los</em> módulos son colecciones de funciones que puedes importar a Python para no tener que escribir esas funciones en tus programas. Un módulo suele tener una finalidad específica, como realizar cálculos científicos o crear juegos, y hay una gran variedad de módulos disponibles para Python. ¡Puede que te sorprenda saber que has estado utilizando módulos a lo largo de este libro! La API Python de Minecraft es un módulo: cada vez que has escrito <span class="literal">from mcpi.minecraft import Minecraft</span>, has estado utilizando un módulo. El módulo API Python de Minecraft te permite conectar tus programas Python a Minecraft. Como está preescrito por otra persona, puedes utilizar las funciones del módulo sin tener que escribir el código tú mismo.</p>
<p class="indent">Python viene con un montón de módulos que puedes utilizar en tus programas. Estos módulos, junto con todo el Python que has aprendido en este libro hasta ahora, se denominan <em>biblioteca estándar de Python</em>. También puedes instalar módulos que no formen parte de la biblioteca estándar; lo haremos en "<a href="ch11.xhtml#ch11lev1sec04">Instalar nuevos módulos con pip</a>" en <a href="ch11.xhtml#page_256">la página 256</a>.</p>
<p class="indent">En esta sección, aprenderás todas las formas en que puedes configurar tus programas para que utilicen módulos. Como ejemplo, utilizaremos el módulo <span class="literal">pickle</span>, que proporciona formas más avanzadas de guardar y cargar datos con archivos que simplemente escribir y leer datos de ellos. Veamos ahora el módulo <span class="literal">pickle</span>.</p>
<h4 class="h4" id="ch11lev2sec08"><strong><span class="blue1">El módulo pickle</span></strong></h4>
<p class="noindent">El módulo <span class="literal">pickle</span> es muy útil cuando escribes datos complicados en un archivo. Por ejemplo, los diccionarios y las listas multidimensionales son difíciles de almacenar y recuperar utilizando las funciones estándar que hemos utilizado anteriormente en el capítulo. Aquí es donde el módulo <span class="literal">pickle</span> resulta útil.</p>
<p class="indent">El módulo <span class="literal">pickle</span> puede ahorrarte horas de escribir y depurar tus propias soluciones para almacenar datos complejos. También puedes utilizar el módulo <span class="literal">pickle</span> con datos sencillos: por ejemplo, puedes utilizarlo para almacenar números sin convertirlos a y desde cadenas, lo que es necesario para la entrada y salida estándar de archivos.</p>
<p class="indent">En otras palabras, puedes utilizar el módulo <span class="literal">pickle</span> para guardar el valor de una variable en un archivo y luego leer el valor de la variable directamente en otro programa sin ningún procesamiento adicional. El tipo de datos sigue siendo el mismo que cuando guardaste el valor, aunque el tipo de datos sea una cadena, un entero, un flotante o un booleano.</p>
<p class="indent">A continuación, aprenderás a importar módulos utilizando <span class="literal">pickle</span> como ejemplo. Luego utilizarás <span class="literal">pickle</span> para guardar algunos datos complejos: ¡un edificio entero de Minecraft!</p>
<h4 class="h4" id="ch11lev2sec09"><strong><span class="blue1">Importar pickle</span></strong></h4>
<p class="noindent">Para utilizar las funciones de cualquier módulo, tienes que importarlo utilizando la palabra clave <span class="literal">import</span>. En realidad, ya has utilizado la palabra clave <span class="literal">importar</span> para importar módulos, como el módulo <span class="literal">del tiempo</span>, así como funciones de la API Minecraft de Python.</p>
<p class="indent"><span epub:type="pagebreak" id="page_243"></span>Una vez que hayas importado el módulo en tu programa, puedes utilizar las funciones del módulo utilizando la notación punto. Incluye el nombre del módulo, un punto y la función que quieras utilizar. Vamos a importar el módulo <span class="literal">pickle</span> y a utilizar un par de sus funciones:</p>
<p class="programs" translate="no"><span class="ent">➊</span> <span class="orange">import</span> pickle<br translate="no"/><br translate="no"/>   locations = {<span class="green">'John'</span>: <span class="green">'Forest'</span>, <span class="green">'Phillipa'</span>: <span class="green">'Mountains'</span>, <span class="green">'Pete'</span>: <span class="green">'City'</span>}<br translate="no"/><br translate="no"/><span class="ent">➋</span> secretFile= <span class="rose">open</span>(<span class="green">"secretFile.txt", "wb"</span>)<br translate="no"/><span class="ent">➌</span> pickle.dump(locations, secretFile)</p>
<p class="indent">Importamos el módulo <span class="literal">pickle</span> en <span class="ent">➊.</span> A continuación abrimos <em>secretFile.txt</em> con un permiso de archivo especial, <span class="literal">"wb"</span> <span class="ent">➋.</span> Cuando abres un archivo con <span class="literal">pickle</span>, debes añadir <span class="literal">b</span> al permiso del archivo. En este caso, <span class="literal">"</span> wb" escribe datos en el archivo utilizando un formato especial que requiere el módulo <span class="literal">pickle</span>.</p>
<p class="indent">La función <span class="literal">dump</span> () escribe en el archivo en <span class="ent">➌.</span> La función <span class="literal">dump</span> () del módulo <span class="literal">pickle</span> almacena una variable en un archivo. Toma dos argumentos: los datos que se escribirán en el archivo y el archivo abierto en el que escribirá. Este ejemplo almacena las ubicaciones de los agentes secretos en un diccionario llamado <span class="literal">ubicaciones</span> y luego vuelca ese diccionario en un archivo llamado <span class="literal">archivoSecreto</span>. Como <span class="literal">dump()</span> pertenece al módulo <span class="literal">pickle</span>, debes utilizar la notación con puntos para especificar tanto el módulo como la función con <span class="literal">pickle.dump()</span>. A diferencia de las funciones de archivo estándar de Python, la función <span class="literal">dump</span> () guarda los datos en el archivo automáticamente: no necesitas cerrar el archivo con la función <span class="literal">close()</span>.</p>
<p class="indent">El módulo <span class="literal">pickle</span> también te permite leer datos almacenados. Puedes utilizar la función <span class="literal">load()</span> de <span class="literal">pickle</span>para leer el contenido de un archivo. Toma un argumento, el archivo que quieres cargar, y devuelve el contenido del archivo. El siguiente ejemplo carga el diccionario de <span class="literal">localizaciones</span> que almacenamos anteriormente. Añade este código al programa:</p>
<p class="programs" translate="no"> <span class="orange">import</span> pickle<br translate="no"/><br translate="no"/><span class="ent">➊</span> secretFile= <span class="rose">open</span>(<span class="green">"secretFile.txt"</span>, <span class="green">"rb"</span>)<br translate="no"/>   locations = pickle.load(secretFile)</p>
<p class="indent">Primero abrimos el archivo con el permiso <span class="literal">"rb"</span> <span class="ent">➊,</span> que permite a tu programa leer un formato de datos especial que utiliza <span class="literal">pickle</span>. Luego cargamos el diccionario.</p>
<p class="indent">Una vez cargado el diccionario, puedes tratarlo como cualquier otro diccionario. Por ejemplo, puedes acceder al valor de una de las claves. Sólo tienes que añadir este código después de la función pickle <span class="literal">.load()</span>:</p>
<p class="programs" translate="no"><span class="rose">print</span>(locations[<span class="green">'Phillipa'</span>])</p>
<p class="indent">Esto imprimirá <span class="literal">'Montañas'</span>, el valor de la clave <span class="literal">'Phillipa'</span>. Esto se debe a que el diccionario del archivo no cambia cuando se carga en el programa <span epub:type="pagebreak" id="page_244"></span>con pickle <span class="literal">:</span>sigue siendo un diccionario, por lo que podemos acceder a sus claves y valores y utilizarlo como cualquier otro diccionario de Python. También podrías hacer lo mismo con una lista o una variable.</p>
<h4 class="h4" id="ch11lev2sec10"><strong><span class="blue1">Importar una función con la cláusula from</span></strong></h4>
<p class="noindent">Importar un módulo significa que tienes acceso a todas las funciones de ese módulo, pero a veces sólo necesitas una función de un módulo. Si quieres importar sólo una función, utiliza la cláusula <span class="literal">from</span> al importar el módulo. Esta cláusula te permite acceder a la función sin incluir el nombre del módulo y la notación de punto cada vez que llames a una función. Sólo tendrías que escribir <span class="literal">function()</span> en lugar de <span class="literal">module.function()</span>.</p>
<p class="indent">A veces, cuando utilizas el módulo <span class="literal">pickle</span>, puedes querer utilizar sólo la función <span class="literal">dump()</span>, y no sus otras funciones. Para ello, cambia el código que escribiste antes para que tenga este aspecto:</p>
<p class="programs" translate="no"><span class="ent">➊</span> <span class="orange">from</span> pickle <span class="orange">import</span> dump<br translate="no"/><br translate="no"/>   locations = {<span class="green">'John'</span>: <span class="green">'Forest'</span>, <span class="green">'Phillipa'</span>: <span class="green">'Mountains'</span>, <span class="green">'Pete'</span>: <span class="green">'City'</span>}<br translate="no"/><br translate="no"/>   secretFile= <span class="rose">open</span>(<span class="green">"secretFile"</span>, <span class="green">"wb"</span>)<br translate="no"/><span class="ent">➋</span> dump(locations, secretFile)</p>
<p class="indent">La primera línea utiliza la cláusula <span class="literal">from</span> para importar sólo la función dump( <span class="literal">)</span> del módulo <span class="literal">pickle</span> <span class="ent">➊.</span> La última línea llama a la función <span class="literal">dump</span> () <span class="ent">➋.</span> Fíjate en que no tiene notación de punto. Simplemente llamas al nombre de la función sin hacer referencia al nombre del módulo.</p>
<p class="indent">También puedes importar más de una función de un módulo utilizando <span class="literal">from</span>. Lo único que tienes que hacer es separar los nombres de las funciones con una coma. Por ejemplo, si quieres utilizar las funciones <span class="literal">dump()</span> y <span class="literal">load()</span> de <span class="literal">pickle</span> en el mismo archivo, puedes importarlas ambas:</p>
<p class="programs" translate="no"><span class="ent">➊</span> <span class="orange">from</span> pickle <span class="orange">import</span> dump, load<br translate="no"/>   locations = {<span class="green">'John'</span>: <span class="green">'Forest'</span>, <span class="green">'Phillipa'</span>: <span class="green">'Mountains'</span>, <span class="green">'Pete'</span>: <span class="green">'City'</span>}<br translate="no"/><br translate="no"/>   secretFile= <span class="rose">open</span>(<span class="green">"secretFile"</span>, <span class="green">"wb"</span>)<br translate="no"/><span class="ent">➋</span> dump(locations, secretFile)<br translate="no"/><br translate="no"/><span class="ent">➌</span> locations = load(secretFile)<br translate="no"/> <span class="rose">print</span>(locations[<span class="green">'Phillipa'</span>])</p>
<p class="indent">La primera línea utiliza la cláusula <span class="literal">from</span> con comas para importar las funciones dump( <span class="literal">)</span> y load( <span class="literal">)</span> <span class="ent">➊.</span> Esto significa que más adelante en el programa, puedes utilizar estas funciones sin tener que incluir el nombre de la función y la notación de puntos, que puedes ver en <span class="ent">➋</span> y <span class="ent">➌.</span></p>
<h4 class="h4" id="ch11lev2sec11"><span epub:type="pagebreak" id="page_245"></span><strong><span class="blue1">Importar todas las funciones con *</span></strong></h4>
<p class="noindent">También puedes importar todas las funciones de un módulo para no tener que incluir el nombre del módulo con la notación de puntos cada vez que lo utilices. Para ello, introduce un asterisco<span class="literal">(*</span>) al final de la sentencia <span class="literal">import</span>, como se indica a continuación:</p>
<p class="programs" translate="no"><span class="ent">➊</span> <span class="orange">from</span> pickle <span class="orange">import</span> *<br translate="no"/>   locations = {<span class="green">'John'</span>: <span class="green">'Forest'</span>, <span class="green">'Phillipa'</span>: <span class="green">'Mountains'</span>, <span class="green">'Pete'</span>: <span class="green">'City'</span>}<br translate="no"/><br translate="no"/>   secretFile= <span class="rose">open</span>(<span class="green">"secretFile"</span>, <span class="green">"wb"</span>)<br translate="no"/><span class="ent">➋</span> dump(locations, secretFile)<br translate="no"/><br translate="no"/><span class="ent">➌</span> locations = load(secretFile)<br translate="no"/> <span class="rose">print</span>(locations[<span class="green">'Phillipa'</span>])</p>
<p class="indent">Como este código importó todas las funciones del módulo utilizando un asterisco <span class="ent">➊,</span> no necesitamos utilizar la notación con puntos cuando llamemos a las funciones <span class="literal">dump()</span> <span class="ent">➋</span> y <span class="literal">load()</span> <span class="ent">➌</span>.</p>
<p class="indent">La opción <span class="literal">*</span> es muy práctica, ¡pero conlleva un riesgo! Si trabajas con varios módulos, puede que dos módulos compartan los mismos nombres de función. Cuando esto ocurra, Python se confundirá y podrías obtener un error. Por eso, cuando trabajes con muchos módulos, es mejor que evites utilizar la opción <span class="literal">*</span> y en su lugar importes sólo las funciones que necesites utilizar.</p>
<h4 class="h4" id="ch11lev2sec12"><strong><span class="blue1">Dar un apodo a un módulo</span></strong></h4>
<p class="noindent">A veces querrás cambiar el nombre de un módulo porque su nombre es demasiado largo y quieres utilizar un nombre más corto en tu programa. O quieres cambiar el nombre del módulo para que sea más fácil de recordar. O quizás quieras cambiar su nombre porque el módulo comparte el mismo nombre que otro módulo y quieres evitar conflictos.</p>
<p class="indent">Puedes utilizar la cláusula <span class="literal">as</span> con la sentencia <span class="literal">import</span> para dar a un módulo un <em>alias, un</em>apodo. Por ejemplo, este código importa el módulo <span class="literal">pickle</span> y lo renombra a <span class="literal">p</span>:</p>
<p class="programs" translate="no"><span class="orange">import</span> pickle as p</p>
<p class="indent">Ahora, cada vez que quieras utilizar el módulo <span class="literal">pickle</span>, puedes escribir <span class="literal">p</span> en tu programa en lugar de <span class="literal">pickle</span>. Aquí tienes un ejemplo de esto en acción:</p>
<p class="programs" translate="no">p.dump(locations, secretFile)</p>
<p class="indent">Observa que se utiliza p. <span class="literal">dump()</span> en lugar de pickle <span class="literal">.dump()</span>. Esto te ahorra tiempo, ¡porque no tienes que seguir escribiendo <span class="literal">pickle</span>!</p>
<h4 class="h4a" id="ch11lev2sec13"><span epub:type="pagebreak" id="page_246"></span><strong>Misión nº 65: Salvar un edificio</strong></h4>
<p class="noindent">Construir cosas es mi parte favorita de Minecraft. Me he pasado horas construyendo casas, castillos, aldeas y muchas otras cosas. Pero cuando me traslado a otra parte del mapa o a un mundo diferente, tengo que dejar atrás mis creaciones. Seguro que tú también has tenido que abandonar algunas creaciones increíbles.</p>
<p class="indent">¿No sería genial que pudieras guardar tus edificios y llevártelos contigo cuando te trasladas a mundos diferentes? Pues con <span class="literal">Pickle</span> y la API de Python, ¡puedes hacerlo!</p>
<p class="indent">En esta misión, desarrollarás dos programas que guardarán y cargarán edificios en tu juego Minecraft. Un programa guardará el edificio, y el otro lo cargará. Ambos programas se basan en <em>duplicateArea.py</em> del <a href="ch10.xhtml#ch10">Capítulo 10</a><a href="ch10.xhtml#page_229">(página 229</a>).</p>
<h4 class="h4" id="ch11lev2sec14"><strong><span class="blue1">Parte 1: Guardar el edificio</span></strong></h4>
<p class="noindent">El primer programa guardará un edificio en un archivo. <a href="ch11.xhtml#ch11ex3">El listado 11-3</a> incluye el código para copiar el edificio. Copia el listado en un archivo en IDLE y guárdalo como <em>guardarEstructura.</em> py en la carpeta <em>archivos</em>.</p>
<p class="sidenote" translate="no"><span class="blue"><em>saveStructure.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/><br translate="no"/> <span class="orange">import</span> pickle<br translate="no"/><br translate="no"/><br translate="no"/> <span class="orange">def</span> <span class="blue1">sortPair</span>(val1, val2):<br translate="no"/> <span class="orange">if</span> val1 &gt; val2:<br translate="no"/> <span class="orange">return</span> val2, val1<br translate="no"/> <span class="orange">else</span>:<br translate="no"/> <span class="orange">return</span> val1, val2<br translate="no"/><br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue1">copyStructure</span>(x1, y1, z1, x2, y2, z2):<br translate="no"/>       x1, x2 = sortPair(x1, x2)<br translate="no"/>       y1, y2 = sortPair(y1, y2)<br translate="no"/>       z1, z2 = sortPair(z1, z2)<br translate="no"/><br translate="no"/>       width = x2 - x1<br translate="no"/>       height = y2 - y1<br translate="no"/>       length = z2 - z1<br translate="no"/><br translate="no"/>       structure = []<br translate="no"/><br translate="no"/> <span class="rose">print</span>(<span class="green">"Please wait..."</span> )<br translate="no"/><br translate="no"/> <span class="red"># Copy the structure</span><br translate="no"/> <span class="orange">for</span> row <span class="orange">in</span> <span class="rose">range</span>(height):<br translate="no"/>           structure.append([])<br translate="no"/> <span class="orange">for</span> column <span class="orange">in</span> <span class="rose">range</span>(width):<br translate="no"/>               structure[row].append([])<br translate="no"/> <span class="orange">for</span> depth <span class="orange">in</span> <span class="rose">range</span>(length):<br translate="no"/><span class="ent">➋</span>                 block = mc.getBlock(x1 + column, y1 + row, z1 + depth)<br translate="no"/>                   structure[row][column].append(block)<br translate="no"/><br translate="no"/> <span class="orange">return</span> structure<br translate="no"/><br translate="no"/><span class="ent">➌</span> <span class="red"># Get the position of the first corner</span><br translate="no"/> <span class="rose">input</span>(<span class="green">"Move to the first position and press ENTER in this window"</span>)<br translate="no"/>   pos1 = mc.player.getTilePos()<br translate="no"/><br translate="no"/>   x1 = pos1.x<br translate="no"/>   y1 = pos1.y<br translate="no"/>   z1 = pos1.z<br translate="no"/><br translate="no"/><span class="ent">➍</span> <span class="red"># Get the position of the second corner</span><br translate="no"/> <span class="rose">input</span>(<span class="green">"Move to the opposite corner and press ENTER in this window"</span>)<br translate="no"/>   pos2 = mc.player.getTilePos()<br translate="no"/><br translate="no"/>   x2 = pos2.x<br translate="no"/>   y2 = pos2.y<br translate="no"/>   z2 = pos2.z<br translate="no"/><br translate="no"/><span class="ent">➎</span> structure = copyStructure( x1, y1, z1, x2, y2, z2)<br translate="no"/><br translate="no"/><span class="ent">➏</span> <span class="red"># Store the structure in a file</span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_247"></span><a id="ch11ex3"></a><em>Listado 11-3: Código incompleto para guardar un edificio en un archivo</em></p>
<p class="indent">La función <span class="literal">copiarEstructura(</span> ) copia un área del juego en un conjunto de listas tridimensionales <span class="ent">➊.</span> Toma dos conjuntos de coordenadas como argumentos. He hecho un ligero cambio en la función <span class="literal">copyStructure</span> () en comparación con <em>duplicateArea.py</em>. He utilizado la función <span class="literal">getBlockWithData</span> () en lugar de la función <span class="literal">getBlock()</span> <span class="ent">➋.</span> En lugar de obtener sólo el ID de bloque de un bloque en unas coordenadas determinadas, la función <span class="literal">getBlockWithData</span> () obtiene también el estado del bloque. Esto es útil para bloques como las escaleras, donde la dirección de las escaleras se almacena en el estado del bloque. Cuando se copie la estructura, las escaleras y otros bloques que estén orientados en una dirección determinada se construirán en la dirección correcta.</p>
<p class="indent">He incluido un código muy útil para que puedas utilizar la posición del jugador para establecer las coordenadas de un edificio que quieras copiar. Cuando ejecutes el programa, te pedirá que te desplaces a la primera esquina de la estructura y luego pulses <small>INTRO</small> en el intérprete de comandos de Python <span class="ent">➌.</span> El programa utiliza la posición del jugador para obtener el primer conjunto de coordenadas del edificio. A continuación, te pide que te muevas a la esquina opuesta de la estructura y hagas lo mismo <span class="ent">➍.</span> Como resultado, puedes situarte donde quieras para empezar a copiar tu edificio en lugar de escribir las coordenadas o codificarlas en tu programa.</p>
<p class="indent">Los valores de estas variables de coordenadas se pasan a la función <span class="literal">copiarEstructura()</span> en <span class="ent">➎.</span> El valor devuelto se almacena en una variable llamada <span class="literal">estructura</span>.</p>
<p class="indent">Para completar el código, necesitas abrir un nuevo archivo con <span class="literal">pickle</span>. Llama al nuevo archivo <span class="literal">"pickleArchivo"</span>. A continuación, escribe el código para almacenar el edificio en el archivo. Hazlo utilizando el módulo <span class="literal">pickle</span> para escribir el valor de la variable <span class="literal">estructura</span> en un archivo ➏.</p>
<p class="indent"><span epub:type="pagebreak" id="page_248"></span><a href="ch11.xhtml#ch11fig3">La Figura 11-3</a> muestra una torre que construí en mi mundo Minecraft.</p>
<div class="image"><img alt="image" src="../images/f11-03.jpg" translate="no"/></div>
<p class="figcap"><a id="ch11fig3"></a><em>Figura 11-3: Mi torre que quiero copiar</em></p>
<p class="indent">Para copiar la torre utilizando <em>saveStructure.</em>py, me muevo a una esquina y pulso <small>ENTER</small> en IDLE<a href="ch11.xhtml#ch11fig4">(Figura 11-4</a>).</p>
<div class="image"><img alt="image" src="../images/f11-04.jpg" translate="no"/></div>
<p class="figcap"><a id="ch11fig4"></a><em>Figura 11-4: De pie junto a una esquina de la torre</em></p>
<p class="indent">Luego me desplazo a la esquina opuesta de la torre y pulso <small>ENTER</small> en IDLE por segunda vez (Figura<a href="ch11.xhtml#ch11fig5">11-5</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_249"></span><img alt="image" src="../images/f11-05.jpg" translate="no"/></div>
<p class="figcap"><a id="ch11fig5"></a><em>Figura 11-5: Volando hacia la esquina opuesta de la torre</em></p>
<p class="indent">Sigue los mismos pasos para utilizar <em>saveStructure.</em> py para guardar uno de tus propios edificios. A continuación completaremos la otra mitad del proceso y cargaremos nuestros edificios guardados en el juego.</p>
<h4 class="h4" id="ch11lev2sec15"><strong><span class="blue1">Parte 2: Cargar el edificio</span></strong></h4>
<p class="noindent">El segundo programa necesita cargar el edificio en el juego desde el archivo (llamado <em>pickleFile</em>) creado por <em>saveStructure</em>.py. <a href="ch11.xhtml#ch11ex4">El listado 11-4</a> incluye código del programa <em>duplicarArea.py</em><a href="ch10.xhtml#page_229">(página 229</a>) que coloca un edificio guardado en listas. Copia el listado en un archivo en IDLE y guárdalo como <em>loadStructure.</em> py en la carpeta de <em>archivos</em>.</p>
<p class="sidenote" translate="no"><span class="blue"><em>loadStructure.py</em></span></p>
<p class="programs" translate="no"> <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br translate="no"/>   mc = Minecraft.create()<br translate="no"/><br translate="no"/> <span class="orange">import</span> pickle<br translate="no"/><br translate="no"/><br translate="no"/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue1">buildStructure</span>(x, y, z, structure):<br translate="no"/>       xStart = x<br translate="no"/>       zStart = z<br translate="no"/> <span class="orange">for</span> row <span class="orange">in</span> structure:<br translate="no"/> <span class="orange">for</span> column <span class="orange">in</span> row:<br translate="no"/> <span class="orange">for</span> block <span class="orange">in</span> column:<br translate="no"/>                   mc.setBlock(x, y, z, block.id, block.data)<br translate="no"/>                   z += 1<br translate="no"/>               x += 1<br translate="no"/>               z = zStart<br translate="no"/>           y += 1<br translate="no"/>           x = xStart<br translate="no"/><br translate="no"/> <span class="red"># Open and load the structure file</span><br translate="no"/><span class="ent">➋</span> structure =<br translate="no"/><br translate="no"/><span class="ent">➌</span> pos = mc.player.getTilePos()<br translate="no"/>   x = pos.x<br translate="no"/>   y = pos.y<br translate="no"/>   z = pos.z<br translate="no"/><span class="ent">➍</span> buildStructure(x, y, z, structure)</p>
<p class="examplet"><span epub:type="pagebreak" id="page_250"></span><a id="ch11ex4"></a><em>Listado 11-4: Cuando esté completo, este programa construirá un edificio a partir de un archivo.</em></p>
<p class="indent">La función <span class="literal">buildStructure()</span> <span class="ent">➊</span> hace la mayor parte del trabajo en este programa. Construye la estructura en el juego utilizando cuatro argumentos: coordenadas x, y y z y una estructura almacenada en una lista tridimensional.</p>
<p class="indent">Importa el módulo <span class="literal">pickle</span> para poder cargar la estructura en el programa, y luego almacénala en la variable <span class="literal">estructura</span> en <span class="ent">➋.</span> Utilizando la función <span class="literal">open()</span>, abre el archivo <em>pickleFile</em> en el que guardaste la estructura. A continuación, cárgala en la variable <span class="literal">estructura</span> utilizando la función <span class="literal">load()</span> de <span class="literal">pickle</span>. Una vez cargada la estructura, cierra <em>pickleFile</em> utilizando la función <span class="literal">close()</span> de <span class="literal">pickle</span>.</p>
<p class="indent">También se incluye en <a href="ch11.xhtml#ch11ex4">el Listado 11-4</a> un código que obtiene la posición del jugador para utilizarla como ubicación inicial de la estructura <span class="ent">➌.</span></p>
<p class="indent">Una vez cargada la estructura y fijadas las coordenadas, pasa la estructura a la función <span class="literal">buildStructure(</span> ) junto con una posición <span class="ent">➍,</span> que construirá la estructura guardada.</p>
<p class="indent"><a href="ch11.xhtml#ch11fig6">La Figura 11-6</a> muestra el programa en acción. El edificio que guardé antes se ha cargado en el juego y se ha reconstruido en una nueva posición. Pruébalo tú mismo: ¡ahora puedes llevarte tus creaciones dondequiera que vayas!</p>
<div class="image"><img alt="image" src="../images/f11-06.jpg" translate="no"/></div>
<p class="figcap"><a id="ch11fig6"></a><em>Figura 11-6: ¡Mira, es una copia de mi torre!</em></p>
<p class="indent">Pero, ¿y si creas un pueblo entero y quieres llevártelo contigo? Podrías guardar cada edificio en su propio archivo utilizando <span class="literal">pickle</span>, pero eso no es muy cómodo. El módulo <span class="literal">pickle</span> funciona muy bien para guardar un solo edificio, pero no es tan bueno para guardar un montón de edificios. Ahí es donde entra en juego el módulo <span class="literal">shelve</span>. Veámoslo a continuación.</p>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="ch11_2.html">anterior</a><a href="ch11.html">Subtema 3 de 7: (Ver todo)</a><a href="ch11_4.html">siguiente</a><br/></p>
<br/><a href="ch11_3.docx" target="_blank"></a></footer>
</body>
</html>
