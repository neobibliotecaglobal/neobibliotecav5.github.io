<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/><title>Appendix B. Bad Parts</title><link href="core.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h1 class="title"><a id="equalsequals"></a>==</h1><p>JavaScript tiene dos conjuntos de operadores de igualdad: <code class="literal" translate="no">===</code> y <code class="literal" translate="no">!==</code>, y sus gemelos malvados <code class="literal" translate="no">==</code> y <code class="literal" translate="no">!=</code>. Los buenos funcionan como cabría esperar. Si los dos operandos son del mismo tipo y tienen el mismo valor, entonces <code class="literal" translate="no">===</code> produce <code class="literal" translate="no">true</code> y <code class="literal" translate="no">!==</code> produce <code class="literal" translate="no">false</code>. Los gemelos malos hacen lo correcto cuando los operandos son del mismo tipo, pero si son de tipos diferentes, intentan coaccionar los valores. Las reglas por las que lo hacen son complicadas y poco memorables. Estos son algunos de los casos interesantes:<a class="indexterm" id="IDX-APP-B-0537"></a><a class="indexterm" id="IDX-APP-B-0538"></a><a class="indexterm" id="IDX-APP-B-0539"></a><a class="indexterm" id="IDX-APP-B-0540"></a><a class="indexterm" id="IDX-APP-B-0541"></a><a class="indexterm" id="IDX-APP-B-0542"></a></p><a id="I_programlisting_d1e8853"></a><pre class="programlisting" translate="no">'' == '0'          // false
0 == ''            // true
0 == '0'           // true

false == 'false'   // false
false == '0'       // true

false == undefined // false
false == null      // false
null == undefined  // true

' \t\r\n ' == 0    // true</pre><p>La falta de transitividad es alarmante. Mi consejo es que nunca utilices los gemelos malvados. En su lugar, utiliza siempre <code class="literal" translate="no">===</code> y <code class="literal" translate="no">!==</code>. Todas las comparaciones que acabamos de mostrar producen <code class="literal" translate="no">false</code> con el operador <code class="literal" translate="no">===</code>.</p>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="apb_1.html">anterior</a><a href="apb.html">Subtema 2 de 2: (Ver todo)</a><br/></p>
<br/><a href="apb_2.docx" target="_blank"></a></footer>
</body>
</html>
