<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Callbacks</title><link href="core.css" rel="stylesheet" type="text/css"/><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head><body><body><div class="sect1" title="Callbacks"><div class="titlepage"><div><div><h1 class="title"><a id="callbacks"></a>Devoluciones de llamada</h1></div></div></div><p>Las funciones pueden facilitar el tratamiento de eventos discontinuos. Por ejemplo, supongamos que hay una secuencia que comienza con una interacción del usuario, realiza una petición al servidor y, por último, muestra la respuesta del servidor. La forma ingenua de escribir eso sería<a class="indexterm" id="IDX-CHP-4-0233"></a><a class="indexterm" id="IDX-CHP-4-0234"></a><a class="indexterm" id="IDX-CHP-4-0231"></a><a class="indexterm" id="IDX-CHP-4-0232"></a></p><a id="I_programlisting4_d1e3320"></a><pre class="programlisting" translate="no">request = prepare_the_request(  );
response = send_request_synchronously(request);
display(response);</pre><p>El problema de este enfoque es que una petición síncrona a través de la red dejará al cliente en un estado congelado. Si la red o el servidor son lentos, la degradación de la capacidad de respuesta será inaceptable.</p><p>Un enfoque mejor es hacer una petición asíncrona, proporcionando una función de devolución de llamada que se invocará cuando se reciba la respuesta del servidor. Una función asíncrona devuelve inmediatamente, por lo que el cliente no se bloquea:</p><a id="I_programlisting4_d1e3326"></a><pre class="programlisting" translate="no">request = prepare_the_request(  );
send_request_asynchronously(request, function (response) {
    display(response);
    });</pre><p>Pasamos un parámetro de función a la función <code class="literal" translate="no">send_request_asynchronously</code> que se invocará cuando la respuesta esté disponible.</p></div></body><footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<a href="ch04s10.html">← Anterior</a><a href="ch04s12.html">Siguiente →</a><br/><br/><em>Recursos no desglosados:</em><br/><a href="ch04s11.docx" target="_blank">&gt; Acceso sin conexión (formato Word / DOCX)</a><br/><a href="..\EN\js-the-good-parts\ch04s11.html" target="_blank">&gt; Lectura en inglés</a></footer></body></html>