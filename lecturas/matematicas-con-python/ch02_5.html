<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/>
<meta charset="utf-8"/>
<title>Capítulo 2: Visualizar datos con gráficos</title>
<link href="style.css" media="all" rel="stylesheet" type="text/css"/>
<link href="core.css" media="all" rel="stylesheet" type="text/css"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h3 class="h3" id="ch02lev1sec04"><strong>Trazar con fórmulas</strong></h3>
<p class="noindent">Hasta ahora, hemos estado trazando puntos en nuestros gráficos basándonos en medidas científicas observadas. En esas gráficas, ya teníamos todos nuestros valores para <em>x</em> e <em>y</em> establecidos. Por ejemplo, las temperaturas y fechas registradas ya estaban a nuestra disposición en el momento en que quisimos crear el gráfico de la ciudad de Nueva York, mostrando cómo variaba la temperatura a lo largo de meses o años. En esta sección, vamos a crear gráficos a partir de fórmulas matemáticas.</p>
<h4 class="h4" id="ch02lev2sec07"><strong><em>Ley de Gravitación Universal de Newton</em></strong></h4>
<p class="noindent">Según la ley de gravitación universal de Newton, un cuerpo de masa <sub>m1</sub> atrae a otro cuerpo de masa<sub>m2</sub> con una fuerza <em>F</em> según la fórmula</p>
<div class="image2"><img alt="image" src="images/e0046-01.jpg" translate="no"/></div>
<p class="noindent">donde <em>r</em> es la distancia entre los dos cuerpos y <em>G</em> es la constante gravitatoria. Queremos ver qué ocurre con la fuerza a medida que aumenta la distancia entre los dos cuerpos.</p>
<p class="indent">Tomemos las masas de dos cuerpos: la masa del primer cuerpo<em>(</em><sub>m1</sub>) es de 0,5 kg, y la masa del segundo cuerpo<em>(</em><sub>m2</sub>) es de 1,5 kg. El valor de la constante gravitatoria es 6,674 × <sup>10-11</sup> N<sup>m2</sup> <sup>kg-2</sup>. Ahora estamos preparados para calcular la fuerza gravitatoria entre estos dos cuerpos a 19 distancias diferentes: 100 m, 150 m, 200 m, 250 m, 300 m, y así hasta 1000 m. El siguiente programa realiza estos cálculos y también dibuja la gráfica:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   The relationship between gravitational force and<br translate="no"/>   distance between two bodies<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   import matplotlib.pyplot as plt<br translate="no"/><br translate="no"/>   # Draw the graph<br translate="no"/>   def draw_graph(x, y):<br translate="no"/>       plt.plot(x, y, marker='o')<br translate="no"/>       plt.xlabel('Distance in meters')<br translate="no"/><a id="page_47"></a><br translate="no"/>       plt.ylabel('Gravitational force in newtons')<br translate="no"/>       plt.title('Gravitational force and distance')<br translate="no"/>       plt.show()<br translate="no"/><br translate="no"/>   def generate_F_r():<br translate="no"/>       # Generate values for r<br translate="no"/><span class="ent">➊</span>     r = range(100, 1001, 50)<br translate="no"/>       # Empty list to store the calculated values of F<br translate="no"/>       F = []<br translate="no"/><br translate="no"/>       # Constant, G<br translate="no"/>       G = 6.674*(10**-11)<br translate="no"/>       # Two masses<br translate="no"/>       m1 = 0.5<br translate="no"/>       m2 = 1.5<br translate="no"/><br translate="no"/>       # Calculate force and add it to the list, F<br translate="no"/><span class="ent">➋</span>     for dist in r:<br translate="no"/>           force = G*(m1*m2)/(dist**2)<br translate="no"/>           F.append(force)<br translate="no"/><br translate="no"/>       # Call the draw_graph function<br translate="no"/><span class="ent">➌</span>     draw_graph(r, F)<br translate="no"/><br translate="no"/>   if __name__=='__main__':<br translate="no"/>       generate_F_r()</p>
<p class="indent">La función <span class="literal" translate="no">generate_F_r()</span> realiza la mayor parte del trabajo en el programa anterior. En <span class="ent">➊,</span> utilizamos la función <span class="literal" translate="no">range()</span> para crear una lista denominada <span class="literal" translate="no">r</span> con distintos valores para la distancia, utilizando un valor de paso de 50. El valor final se especifica como 1001 porque queremos que también se incluya 1000. A continuación, creamos una lista vacía (<span class="literal" translate="no">F</span>), donde almacenaremos la fuerza gravitatoria correspondiente a cada una de estas distancias. A continuación, creamos etiquetas referidas a la constante gravitatoria (<span class="literal" translate="no">G</span>) y a las dos masas (<span class="literal" translate="no">m1</span> y <span class="literal" translate="no">m2</span>). Utilizando un bucle <span class="literal" translate="no">for</span> <span class="ent">➋,</span> calculamos entonces la fuerza en cada uno de los valores de la lista de distancias (<span class="literal" translate="no">r</span>). Utilizamos una etiqueta (<span class="literal" translate="no">force</span>) para referirnos a la fuerza calculada y añadirla a la lista (<span class="literal" translate="no">F</span>). Por último, llamamos a la función <span class="literal" translate="no">draw_graph()</span> en <span class="ent">➌</span> con la lista de distancias y la lista de las fuerzas calculadas. El <em>eje x</em> del gráfico muestra la fuerza, y el <em>eje y</em> muestra la distancia. El gráfico se muestra en la <a href="ch02.html#ch2fig12">Figura 2-12</a>.</p>
<p class="indent">A medida que aumenta la distancia (<span class="literal" translate="no">r</span>), disminuye la fuerza gravitatoria. Con este tipo de relación, decimos que la fuerza gravitatoria es <em>inversamente proporcional</em> a la distancia entre los dos cuerpos. Además, ten en cuenta que cuando cambia el valor de una de las dos variables, la otra variable no cambiará necesariamente en la misma proporción. A esto lo llamamos <em>relación no lineal</em>. Como resultado, acabamos teniendo una línea curva en la gráfica en lugar de una recta.</p>
<div class="image"><a id="page_48"></a><img alt="image" src="images/f02-12.jpg" translate="no"/></div>
<p class="figuret"><a id="ch2fig12"></a><em>Figura 2-12: Visualización de la relación entre la fuerza gravitatoria y la distancia al cuadrado</em></p>
<h4 class="h4" id="ch02lev2sec08"><strong><em>Movimiento de proyectiles</em></strong></h4>
<p class="noindent">Ahora vamos a representar gráficamente algo que te resultará familiar de la vida cotidiana. Si lanzas una pelota a través de un campo, seguirá una trayectoria como la que se muestra en la <a href="ch02.html#ch2fig13">Figura 2</a>-13.</p>
<div class="image"><img alt="image" src="images/f02-13.jpg" translate="no"/></div>
<p class="figuret"><a id="ch2fig13"></a><em>Figura 2-13: Movimiento de una pelota lanzada en</em> el punto A -con un<em>ángulo (</em>θ)<em> y una velocidad (</em><small>U</small>)<em>- y que cae al suelo en el punto</em> B</p>
<p class="indent"><a id="page_49"></a>En la figura, la pelota es lanzada desde el punto <em>A</em> y cae en el punto <em>B</em>. Este tipo de movimiento se denomina movimiento de <em>proyectil</em>. Nuestro objetivo aquí es utilizar las ecuaciones del movimiento de proyectil para representar gráficamente la trayectoria de un cuerpo, mostrando la posición de la pelota desde el punto en que es lanzada hasta que vuelve a tocar el suelo.</p>
<p class="indent">Cuando lanzas la pelota, ésta tiene una velocidad inicial y la dirección de esa velocidad crea un determinado ángulo con el suelo. Llamemos a la velocidad inicial <em>u</em> y al ángulo que forma con el suelo <em>θ</em> (theta), como se muestra en la <a href="ch02.html#ch2fig13">Figura 2-13</a>. La bola tiene dos componentes de velocidad: una en la dirección <em>x</em>, calculada por <em><sub>ux</sub></em> = <em>u</em> <em>cosθ</em>, y otra en la dirección <em>y</em>, donde <em><sub>uy</sub></em> = <em>u</em> <em>sinθ</em>.</p>
<p class="indentb">A medida que la bola se mueve, su velocidad cambia, y representaremos ese cambio de velocidad mediante <em>v</em>: la componente horizontal es <em><sub>vx</sub></em> y la componente vertical es <em><sub>vy</sub></em>. Para simplificar, supongamos que la componente horizontal<em>(<sub>vx</sub></em>) no cambia durante el movimiento del cuerpo, mientras que la componente vertical<em>(<sub>vy</sub></em>) disminuye debido a la fuerza de la gravedad según la ecuación <em><sub>vy</sub></em> = <em><sub>uy</sub></em> <em>- gt</em>. En esta ecuación, <em>g</em> es la aceleración gravitatoria y <em>t</em> es el tiempo en el que se mide la velocidad. Como <em><sub>uy</sub></em> = <em>u</em> <em>sinθ</em>, podemos sustituir para obtener</p>
<p class="center"><em><sub>vy</sub></em> = <em>u</em> <em>sinθ</em> - <em>gt</em>.</p>
<p class="indentt">Como la componente horizontal de la velocidad permanece constante, la distancia horizontal recorrida<em>(<sub>Sx</sub></em>) viene dada por <em><sub>Sx</sub></em> = <em>u</em>(<em>cosθ</em><em>)t</em>. Sin embargo, la componente vertical de la velocidad cambia, y la distancia vertical recorrida viene dada por la fórmula</p>
<div class="image2"><img alt="image" src="images/e0049-01.jpg" translate="no"/></div>
<p class="indent">En otras palabras, <em><sub>Sx</sub></em> y <em><sub>Sy</sub></em> nos dan las <em>coordenadas</em> <em>x</em> e <em>y</em> de la bola en un momento dado de su vuelo. Utilizaremos estas ecuaciones cuando escribamos un programa para dibujar la trayectoria. Cuando utilicemos estas ecuaciones, el tiempo<em>(t</em>) se expresará en segundos, la velocidad se expresará en m/s, el ángulo de proyección<em>(θ</em>) se expresará en grados y la aceleración gravitatoria<em>(g</em>) se expresará en <sup>m/s2</sup>.</p>
<p class="indent">Sin embargo, antes de escribir nuestro programa, tendremos que averiguar cuánto tiempo estará la pelota en vuelo antes de tocar el suelo, para saber cuándo nuestro programa debe dejar de trazar la trayectoria de la pelota. Para ello, primero averiguaremos cuánto tarda la pelota en alcanzar su punto más alto. La pelota alcanza su punto más alto cuando la componente vertical de la velocidad<em>(<sub>vy</sub></em>) es 0, es decir, cuando <em><sub>vy</sub></em> = <em>u</em> sen <em>θ</em> - <em>gt</em> = 0. Por tanto, buscamos el valor <em>t</em> mediante la fórmula</p>
<div class="image2"><img alt="image" src="images/e0049-02.jpg" translate="no"/></div>
<p class="indent"><a id="page_50"></a>Llamaremos a este tiempo <span class="literal" translate="no">t_peak</span>. Tras alcanzar su punto más alto, la pelota tocará el suelo después de estar en el aire durante otros <span class="literal" translate="no">t_peak</span> segundos, por lo que el tiempo total de vuelo (<span class="literal" translate="no">t_flight</span>) de la pelota es</p>
<div class="image2"><img alt="image" src="images/e0050-01.jpg" translate="no"/></div>
<p class="indent">Tomemos una pelota lanzada con una velocidad inicial<em>(u</em>) de 5 m/s en un ángulo<em>(θ</em>) de 45 grados. Para calcular el tiempo total de vuelo, sustituimos <em>u</em> = 5, <em>θ</em> = 45 y <em>g</em> = 9,8 en la ecuación que vimos anteriormente:</p>
<div class="image2"><img alt="image" src="images/e0050-02.jpg" translate="no"/></div>
<p class="indent">En este caso, el tiempo de vuelo de la pelota resulta ser de 0,72154 segundos (redondeado a cinco decimales). La pelota estará en el aire durante este periodo de tiempo, así que para dibujar la trayectoria, calcularemos sus <em>coordenadas</em> <em>x</em> e y a intervalos regulares durante este periodo de tiempo. ¿Con qué frecuencia debemos calcular las coordenadas? Idealmente, con la mayor frecuencia posible. En este capítulo, calcularemos las coordenadas cada 0,001 segundos.</p>
<h5 class="h5" id="ch02lev3sec04"><strong>Generación de números en coma flotante equidistantes</strong></h5>
<p class="noindent">Hemos utilizado la función <span class="literal" translate="no">range()</span> para generar números enteros igualmente espaciados; es decir, si quisiéramos una lista de números enteros entre 1 y 10 con cada número entero separado por 1, utilizaríamos range(1, 10). Si quisiéramos un valor de paso diferente, podríamos especificarlo a la función rango como tercer argumento. Por desgracia, no existe una función incorporada de este tipo para los números de coma flotante. Así que, por ejemplo, no hay ninguna función que nos permita crear una lista de los números de 0 a 0,72 con dos números consecutivos separados por 0,001. Podemos utilizar un bucle <span class="literal" translate="no">while</span> como el siguiente para crear nuestra propia función para esto:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Generate equally spaced floating point<br translate="no"/>   numbers between two given values<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   def frange(start, final, increment):<br translate="no"/><br translate="no"/>       numbers = []<br translate="no"/><span class="ent">➊</span>     while start &lt; final:<br translate="no"/><span class="ent">➋</span>         numbers.append(start)<br translate="no"/>           start = start + increment<br translate="no"/><br translate="no"/>       return numbers</p>
<p class="indent"><a id="page_51"></a>Hemos definido una función <span class="literal" translate="no">frange()</span> (rango "punto flotante") que recibe tres parámetros: <span class="literal" translate="no">start</span> y <span class="literal" translate="no">final</span> se refieren a los puntos inicial y final del rango de números, y <span class="literal" translate="no">increment</span> se refiere a la diferencia entre dos números consecutivos. Inicializamos un bucle <span class="literal" translate="no">while</span> en <span class="ent">➊,</span> que continúa la ejecución mientras el número apuntado por <span class="literal" translate="no">start</span> sea menor que el valor de <span class="literal" translate="no">final</span>. Almacenamos el número apuntado por <span class="literal" translate="no">start</span> en la lista <span class="literal" translate="no">numbers</span> <span class="ent">➋</span> y luego añadimos el valor que hemos introducido como <span class="literal" translate="no">increment</span> en cada iteración del bucle. Por último, devolvemos la lista <span class="literal" translate="no">numbers</span>.</p>
<p class="indent">Utilizaremos esta función para generar instantes de tiempo igualmente espaciados en el programa de dibujo de trayectorias que se describe a continuación.</p>
<h5 class="h5" id="ch02lev3sec05"><strong>Dibujar la trayectoria</strong></h5>
<p class="noindent">El siguiente programa dibuja la trayectoria de una pelota lanzada con una velocidad y un ángulo determinados, ambos suministrados como entrada al programa:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Draw the trajectory of a body in projectile motion<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   from matplotlib import pyplot as plt<br translate="no"/>   import math<br translate="no"/><br translate="no"/>   def draw_graph(x, y):<br translate="no"/>       plt.plot(x, y)<br translate="no"/>       plt.xlabel('x-coordinate')<br translate="no"/>       plt.ylabel('y-coordinate')<br translate="no"/>       plt.title('Projectile motion of a ball')<br translate="no"/><br translate="no"/>   def frange(start, final, interval):<br translate="no"/><br translate="no"/>       numbers = []<br translate="no"/>       while start &lt; final:<br translate="no"/>           numbers.append(start)<br translate="no"/>           start = start + interval<br translate="no"/><br translate="no"/>       return numbers<br translate="no"/><br translate="no"/>   def draw_trajectory(u, theta):<br translate="no"/><br translate="no"/><span class="ent">➊</span>     theta = math.radians(theta)<br translate="no"/>       g = 9.8<br translate="no"/><br translate="no"/>       # Time of flight<br translate="no"/><span class="ent">➋</span>     t_flight = 2*u*math.sin(theta)/g<br translate="no"/>       # Find time intervals<br translate="no"/>       intervals = frange(0, t_flight, 0.001)<br translate="no"/><a id="page_52"></a><br translate="no"/>       # List of x and y coordinates<br translate="no"/>       x = []<br translate="no"/>       y = []<br translate="no"/><span class="ent">➌</span>     for t in intervals:<br translate="no"/>           x.append(u*math.cos(theta)*t)<br translate="no"/>           y.append(u*math.sin(theta)*t - 0.5*g*t*t)<br translate="no"/><br translate="no"/>       draw_graph(x, y)<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/><span class="ent">➍</span>     try:<br translate="no"/>           u = float(input('Enter the initial velocity (m/s): '))<br translate="no"/>           theta = float(input('Enter the angle of projection (degrees): '))<br translate="no"/>       except ValueError:<br translate="no"/>           print('You entered an invalid input')<br translate="no"/>       else:<br translate="no"/>           draw_trajectory(u, theta)<br translate="no"/>           plt.show()</p>
<p class="indent">En este programa, utilizamos las funciones <span class="literal" translate="no">radians()</span>, <span class="literal" translate="no">cos()</span>, y <span class="literal" translate="no">sin()</span> definidas en el módulo <span class="literal" translate="no">math</span> de la biblioteca estándar, por lo que importamos dicho módulo al principio. La función <span class="literal" translate="no">draw_trajectory()</span> acepta dos argumentos, <span class="literal" translate="no">u</span> y <span class="literal" translate="no">theta</span>, correspondientes a la velocidad y al ángulo con el que se lanza la bola. Las funciones seno y coseno del módulo <span class="literal" translate="no">math</span> esperan que el ángulo se proporcione en radianes, así que en <span class="ent">➊,</span> convertimos el ángulo (<span class="literal" translate="no">theta</span>) de grados a radianes utilizando la función <span class="literal" translate="no">math.radians()</span>. A continuación, creamos una etiqueta (<span class="literal" translate="no">g</span>) para referirnos al valor de la aceleración debida a la gravedad, 9,8 <sup>m/s2</sup>. En <span class="ent">➋,</span> calculamos el tiempo de vuelo y luego llamamos a la función <span class="literal" translate="no">frange()</span> con los valores de <span class="literal" translate="no">start</span>, <span class="literal" translate="no">final</span>, y <span class="literal" translate="no">increment</span> fijados en 0, <span class="literal" translate="no">t_flight</span>, y 0,001, respectivamente. A continuación, calculamos las coordenadas <em>x</em> e <em>y</em> de la trayectoria en cada uno de los instantes de tiempo y las almacenamos en dos listas distintas, <span class="literal" translate="no">x</span> y <span class="literal" translate="no">y</span> <span class="ent">➌.</span> Para calcular estas coordenadas, utilizamos las fórmulas para las distancias <em><sub>Sx</sub></em> y <em><sub>Sy</sub></em> que hemos discutido antes.</p>
<p class="indent">Por último, llamamos a la función <span class="literal" translate="no">draw_graph()</span> con las coordenadas <em>x</em> e <em>y</em> para dibujar la trayectoria. Observa que la función <span class="literal" translate="no">draw_graph()</span> no llama a la función <span class="literal" translate="no">show()</span> (veremos por qué en el siguiente programa). Utilizamos un bloque <span class="literal" translate="no">try...except</span> <span class="ent">➍</span> para informar de un mensaje de error en caso de que el usuario introduzca una entrada no válida. La entrada válida para este programa es cualquier número entero o de coma flotante. Cuando ejecutas el programa, te pide estos valores como entrada y luego dibuja la trayectoria (ver <a href="ch02.html#ch2fig14">Figura 2</a>-14):</p>
<p class="programs" translate="no">Enter the initial velocity (m/s): <span class="codestrong">25</span><br translate="no"/>Enter the angle of projection (degrees): <span class="codestrong">60</span></p>
<div class="image"><a id="page_53"></a><img alt="image" src="images/f02-14.jpg" translate="no"/></div>
<p class="figuret"><a id="ch2fig14"></a><em>Figura 2-14: Trayectoria de una pelota lanzada con una velocidad de 25 m/s y un ángulo de 60 grados</em></p>
<h5 class="h5" id="ch02lev3sec06"><strong>Comparación de la trayectoria con distintas velocidades iniciales</strong></h5>
<p class="noindent">El programa anterior te permite realizar experimentos interesantes. Por ejemplo, ¿cómo sería la trayectoria de tres pelotas lanzadas a distintas velocidades pero con el mismo ángulo inicial? Para representar gráficamente tres trayectorias a la vez, podemos sustituir el bloque de código <span class="literal" translate="no">main</span> de nuestro programa anterior por el siguiente:</p>
<p class="programs" translate="no">   if __name__ == '__main__':<br translate="no"/><br translate="no"/>       # List of three different initial velocities<br translate="no"/><span class="ent">➊</span>     u_list = [20, 40, 60]<br translate="no"/>       theta = 45<br translate="no"/>       for u in u_list:<br translate="no"/>           draw_trajectory(u, theta)<br translate="no"/><br translate="no"/>       # Add a legend and show the graph<br translate="no"/><span class="ent">➋</span>     plt.legend(['20', '40', '60'])<br translate="no"/>       plt.show()</p>
<p class="indent"><a id="page_54"></a>Aquí, en lugar de pedir al usuario del programa que introduzca la velocidad y el ángulo de proyección, creamos una lista (<span class="literal" translate="no">u_list</span>) con las velocidades 20, 40 y 60 en <span class="ent">➊</span> y fijamos el ángulo de proyección en 45 grados (utilizando la etiqueta <span class="literal" translate="no">theta</span>). A continuación, llamamos a la función <span class="literal" translate="no">draw_trajectory()</span> con cada uno de los tres valores de <span class="literal" translate="no">u_list</span> utilizando el mismo valor para <span class="literal" translate="no">theta</span>, que calcula la lista de <em>coordenadas</em> <em>x</em> e <em>y</em> y llama a la función <span class="literal" translate="no">draw_graph()</span>. Cuando llamamos a la función <span class="literal" translate="no">show()</span>, las tres gráficas se muestran en el mismo gráfico. Como ahora tenemos una gráfica con múltiples trazados, añadimos una leyenda a la gráfica en <span class="ent">➋</span> antes de llamar a <span class="literal" translate="no">show()</span> para mostrar la velocidad de cada línea. Cuando ejecutes el programa anterior, verás la gráfica que se muestra en la <a href="ch02.html#ch2fig15">Figura 2-15</a>.</p>
<div class="image"><img alt="image" src="images/f02-15.jpg" translate="no"/></div>
<p class="figuret"><a id="ch2fig15"></a><em>Figura 2-15: La trayectoria de una pelota lanzada en un ángulo de 60 grados, con una velocidad de 20, 40 y 60 m/s</em></p>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="ch02_4.html">anterior</a><a href="ch02.html">Subtema 5 de 7: (Ver todo)</a><a href="ch02_6.html">siguiente</a><br/></p>
<br/><a href="ch02_5.docx" target="_blank"></a></footer>
</body>
</html>
