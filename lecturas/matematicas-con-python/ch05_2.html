<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/>
<meta charset="utf-8"/>
<title>Capítulo 5: Jugar con conjuntos y probabilidad</title>
<link href="style.css" media="all" rel="stylesheet" type="text/css"/>
<link href="core.css" media="all" rel="stylesheet" type="text/css"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h3 class="h3" id="ch05lev1sec01"><strong>¿Qué es un conjunto?</strong></h3>
<p class="noindent">Un <em>conjunto</em> es una colección de objetos distintos, a menudo llamados <em>elementos</em> o <em>miembros</em>. Dos características de un conjunto lo diferencian de cualquier colección de objetos. Un conjunto está "bien definido", lo que significa que la pregunta "¿Está un objeto concreto en esta colección?" siempre tiene una respuesta clara de sí o no, normalmente basada en una regla o en algún criterio dado. La segunda característica es que no hay dos miembros iguales en un conjunto. Un conjunto puede contener cualquier cosa: números, personas, cosas, palabras, etc.</p>
<p class="indent"><a id="page_122"></a>Repasemos algunas propiedades básicas de los conjuntos mientras aprendemos a trabajar con conjuntos en Python utilizando SymPy.</p>
<h4 class="h4" id="ch05lev2sec01"><strong><em>Construcción de conjuntos</em></strong></h4>
<p class="noindent">En notación matemática, un conjunto se representa escribiendo sus miembros entre llaves. Por ejemplo, {2, 4, 6} representa un conjunto con 2, 4 y 6 como miembros. Para crear un conjunto en Python, podemos utilizar la clase <span class="literal" translate="no">FiniteSet</span> del paquete <span class="literal" translate="no">sympy</span>, como se indica a continuación:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(2, 4, 6)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s</span><br translate="no"/>{2, 4, 6}</p>
<p class="indent">Aquí, primero importamos la clase <span class="literal" translate="no">FiniteSet</span> de SymPy y luego creamos un objeto de esta clase pasando los miembros del conjunto como argumentos. Asignamos la etiqueta <span class="literal" translate="no">s</span> al conjunto que acabamos de crear.</p>
<p class="indent">Podemos almacenar distintos tipos de números -incluidos enteros, números de coma flotante y fracciones- en el mismo conjunto:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">from fractions import Fraction</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 1.5, Fraction(1, 5))</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s</span><br translate="no"/>{1/5, 1, 1.5}</p>
<p class="indent">La <em>cardinalidad</em> de un conjunto es el número de miembros del conjunto, que puedes averiguar utilizando la función <span class="literal" translate="no">len()</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 1.5, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">len(s)</span><br translate="no"/>3</p>
<h5 class="h5" id="ch05lev3sec01"><strong>Comprobar si un número está en un conjunto</strong></h5>
<p class="noindent">Para comprobar si un número es miembro de un conjunto existente, utiliza el operador <span class="literal" translate="no">in</span>. Este operador pregunta a Python: "¿Este número está en este conjunto?". Devuelve <span class="literal" translate="no">True</span> si el número pertenece al conjunto y <span class="literal" translate="no">False</span> en caso contrario. Si, por ejemplo, quisiéramos comprobar si el 4 está en el conjunto anterior, haríamos lo siguiente:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">4 in s</span><br translate="no"/>False</p>
<p class="indent">Como el 4 no está presente en el conjunto, el operador devuelve <span class="literal" translate="no">False</span>.</p>
<h5 class="h5" id="ch05lev3sec02"><a id="page_123"></a><strong>Crear un conjunto vacío</strong></h5>
<p class="noindent">Si quieres crear un conjunto <em>vacío</em>, que es un conjunto que no tiene elementos ni miembros, crea un objeto <span class="literal" translate="no">FiniteSet</span> sin pasarle ningún argumento. El resultado es un objeto <span class="literal" translate="no">EmptySet</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet()</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s</span><br translate="no"/>EmptySet()</p>
<h5 class="h5" id="ch05lev3sec03"><strong>Crear conjuntos a partir de listas o tuplas</strong></h5>
<p class="noindent">También puedes crear un conjunto pasando una lista o tupla de miembros del conjunto como argumento a <span class="literal" translate="no">FiniteSet</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">members = [1, 2, 3]</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(*members)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s</span><br translate="no"/>{1, 2, 3}</p>
<p class="indent">Aquí, en lugar de pasar los miembros del conjunto directamente a <span class="literal" translate="no">FiniteSet</span>, primero los almacenamos en una lista, a la que llamamos <span class="literal" translate="no">members</span>. Después, pasamos la lista a <span class="literal" translate="no">FiniteSet</span> utilizando esta sintaxis especial de Python, que básicamente se traduce en crear un objeto <span class="literal" translate="no">FiniteSet</span> que pasa los miembros de la lista como argumentos separados y no como una lista. Es decir, esta forma de crear un objeto <span class="literal" translate="no">FiniteSet</span> es equivalente a <span class="literal" translate="no">FiniteSet(1, 2, 3)</span>. Utilizaremos esta sintaxis cuando se calculen los miembros del conjunto en tiempo de ejecución.</p>
<h5 class="h5" id="ch05lev3sec04"><strong>Repetición y orden de los conjuntos</strong></h5>
<p class="noindent">Los conjuntos en Python (como los conjuntos matemáticos) ignoran cualquier repetición de un miembro, y no llevan la cuenta del orden de los miembros del conjunto. Por ejemplo, si creas un conjunto a partir de una lista que tiene varias instancias de un número, el número se añade al conjunto sólo una vez, y las demás instancias se descartan:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">members = [1, 2, 3, 2]</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">FiniteSet(*members)</span><br translate="no"/>{1, 2, 3}</p>
<p class="indent">Aquí, aunque hayamos pasado una lista que tenía dos instancias del número 2, el número 2 sólo aparece una vez en el conjunto creado a partir de esa lista.</p>
<p class="indent">En las listas y tuplas de Python, cada elemento se almacena en un orden determinado, pero no siempre ocurre lo mismo con los conjuntos. Por ejemplo, podemos imprimir cada miembro de un conjunto iterando a través de él como se indica a continuación:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">for member in s:</span><br translate="no"/> <span class="codestrong">print(member)</span><br translate="no"/><a id="page_124"></a><br translate="no"/>2<br translate="no"/>1<br translate="no"/>3</p>
<p class="indent">Cuando ejecutes este código, los elementos podrían imprimirse en cualquier orden posible. Esto se debe a la forma en que Python almacena los conjuntos: mantiene un registro de los miembros del conjunto, pero no de ningún orden concreto de esos miembros.</p>
<p class="indent">Veamos otro ejemplo. Dos conjuntos son <em>iguales</em> cuando tienen los mismos elementos. En Python, puedes utilizar el operador de igualdad, <span class="literal" translate="no">==</span>, para comprobar si dos conjuntos son iguales:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(3, 4, 5)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(5, 4, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s == t</span><br translate="no"/>True</p>
<p class="indent">Aunque los miembros de estos dos conjuntos aparezcan en distinto orden, los conjuntos siguen siendo iguales.</p>
<h4 class="h4" id="ch05lev2sec02"><strong><em>Subconjuntos, superconjuntos y conjuntos potentes</em></strong></h4>
<p class="noindent">Un conjunto, <em>s</em>, es <em>subconjunto</em> de otro conjunto, <em>t</em>, si todos los miembros de <em>s</em> son también miembros de <em>t</em>. Por ejemplo, el conjunto {1} es subconjunto del conjunto {1, 2}. Puedes comprobar si un conjunto es subconjunto de otro mediante el método <span class="literal" translate="no">is_subset()</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(1,2)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s.is_subset(t)</span><br translate="no"/>True<br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t.is_subset(s)</span><br translate="no"/>False</p>
<p class="indent">Observa que un conjunto vacío es un subconjunto de todo conjunto. Además, cualquier conjunto es un subconjunto de sí mismo, como puedes ver a continuación:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">s.is_subset(s)</span><br translate="no"/>True<br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t.is_subset(t)</span><br translate="no"/>True</p>
<p class="indent">Del mismo modo, se dice que un conjunto, <em>t</em>, es <em>superconjunto</em> de otro conjunto, <em>s</em>, si <em>t</em> contiene todos los miembros contenidos en <em>s</em>. Puedes comprobar si un conjunto es superconjunto de otro utilizando el método <span class="literal" translate="no">is_superset()</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">s.is_superset(t)</span><br translate="no"/>False<br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t.is_superset(s)</span><br translate="no"/>True</p>
<p class="indent"><a id="page_125"></a>El <em>conjunto potencia</em> de un conjunto, <em>s</em>, es el conjunto de todos los subconjuntos posibles de <em>s</em>. Cualquier conjunto, <em>s</em>, tiene precisamente <sup><em>2|s|</em></sup> subconjuntos, donde <em>|s|</em> es la cardinalidad del conjunto. Por ejemplo, el conjunto {1, 2, 3} tiene una cardinalidad de 3, por lo que tiene<sup>23</sup> u 8 subconjuntos: {} (el conjunto vacío), {1}, {2}, {3}, {1, 2}, {2, 3}, {1, 3} y {1, 2, 3}.</p>
<p class="indent">El conjunto de todos estos subconjuntos forma el conjunto potencia, y podemos hallar el conjunto potencia utilizando el método <span class="literal" translate="no">powerset()</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">ps = s.powerset()</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">ps</span><br translate="no"/>{{1}, {1, 2}, {1, 3}, {1, 2, 3}, {2}, {2, 3}, {3}, EmptySet()}</p>
<p class="indent">Como el conjunto potencia es un conjunto en sí mismo, puedes hallar su cardinalidad utilizando la función <span class="literal" translate="no">len()</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">len(ps)</span><br translate="no"/>8</p>
<p class="indent">La cardinalidad del conjunto potencia es <sup><em>2|s|</em></sup>, que es<sup>23</sup> = 8.</p>
<p class="indent">Según nuestra definición de subconjunto, dos conjuntos cualesquiera con exactamente los mismos miembros serían subconjuntos y superconjuntos entre sí. Por el contrario, un conjunto, <em>s</em>, es un <em>subconjunto</em> propio de <em>t</em> sólo si todos los miembros de <em>s</em> están también en <em>t</em> y <em>t</em> tiene al menos un miembro que no está en <em>s</em>. Así, si <em>s</em> = {1, 2, 3}, sólo es un subconjunto propio de <em>t</em> si <em>t</em> contiene 1, 2 y 3 más al menos un miembro más. Esto también significaría que <em>t</em> es un <em>superconjunto</em> adecuado de <em>s</em>. Puedes utilizar el método <span class="literal" translate="no">is_proper_subset()</span> y el método <span class="literal" translate="no">is_proper_superset()</span> para comprobar estas relaciones:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(1, 2, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s.is_proper_subset(t)</span><br translate="no"/>False<br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t.is_proper_superset(s)</span><br translate="no"/>False</p>
<p class="indent">Ahora, si volvemos a crear el conjunto <span class="literal" translate="no">t</span> para incluir otro miembro, <span class="literal" translate="no">s</span> se considerará un subconjunto propio de <span class="literal" translate="no">t</span> y <span class="literal" translate="no">t</span> un superconjunto propio de <span class="literal" translate="no">s</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(1, 2, 3, 4)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s.is_proper_subset(t)</span><br translate="no"/>True<br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t.is_proper_superset(s)</span><br translate="no"/>True</p>
<div class="sidebar">
<p class="sidebart"><a id="page_126"></a><strong>CONJUNTOS NUMÉRICOS COMUNES</strong></p>
<p class="noindent">En el primer capítulo aprendimos que existen distintos tipos de números: enteros, de coma flotante, fracciones y complejos. Todos estos números forman diferentes conjuntos numéricos, que tienen nombres especiales.</p>
<p class="indent">Todos los números enteros positivos y negativos forman el conjunto de los <em>números enteros</em>. Todos los números enteros positivos forman el conjunto de los números <em>naturales</em> (a veces el 0 se incluye en este conjunto de números aunque no sea positivo, pero a veces no). Esto significa que el conjunto de los números naturales es un subconjunto propio del conjunto de los números enteros.</p>
<p class="indent">El conjunto de los <em>números racionales</em> incluye cualquier número que pueda expresarse como fracción, lo que incluye todos los números enteros, además de cualquier número con terminación decimal que termine o se repita (incluyendo números como 1/4 o 0,25, y 1/3 o 0,33333 ...). Por el contrario, los números decimales que no se repiten ni terminan se conocen como <em>números irracionales</em>. Tanto la raíz cuadrada de 2 como <em>π</em> son ejemplos de números irracionales, porque se eternizan sin repetirse.</p>
<p class="indent">Si juntas todos los números racionales e irracionales, obtienes el conjunto de los <em>números reales</em>. Pero aún mayor es el conjunto de los <em>números complejos</em>, que incluye todos los números reales y todos los números con componente imaginario.</p>
<p class="indent">Todos estos conjuntos de números son conjuntos infinitos porque tienen infinitos miembros. En cambio, los conjuntos de los que hemos hablado en este capítulo tienen un número finito de miembros, por eso la clase SymPy que utilizamos se llama <span class="literal" translate="no">FiniteSet</span>.</p>
</div>
<h4 class="h4" id="ch05lev2sec03"><strong><em>Operaciones con conjuntos</em></strong></h4>
<p class="noindent">Las operaciones con conjuntos, como la unión, la intersección y el producto cartesiano, te permiten combinar conjuntos de determinadas formas metódicas. Estas operaciones con conjuntos son muy útiles en situaciones reales de resolución de problemas, cuando tenemos que considerar varios conjuntos juntos. Más adelante en este capítulo, veremos cómo utilizar estas operaciones para aplicar una fórmula a varios conjuntos de datos y calcular las probabilidades de sucesos aleatorios.</p>
<h5 class="h5" id="ch05lev3sec05"><strong>Unión e intersección</strong></h5>
<p class="noindent">La <em>unión</em> de dos conjuntos es un conjunto que contiene todos los miembros <em>distintos</em> de los dos conjuntos. En teoría de conjuntos, utilizamos el símbolo ∪ para referirnos a la operación de unión. Por ejemplo, {1, 2} ∪ {2, 3} dará como resultado un nuevo conjunto, {1, 2, 3}. En SymPy, la unión de estos dos conjuntos puede crearse utilizando el método <span class="literal" translate="no">union()</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(2, 4, 6)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s.union(t)</span><br translate="no"/>{1, 2, 3, 4, 6}</p>
<p class="indent"><a id="page_127"></a>Encontramos la unión de <span class="literal" translate="no">s</span> y <span class="literal" translate="no">t</span> aplicando el método <span class="literal" translate="no">union</span> a <span class="literal" translate="no">s</span> y pasando <span class="literal" translate="no">t</span> como argumento. El resultado es un tercer conjunto con todos los miembros distintos de los dos conjuntos. En otras palabras, cada miembro de este tercer conjunto es miembro de uno o de los dos primeros conjuntos.</p>
<p class="indent">La <em>intersección</em> de dos conjuntos crea un nuevo conjunto a partir de los elementos comunes a ambos conjuntos. Por ejemplo, la intersección de los conjuntos {1, 2} y {2, 3} dará como resultado un nuevo conjunto con el único elemento común, {2}. Matemáticamente, esta operación se escribe como {1, 2} ∩ {2, 3}.</p>
<p class="indent">En SymPy, utiliza el método <span class="literal" translate="no">intersect()</span> para hallar la intersección:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(2, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s.intersect(t)</span><br translate="no"/>{2}</p>
<p class="indent">Mientras que la operación de unión encuentra los miembros que están en uno <em>u otro</em> conjunto, la operación de intersección encuentra los elementos que están presentes en ambos. Ambas operaciones también pueden aplicarse a más de dos conjuntos. Por ejemplo, así es como encontrarías la unión de tres conjuntos:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(2, 4, 6)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">u = FiniteSet(3, 5, 7)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s.union(t).union(u)</span><br translate="no"/>{1, 2, 3, 4, 5, 6, 7}</p>
<p class="indent">Del mismo modo, así es como encontrarías la intersección de tres conjuntos:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">s.intersect(t).intersect(u)</span><br translate="no"/>EmptySet()</p>
<p class="indent">La intersección de los conjuntos <span class="literal" translate="no">s</span>, <span class="literal" translate="no">t</span>, y <span class="literal" translate="no">u</span> resulta ser un conjunto vacío porque no hay elementos que compartan los tres conjuntos.</p>
<h5 class="h5" id="ch05lev3sec06"><strong>Producto cartesiano</strong></h5>
<p class="noindent">El producto <em>cartesiano</em> de dos conjuntos crea un conjunto formado por todas las parejas posibles formadas tomando un elemento de cada conjunto. Por ejemplo, el producto cartesiano de los conjuntos {1, 2} y {3, 4} es {(1, 3), (1, 4), (2, 3), (2, 4)}. En SymPy, puedes hallar el producto cartesiano de dos conjuntos utilizando simplemente el operador multiplicación:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(3, 4)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">p = s*t</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">p</span><br translate="no"/>{1, 2} x {3, 4}</p>
<p class="indent"><a id="page_128"></a>Éste toma el producto cartesiano de los conjuntos <span class="literal" translate="no">s</span> y <span class="literal" translate="no">t</span> y lo almacena como <span class="literal" translate="no">p</span>. Para ver realmente cada par en ese producto cartesiano, podemos iterar a través de ellos e imprimirlos como sigue:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">for elem in p:</span><br translate="no"/> <span class="codestrong">print(elem)</span><br translate="no"/>(1, 3)<br translate="no"/>(1, 4)<br translate="no"/>(2, 3)<br translate="no"/>(2, 4)</p>
<p class="indent">Cada elemento del producto es una tupla formada por un miembro del primer conjunto y un miembro del segundo conjunto.</p>
<p class="indent">La cardinalidad del producto cartesiano es el producto de la cardinalidad de los conjuntos individuales. Podemos demostrarlo en Python:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">len(p) == len(s)*len(t)</span><br translate="no"/>True</p>
<p class="indent">Si aplicamos el operador exponencial (<span class="literal" translate="no">**</span>) a un conjunto, obtendremos el producto cartesiano de ese conjunto multiplicado por sí mismo el número de veces especificado.</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">p = s**3</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">p</span><br translate="no"/>{1, 2} x {1, 2} x {1, 2}</p>
<p class="indent">Aquí, por ejemplo, elevamos el conjunto <span class="literal" translate="no">s</span> a la potencia de 3. Como estamos tomando el producto cartesiano de tres conjuntos, esto nos da un conjunto de todos los posibles tripletes que contienen un miembro de cada conjunto:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">for elem in p:</span><br translate="no"/> <span class="codestrong">print(elem)</span><br translate="no"/>(1, 1, 1)<br translate="no"/>(1, 1, 2)<br translate="no"/>(1, 2, 1)<br translate="no"/>(1, 2, 2)<br translate="no"/>(2, 1, 1)<br translate="no"/>(2, 1, 2)<br translate="no"/>(2, 2, 1)<br translate="no"/>(2, 2, 2)</p>
<p class="indent">Encontrar el producto cartesiano de conjuntos es útil para encontrar todas las combinaciones posibles de los miembros del conjunto, que exploraremos a continuación.</p>
<h5 class="h5" id="ch05lev3sec07"><a id="page_129"></a><strong>Aplicación de una fórmula a múltiples conjuntos de variables</strong></h5>
<p class="noindent">Considera un péndulo simple de longitud <em>L</em>. El <em>período de tiempo</em>, <em>T</em>, de este péndulo -es decir, la cantidad de tiempo que tarda el péndulo en completar una oscilación completa- viene dado por la fórmula</p>
<div class="image2"><img alt="image" src="images/e0129-01.jpg" translate="no"/></div>
<p class="indent">Aquí, <em>π</em> es la constante matemática, <em>pi</em>, y <em>g</em> es la aceleración gravitatoria local, que es de unos 9,8 <sup>m/s2</sup> en la Tierra. Como <em>π</em> y <em>g</em> son constantes, la longitud, <em>L</em>, es la única variable del lado derecho de la ecuación que no tiene un valor constante.</p>
<p class="indent">Si quisieras ver cómo varía el período de tiempo de un péndulo simple con su longitud, asumirías distintos valores para la longitud y medirías el período de tiempo correspondiente a cada uno de estos valores utilizando la fórmula. Un experimento típico de bachillerato consiste en comparar el periodo de tiempo que obtienes utilizando la fórmula anterior, que es el resultado teórico, con el que mides en el laboratorio, que es el resultado experimental. Por ejemplo, elijamos cinco valores diferentes: 15, 18, 21, 22,5 y 25 (todos ellos expresados en centímetros). Con Python, podemos escribir un programa rápido que agilizará los cálculos de los resultados teóricos:</p>
<p class="programs" translate="no">   from sympy import FiniteSet, pi<br translate="no"/><span class="ent">➊</span> def time_period(length):<br translate="no"/>       g = 9.8<br translate="no"/>       T = 2*pi*(length/g)**0.5<br translate="no"/>       return T<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/><span class="ent">➋</span>     L = FiniteSet(15, 18, 21, 22.5, 25)<br translate="no"/>       for l in L:<br translate="no"/><span class="ent">➌</span>         t = time_period(l/100)<br translate="no"/>           print('Length: {0} cm Time Period: {1:.3f} s'. format(float(l), float(t)))</p>
<p class="indent">Primero definimos la función <span class="literal" translate="no">time_period</span> en <span class="ent">➊.</span> Esta función aplica la fórmula mostrada anteriormente a una longitud dada, que se pasa como <span class="literal" translate="no">length</span>. A continuación, nuestro programa define un conjunto de longitudes en <span class="ent">➋</span> y aplica la función <span class="literal" translate="no">time_period</span> a cada valor en <span class="ent">➌.</span> Observa que cuando pasamos los valores de longitud a <span class="literal" translate="no">time_period</span>, los dividimos por 100. Esta operación convierte las longitudes de centímetros a metros para que coincidan con la unidad de aceleración gravitatoria, que se expresa en unidades de <sup>metros/segundo2</sup>. Por último, imprimimos el periodo de tiempo calculado. Cuando ejecutes el programa, verás la siguiente salida:</p>
<p class="programs" translate="no">Length: 15.0 cm Time Period: 0.777 s<br translate="no"/>Length: 18.0 cm Time Period: 0.852 s<br translate="no"/>Length: 21.0 cm Time Period: 0.920 s<br translate="no"/>Length: 22.5 cm Time Period: 0.952 s<br translate="no"/>Length: 25.0 cm Time Period: 1.004 s</p>
<h5 class="h5" id="ch05lev3sec08"><a id="page_130"></a><strong>Gravedad diferente, resultados diferentes</strong></h5>
<p class="noindent">Ahora, imagina que realizamos este experimento en tres lugares distintos: mi ubicación actual, Brisbane, Australia; el Polo Norte; y el ecuador. La fuerza de la gravedad varía ligeramente en función de la latitud de tu ubicación: es un poco menor (aproximadamente 9,78 <sup>m/s2</sup>) en el ecuador y mayor (9,83 <sup>m/s2</sup>) en el Polo Norte. Esto significa que podemos tratar la fuerza de la gravedad como una variable en nuestra fórmula, en lugar de como una constante, y calcular los resultados para tres valores diferentes de aceleración gravitatoria: {9.8, 9.78, 9.83}.</p>
<p class="indent">Si queremos calcular el período de un péndulo para cada una de nuestras cinco longitudes en cada uno de estos tres lugares, una forma sistemática de calcular todas estas combinaciones de los valores es tomar el producto cartesiano, como se muestra en el siguiente programa:</p>
<p class="programs" translate="no">   from sympy import FiniteSet, pi<br translate="no"/><br translate="no"/>   def time_period(length, g):<br translate="no"/><br translate="no"/>       T = 2*pi*(length/g)**0.5<br translate="no"/>       return T<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/><br translate="no"/>       L = FiniteSet(15, 18, 21, 22.5, 25)<br translate="no"/>       g_values = FiniteSet(9.8, 9.78, 9.83)<br translate="no"/><span class="ent">➊</span>     print('{0:^15}{1:^15}{2:^15}'.format('Length(cm)', 'Gravity(m/s^2)', 'Time Period(s)'))<br translate="no"/><span class="ent">➋</span>     for elem in L*g_values:<br translate="no"/><span class="ent">➌</span>         l = elem[0]<br translate="no"/><span class="ent">➍</span>         g = elem[1]<br translate="no"/>           t = time_period(l/100, g)<br translate="no"/><br translate="no"/><span class="ent">➎</span>         print('{0:^15}{1:^15}{2:^15.3f}'.format(float(l), float(g), float(t)))</p>
<p class="indent">En <span class="ent">➋,</span> tomamos el producto cartesiano de nuestros dos conjuntos de variables, <span class="literal" translate="no">L</span> y <span class="literal" translate="no">g_values</span>, e iteramos por cada combinación de valores resultante para calcular el periodo de tiempo. Cada combinación se representa como una tupla, y de cada tupla extraemos el primer valor, la longitud, en <span class="ent">➌</span> y el segundo valor, la gravedad, en <span class="ent">➍.</span> A continuación, igual que antes, llamamos a la función <span class="literal" translate="no">time_period()</span> con estas dos etiquetas como parámetros, e imprimimos los valores de longitud (<span class="literal" translate="no">l</span>), gravedad (<span class="literal" translate="no">g</span>), y el periodo de tiempo correspondiente (<span class="literal" translate="no">T</span>).</p>
<p class="indent">La salida se presenta en una tabla para facilitar su seguimiento. La tabla se formatea mediante las sentencias <span class="literal" translate="no">print</span> en <span class="ent">➊</span> y <span class="ent">➎.</span> La cadena de formato <span class="literal" translate="no">{0:^15} {1:^15}{2:^15.3f}</span> crea tres campos, cada uno de 15 espacios de ancho, y el símbolo <span class="literal" translate="no">^</span> centra cada entrada en cada campo. En el último campo de la sentencia <span class="literal" translate="no">print</span> en <span class="ent">➎,</span> <span class="literal" translate="no">'.3f'</span> limita a tres el número de dígitos después del punto decimal.</p>
<p class="indent">Cuando ejecutes el programa, verás la siguiente salida:</p>
<p class="programs" translate="no">Length(cm)   Gravity(m/s^2)   Time Period(s)<br translate="no"/>    15.0           9.78             0.778<br translate="no"/>    15.0            9.8             0.777<br translate="no"/>    15.0           9.83             0.776<br translate="no"/><a id="page_131"></a><br translate="no"/>    18.0           9.78             0.852<br translate="no"/>    18.0            9.8             0.852<br translate="no"/>    18.0           9.83             0.850<br translate="no"/>    21.0           9.78             0.921<br translate="no"/>    21.0            9.8             0.920<br translate="no"/>    21.0           9.83             0.918<br translate="no"/>    22.5           9.78             0.953<br translate="no"/>    22.5            9.8             0.952<br translate="no"/>    22.5           9.83             0.951<br translate="no"/>    25.0           9.78             1.005<br translate="no"/>    25.0            9.8             1.004<br translate="no"/>    25.0           9.83             1.002</p>
<p class="indent">Este experimento presenta un escenario sencillo en el que necesitas todas las combinaciones posibles de los elementos de varios conjuntos (o un grupo de números). En este tipo de situación, el producto cartesiano es exactamente lo que necesitas.</p>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="ch05_1.html">anterior</a><a href="ch05.html">Subtema 2 de 5: (Ver todo)</a><a href="ch05_3.html">siguiente</a><br/></p>
<br/><a href="ch05_2.docx" target="_blank"></a></footer>
</body>
</html>
