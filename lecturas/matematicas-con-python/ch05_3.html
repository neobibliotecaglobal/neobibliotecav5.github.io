<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/>
<meta charset="utf-8"/>
<title>Capítulo 5: Jugar con conjuntos y probabilidad</title>
<link href="style.css" media="all" rel="stylesheet" type="text/css"/>
<link href="core.css" media="all" rel="stylesheet" type="text/css"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h3 class="h3" id="ch05lev1sec02"><strong>Probabilidad</strong></h3>
<p class="noindentb">Los conjuntos nos permiten razonar sobre los conceptos básicos de la probabilidad. Empezaremos con algunas definiciones:</p>
<p class="itemlist"><strong>Experimento</strong> El <em>experimento</em> es simplemente la prueba que queremos realizar. Realizamos la prueba porque nos interesa la probabilidad de cada resultado posible. Lanzar un dado, lanzar una moneda y sacar una carta de una baraja son ejemplos de experimentos. Una única ejecución de un experimento se denomina <em>ensayo</em>.</p>
<p class="itemlist"><em>Espacio muestral</em> Todos los resultados posibles de un experimento forman un conjunto conocido como <em>espacio muestral</em>, que normalmente llamaremos <em>S</em> en nuestras fórmulas. Por ejemplo, cuando se lanza una vez un dado de seis caras, el espacio muestral es {1, 2, 3, 4, 5, 6}.</p>
<p class="itemlist"><strong>Evento</strong> Un <em>evento</em> es un conjunto de resultados de los que queremos calcular la probabilidad y que forman un <em>subconjunto</em> del espacio muestral. Por ejemplo, podemos querer conocer la probabilidad de un resultado concreto, como sacar un 3, o la probabilidad de un conjunto de resultados múltiples, como sacar un número par (2, 4 ó 6). Utilizaremos la letra <em>E</em> en nuestras fórmulas para representar un suceso.</p>
<p class="indentt">Si existe una <em>distribución uniforme,</em>es decir, si cada resultado del espacio muestral tiene la misma probabilidad de producirse, la probabilidad de que se produzca un suceso, <em>P</em><em>(E</em>), se calcula mediante la siguiente fórmula (hablaré de las distribuciones no uniformes un poco más adelante en este capítulo):</p>
<div class="image2"><img alt="image" src="images/e0131-01.jpg" translate="no"/></div>
<p class="indent">Aquí, <em>n</em>(<em>E</em>) y <em>n</em><em>(S</em>) son la cardinalidad de los conjuntos <em>E</em>, el suceso, y <em>S</em>, el espacio muestral, respectivamente. El valor de <em>P</em><em>(E</em>) oscila entre 0 y 1, y los valores más altos indican una mayor probabilidad de que ocurra el suceso.</p>
<p class="indent"><a id="page_132"></a>Podemos aplicar esta fórmula a la tirada de un dado para calcular la probabilidad de una determinada tirada, por ejemplo, 3:</p>
<div class="image2"><img alt="image" src="images/e0132-01.jpg" translate="no"/></div>
<p class="indent">Esto confirma lo que era evidente desde el principio: la probabilidad de una determinada tirada es 1/6. Podrías hacer fácilmente este cálculo mentalmente, pero podemos utilizar esta fórmula para escribir la siguiente función en Python que calcula la probabilidad de cualquier suceso, <span class="literal" translate="no">event</span>, en cualquier espacio muestral, <span class="literal" translate="no">space</span>:</p>
<p class="programs" translate="no">def probability(space, event):<br translate="no"/>    return len(event)/len(space)</p>
<p class="indent">En esta función, los dos argumentos <span class="literal" translate="no">space</span> y <span class="literal" translate="no">event</span>-el espacio muestral y el suceso- no tienen por qué ser conjuntos creados con <span class="literal" translate="no">FiniteSet</span>. También pueden ser listas o, para el caso, cualquier otro objeto de Python que admita la función <span class="literal" translate="no">len()</span>.</p>
<p class="indent">Utilizando esta función, escribamos un programa para averiguar la probabilidad de que aparezca un número primo al lanzar un dado de 20 caras:</p>
<p class="programs" translate="no">     def probability(space, event):<br translate="no"/>         return len(event)/len(space)<br translate="no"/><br translate="no"/><span class="ent">➊</span>   def check_prime(number):<br translate="no"/>         if number != 1:<br translate="no"/>             for factor in range(2, number):<br translate="no"/>                 if number % factor == 0:<br translate="no"/>                     return False<br translate="no"/>         else:<br translate="no"/>             return False<br translate="no"/>         return True<br translate="no"/><br translate="no"/>     if __name__ == '__main__':<br translate="no"/><span class="ent">➋</span>       space = FiniteSet(*range(1, 21))<br translate="no"/>         primes = []<br translate="no"/>         for num in s:<br translate="no"/><span class="ent">➌</span>           if check_prime(num):<br translate="no"/>                 primes.append(num)<br translate="no"/><span class="ent">➍</span>           event= FiniteSet(*primes)<br translate="no"/>         p = probability(space, event)<br translate="no"/><br translate="no"/>         print('Sample space: {0}'.format(space))<br translate="no"/>         print('Event: {0}'.format(event))<br translate="no"/>         print('Probability of rolling a prime: {0:.5f}'.format(p))</p>
<p class="indent"><a id="page_133"></a>Primero creamos un conjunto que represente el espacio muestral, <span class="literal" translate="no">space</span>, utilizando la función <span class="literal" translate="no">range()</span> en <span class="ent">➋.</span> Para crear el conjunto de sucesos, necesitamos encontrar los números primos del espacio muestral, así que definimos una función, <span class="literal" translate="no">check_prime()</span>, en <span class="ent">➊.</span> Esta función toma un número entero y comprueba si es divisible (sin resto) por cualquier número entre 2 y él mismo. Si es así, devuelve <span class="literal" translate="no">False</span>. Como un número primo sólo es divisible por 1 y por sí mismo, esta función devuelve <span class="literal" translate="no">True</span> si un número entero es primo y <span class="literal" translate="no">False</span> en caso contrario.</p>
<p class="indent">Llamamos a esta función para cada uno de los números del espacio muestral en <span class="ent">➌</span> y añadimos los números primos a una lista, <span class="literal" translate="no">primes</span>. A continuación, creamos nuestro conjunto de sucesos, <span class="literal" translate="no">event</span>, a partir de esta lista en <span class="ent">➍.</span> Por último, llamamos a la función <span class="literal" translate="no">probability()</span> que hemos creado antes. Al ejecutar el programa obtenemos el siguiente resultado:</p>
<p class="programs" translate="no">Sample space: {1, 2, 3, ..., 18, 19, 20}<br translate="no"/>Event: {2, 3, 5, 7, 11, 13, 17, 19}<br translate="no"/>Probability of rolling a prime: 0.40000</p>
<p class="indent">Aquí, <em>n</em><em>(E</em>) = 8 y <em>n</em><em>(S</em>) = 20, por lo que la probabilidad, <em>P</em>, es 0,4.</p>
<p class="indent">En nuestro programa del dado de 20 caras, realmente no necesitábamos crear los conjuntos; en su lugar, podríamos haber llamado a la función <span class="literal" translate="no">probability()</span> con el espacio muestral y los sucesos como listas:</p>
<p class="programs" translate="no">if __name__ == '__main__':<br translate="no"/>    space = range(1, 21)<br translate="no"/>    primes = []<br translate="no"/>    for num in space:<br translate="no"/>        if check_prime(num):<br translate="no"/>            primes.append(num)<br translate="no"/>    p = probability(space, primes)</p>
<p class="indent">La función <span class="literal" translate="no">probability()</span> funciona igual de bien en este caso.</p>
<h4 class="h4" id="ch05lev2sec04"><strong><em>Probabilidad del suceso A o del suceso B</em></strong></h4>
<p class="noindentb">Supongamos que nos interesan dos posibles sucesos y queremos hallar la probabilidad de que ocurra <em>alguno de</em> ellos. Por ejemplo, volviendo a una simple tirada de dado, consideremos los dos sucesos siguientes:</p>
<p class="itemlist">A = El número es un número primo.</p>
<p class="itemlist">B = El número es impar.</p>
<p class="indentt">Como antes, el espacio muestral, <em>S</em>, es {1, 2, 3, 4, 5, 6}. El suceso A puede representarse como el subconjunto {2, 3, 5}, el conjunto de números primos del espacio muestral, y el suceso B puede representarse como {1, 3, 5}, los números impares del espacio muestral. Para calcular la probabilidad de cualquiera de los dos conjuntos de resultados, podemos hallar la probabilidad de la <em>unión</em> de los dos conjuntos. En nuestra notación, podríamos decir</p>
<div class="image2"><img alt="image" src="images/e0133-01.jpg" translate="no"/></div>
<p class="indent"><a id="page_134"></a>Ahora vamos a realizar este cálculo en Python:</p>
<p class="programs" translate="no">   &gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3, 4, 5, 6)</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">a = FiniteSet(2, 3, 5)</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">b = FiniteSet(1, 3, 5)</span><br translate="no"/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">e = a.union(b)</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">len(e)/len(s)</span><br translate="no"/>   0.6666666666666666</p>
<p class="indent">Primero creamos un conjunto, <span class="literal" translate="no">s</span>, que representa el espacio muestral, seguido de los dos conjuntos <span class="literal" translate="no">a</span> y <span class="literal" translate="no">b</span>. A continuación, en <span class="ent">➊,</span> utilizamos el método <span class="literal" translate="no">union()</span> para encontrar el conjunto de sucesos, <span class="literal" translate="no">e</span>. Por último, calculamos la probabilidad de la unión de los dos conjuntos utilizando la fórmula anterior.</p>
<h4 class="h4" id="ch05lev2sec05"><strong><em>Probabilidad del suceso A y del suceso B</em></strong></h4>
<p class="noindentb">Supongamos que tienes dos sucesos en mente y quieres calcular las probabilidades de que ocurran <em>ambos</em>; por ejemplo, las probabilidades de que la tirada de un dado sea a la vez primo e impar. Para determinarlo, calcula la probabilidad de la intersección de los dos conjuntos de sucesos:</p>
<p class="center"><em>E</em> = <em>A</em> ∩ <em>B</em> = {2, 3, 5} ∩ {1, 3, 5} = {3, 5}</p>
<p class="indentt">Podemos calcular la probabilidad de que ocurran tanto A como B utilizando el método <span class="literal" translate="no">intersect()</span>, que es similar al que hicimos en el caso anterior:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3, 4, 5, 6)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">a = FiniteSet(2, 3, 5)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">b = FiniteSet(1, 3, 5)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">e = a.intersect(b)</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">len(e)/len(s)</span><br translate="no"/>0.3333333333333333</p>
<h4 class="h4" id="ch05lev2sec06"><strong><em>Generar números aleatorios</em></strong></h4>
<p class="noindent">Los conceptos de probabilidad nos permiten razonar y calcular la posibilidad de que ocurra un suceso. Para simular realmente tales sucesos -como un simple juego de dados- utilizando programas informáticos, necesitamos una forma de generar números aleatorios.</p>
<h5 class="h5" id="ch05lev3sec09"><strong>Simular la tirada de un dado</strong></h5>
<p class="noindent">Para simular la tirada de un dado de seis caras, necesitamos una forma de generar un número entero aleatorio entre 1 y 6. El módulo <span class="literal" translate="no">random</span> de la biblioteca estándar de Python nos proporciona varias funciones para generar números aleatorios. Dos funciones que utilizaremos en este capítulo son la función <span class="literal" translate="no">randint()</span>, que genera un entero aleatorio en un rango dado, y la función <span class="literal" translate="no">random()</span>, <a id="page_135"></a>que genera un número de coma flotante entre 0 y 1. Veamos un ejemplo rápido de cómo funciona la función <span class="literal" translate="no">randint()</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">import random</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">random.randint(1, 6)</span><br translate="no"/>4</p>
<p class="indent">La función <span class="literal" translate="no">randint()</span> toma dos números enteros como argumentos y devuelve un número entero aleatorio que cae entre estos dos números (ambos inclusive). En este ejemplo, pasamos el rango <span class="literal" translate="no">(1, 6)</span>, y nos devolvió el número 4, pero si volvemos a llamarla, es muy probable que obtengamos un número diferente:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">random.randint(1, 6)</span><br translate="no"/>6</p>
<p class="indent">Llamar a la función <span class="literal" translate="no">randint()</span> nos permite simular la tirada de nuestro dado virtual. Cada vez que llamemos a esta función, obtendremos un número entre 1 y 6, igual que si lanzáramos un dado de seis caras. Ten en cuenta que <span class="literal" translate="no">randint()</span> espera que proporciones primero el número más bajo, por lo que <span class="literal" translate="no">randint(6, 1)</span> no es válido.</p>
<h5 class="h5" id="ch05lev3sec10"><strong>¿Puedes sacar esa puntuación?</strong></h5>
<p class="noindent">Nuestro siguiente programa simulará un sencillo juego de lanzamiento de dados, en el que seguimos lanzando el dado de seis caras hasta que hayamos sacado un total de 20:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Roll a die until the total score is 20<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   import matplotlib.pyplot as plt<br translate="no"/>   import random<br translate="no"/><br translate="no"/>   target_score = 20<br translate="no"/><br translate="no"/>   def roll():<br translate="no"/>       return random.randint(1, 6)<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/>       score = 0<br translate="no"/>       num_rolls = 0<br translate="no"/><span class="ent">➊</span>     while score &lt; target_score:<br translate="no"/>           die_roll = roll()<br translate="no"/>           num_rolls += 1<br translate="no"/>           print('Rolled: {0}'.format(die_roll))<br translate="no"/>           score += die_roll<br translate="no"/><br translate="no"/>       print('Score of {0} reached in {1} rolls'.format(score, num_rolls))</p>
<p class="indent"><a id="page_136"></a>Primero, definimos la misma función <span class="literal" translate="no">roll()</span> que creamos antes. A continuación, utilizamos un bucle <span class="literal" translate="no">while</span> en <span class="ent">➊</span> para llamar a esta función, llevar la cuenta del número de tiradas, imprimir la tirada actual y sumar la puntuación total. El bucle se repite hasta que la puntuación llega a 20, y entonces el programa imprime la puntuación total y el número de tiradas.</p>
<p class="indent">Aquí tienes un ejemplo de ejecución:</p>
<p class="programs" translate="no">Rolled: 6<br translate="no"/>Rolled: 2<br translate="no"/>Rolled: 5<br translate="no"/>Rolled: 1<br translate="no"/>Rolled: 3<br translate="no"/>Rolled: 4<br translate="no"/>Score of 21 reached in 6 rolls</p>
<p class="indent">Si ejecutas el programa varias veces, te darás cuenta de que el número de tiradas que tarda en llegar a 20 varía.</p>
<h5 class="h5" id="ch05lev3sec11"><strong>¿Es posible alcanzar la puntuación objetivo?</strong></h5>
<p class="noindent">Nuestro siguiente programa es similar, pero nos dirá si es posible alcanzar una determinada puntuación objetivo con un número máximo de tiradas:</p>
<p class="programs" translate="no">   from sympy import FiniteSet<br translate="no"/>   import random<br translate="no"/><br translate="no"/>   def find_prob(target_score, max_rolls):<br translate="no"/><br translate="no"/>       die_sides = FiniteSet(1, 2, 3, 4, 5, 6)<br translate="no"/>       # Sample space<br translate="no"/><span class="ent">➊</span>     s = die_sides**max_rolls<br translate="no"/>       # Find the event set<br translate="no"/>       if max_rolls &gt; 1:<br translate="no"/>           success_rolls = []<br translate="no"/><span class="ent">➋</span>         for elem in s:<br translate="no"/>               if sum(elem) &gt;= target_score:<br translate="no"/>                   success_rolls.append(elem)<br translate="no"/>       else:<br translate="no"/>           if target_score &gt; 6:<br translate="no"/><span class="ent">➌</span>             success_rolls = []<br translate="no"/>           else:<br translate="no"/>               success_rolls = []<br translate="no"/>               for roll in die_sides:<br translate="no"/><span class="ent">➍</span>                 if roll &gt;= target_score:<br translate="no"/>                       success_rolls.append(roll)<br translate="no"/><span class="ent">➎</span>     e = FiniteSet(*success_rolls)<br translate="no"/>       # Calculate the probability of reaching target score<br translate="no"/>       return len(e)/len(s)<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/><br translate="no"/>       target_score = int(input('Enter the target score: '))<br translate="no"/>       max_rolls = int(input('Enter the maximum number of rolls allowed: '))<br translate="no"/><a id="page_137"></a><br translate="no"/>       p = find_prob(target_score, max_rolls)<br translate="no"/>       print('Probability: {0:.5f}'.format(p))</p>
<p class="indent">Cuando ejecutas este programa, te pide la puntuación objetivo y el número máximo de tiradas permitidas, y luego imprime la probabilidad de alcanzarla.</p>
<p class="indent">Aquí tienes dos ejemplos de ejecución:</p>
<p class="programs" translate="no">Enter the target score: 25<br translate="no"/>Enter the maximum number of rolls allowed: 4<br translate="no"/>Probability: 0.00000<br translate="no"/><br translate="no"/>Enter the target score: 25<br translate="no"/>Enter the maximum number of rolls allowed: 5<br translate="no"/>Probability: 0.03241</p>
<p class="indent">Vamos a entender el funcionamiento de la función <span class="literal" translate="no">find_prob()</span>, que realiza el cálculo de la probabilidad. El espacio muestral aquí es el producto cartesiano, <span class="literal" translate="no">die_sides</span><sup><span class="literal" translate="no">max_rolls</span></sup> <span class="ent">➊,</span> donde <span class="literal" translate="no">die_sides</span> es el conjunto {1, 2, 3, 4, 5, 6}, que representa los números de un dado de seis caras, y <span class="literal" translate="no">max_rolls</span> es el número máximo de tiradas de dado permitidas.</p>
<p class="indent">El conjunto de sucesos son todos los conjuntos del espacio muestral que nos ayudan a alcanzar esta puntuación objetivo. Aquí hay dos casos: cuando el número de turnos restantes es mayor que 1 y cuando estamos en el último turno. En el primer caso, en <span class="ent">➋,</span> iteramos sobre cada una de las tuplas del producto cartesiano y sumamos las que sumen o superen <span class="literal" translate="no">target_score</span> en la lista <span class="literal" translate="no">success_rolls</span>. El segundo caso es especial: nuestro espacio muestral es sólo el conjunto {1, 2, 3, 4, 5, 6}, y sólo nos queda un lanzamiento del dado. Si el valor de la puntuación objetivo es mayor que 6, no es posible alcanzarla, y establecemos <span class="literal" translate="no">success_rolls</span> como lista vacía en <span class="ent">➌.</span> Si, por el contrario, <span class="literal" translate="no">target_score</span> es menor o igual que 6, iteramos sobre cada tirada posible y sumamos las que sean mayores o iguales que el valor de <span class="literal" translate="no">target_score</span> en <span class="ent">➍.</span></p>
<p class="indent">En <span class="ent">➎,</span> calculamos el conjunto de sucesos, <span class="literal" translate="no">e</span>, a partir de la lista <span class="literal" translate="no">success_rolls</span> que construimos anteriormente y, a continuación, devolvemos la probabilidad de alcanzar la puntuación objetivo.</p>
<h4 class="h4" id="ch05lev2sec07"><strong><em>Números aleatorios no uniformes</em></strong></h4>
<p class="noindent">Hasta ahora, en nuestras discusiones sobre la probabilidad hemos supuesto que cada uno de los resultados del espacio muestral tiene la misma probabilidad. La función <span class="literal" translate="no">random.randint()</span>, por ejemplo, devuelve un número entero en el rango especificado suponiendo que cada número entero es <em>igualmente</em> probable. Nos referimos a dicha probabilidad como <em>probabilidad uniforme</em> y a los números aleatorios generados por la función <span class="literal" translate="no">randint()</span> como <em>números aleatorios uniformes</em>. Digamos, sin embargo, que queremos simular un lanzamiento de moneda sesgado: una moneda cargada para la que la probabilidad de que salga cara es el doble que la de que salga cruz. Entonces necesitaríamos una forma de generar números aleatorios <em>no uniformes</em>.</p>
<p class="indent">Antes de escribir el programa para hacerlo, repasaremos la idea que hay detrás.</p>
<p class="indent">Considera una recta numérica con una longitud de 1 y con dos intervalos divididos por igual, como se muestra en la <a href="ch05.html#ch5fig1">Figura 5-1</a>.</p>
<div class="image"><a id="page_138"></a><img alt="image" src="images/f05-01.jpg" translate="no"/></div>
<p class="figuret"><a id="ch5fig1"></a><em>Figura 5-1: Recta numérica con una longitud de 1 dividida en dos intervalos iguales correspondientes a la probabilidad de cara o cruz en el lanzamiento de una moneda</em></p>
<p class="indent">Nos referiremos a esta recta como la <em>recta</em> numérica de la probabilidad, en la que cada división representa un resultado igualmente posible; por ejemplo, cara o cruz al lanzar una moneda. Ahora, en la <a href="ch05.html#ch5fig2">Figura 5-2</a>, considera una versión diferente de esta recta numérica.</p>
<div class="image"><img alt="image" src="images/f05-02.jpg" translate="no"/></div>
<p class="figuret"><a id="ch5fig2"></a><em>Figura 5-2: Una recta numérica con una longitud de 1 dividida en dos intervalos desiguales correspondientes a la probabilidad de cara o cruz en el lanzamiento sesgado de una moneda</em></p>
<p class="indent">Aquí, la división correspondiente a cara es 2/3 de la longitud total y la correspondiente a cruz es 1/3. Esto representa la situación de una moneda que probablemente salga cara en 2/3 de los lanzamientos y cruz sólo en 1/3 de los lanzamientos. La siguiente función de Python simulará un lanzamiento de moneda de este tipo, considerando esta probabilidad desigual de que salga cara o cruz:</p>
<p class="programs" translate="no">   import random<br translate="no"/><br translate="no"/>   def toss():<br translate="no"/>       # 0 -&gt; Heads, 1-&gt; Tails<br translate="no"/><span class="ent">➊</span>     if random.random() &lt; 2/3:<br translate="no"/>           return 0<br translate="no"/>       else:<br translate="no"/>           return 1</p>
<p class="indent">Suponemos que la función devuelve 0 para indicar cara y 1 para indicar cruz, y luego generamos un número aleatorio entre 0 y 1 en <span class="ent">➊</span> utilizando la función <span class="literal" translate="no">random.random()</span>. Si el número generado es menor que 2/3 -la probabilidad de lanzar cara con nuestra moneda sesgada- el programa devuelve 0; en caso contrario, devuelve 1 (cruz).</p>
<p class="indent">Ahora veremos cómo podemos extrapolar la función anterior para simular un suceso no uniforme con múltiples resultados posibles. Consideremos un cajero automático ficticio que dispensa un billete de 5$, 10$, 20$ o 50$ cuando se pulsa su botón. Las distintas denominaciones tienen distintas probabilidades de ser dispensadas, como se muestra en la <a href="ch05.html#ch5fig3">Figura 5-3</a>.</p>
<div class="image"><img alt="image" src="images/f05-03.jpg" translate="no"/></div>
<p class="figuret"><a id="ch5fig3"></a><em>Figura 5-3: Recta numérica de longitud 1 dividida en cuatro intervalos de distinta longitud correspondientes a la probabilidad de dispensar billetes de distintas denominaciones</em></p>
<p class="indent"><a id="page_139"></a>Aquí, la probabilidad de que se dispense un billete de 5$ o de 10$ es de 1/6, y la probabilidad de que se dispense un billete de 20$ o de 50$ es de 1/3.</p>
<p class="indent">Creamos una lista para almacenar la suma móvil de las probabilidades, y luego generamos un número aleatorio entre 0 y 1. Empezamos por el extremo izquierdo de la lista que almacena la suma y devolvemos el primer índice de esta lista para el que la suma correspondiente sea menor o igual que el número aleatorio generado. La función <span class="literal" translate="no">get_index()</span> pone en práctica esta idea:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Simulate a fictional ATM that dispenses dollar bills<br translate="no"/>   of various denominations with varying probability<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   import random<br translate="no"/><br translate="no"/>   def get_index(probability):<br translate="no"/>       c_probability = 0<br translate="no"/><span class="ent">➊</span>     sum_probability = []<br translate="no"/>       for p in probability:<br translate="no"/>           c_probability += p<br translate="no"/>           sum_probability.append(c_probability)<br translate="no"/><span class="ent">➋</span>     r = random.random()<br translate="no"/>       for index, sp in enumerate(sum_probability):<br translate="no"/><span class="ent">➌</span>         if r &lt;= sp:<br translate="no"/>               return index<br translate="no"/><span class="ent">➍</span>     return len(probability)-1<br translate="no"/><br translate="no"/>   def dispense():<br translate="no"/><br translate="no"/>       dollar_bills = [5, 10, 20, 50]<br translate="no"/>       probability = [1/6, 1/6, 1/3, 2/3]<br translate="no"/>       bill_index = get_index(probability)<br translate="no"/>       return dollar_bills[bill_index]</p>
<p class="indent">Llamamos a la función <span class="literal" translate="no">get_index()</span> con una lista que contiene la probabilidad de que se produzca el suceso en la posición correspondiente. A continuación, en <span class="ent">➊,</span> construimos la lista <span class="literal" translate="no">sum_probability</span>, donde el <span class="literal" translate="no">i</span>º elemento es la suma de los primeros <span class="literal" translate="no">i</span> elementos de la lista <span class="literal" translate="no">probability</span>. Es decir, el primer elemento de <span class="literal" translate="no">sum_probability</span> es igual al primer elemento de <span class="literal" translate="no">probability</span>, el segundo elemento es igual a la suma de los dos primeros elementos de <span class="literal" translate="no">probability</span>, y así sucesivamente. En <span class="ent">➋,</span> se genera un número aleatorio entre 0 y 1 utilizando la etiqueta <span class="literal" translate="no">r</span>. A continuación, en <span class="ent">➌,</span> recorremos <span class="literal" translate="no">sum_probability</span> y devolvemos el índice del primer elemento que supere <span class="literal" translate="no">r</span>.</p>
<p class="indent">La última línea de la función, en <span class="ent">➍,</span> se ocupa de un caso especial que se ilustra mejor con un ejemplo. Considera una lista de tres sucesos con porcentajes de ocurrencia cada uno expresados como 0,33. En este caso, la lista <span class="literal" translate="no">sum_probability</span> quedaría como <span class="literal" translate="no">[0.33, 0.66, 0.99]</span>. Ahora, considera que el número aleatorio generado, <span class="literal" translate="no">r</span>, es <span class="literal" translate="no">0.99314</span>. Para este valor de <span class="literal" translate="no">r</span>, queremos que se elija el último elemento de la lista de sucesos. Puedes argumentar que esto no es exactamente correcto porque el último evento tiene una probabilidad superior al 33% de ser <a id="page_140"></a>seleccionado. Según la condición de <span class="ent">➌,</span> no hay ningún elemento en <span class="literal" translate="no">sum_probability</span> que sea mayor que <span class="literal" translate="no">r</span>; por lo tanto, la función no devolvería ningún índice. La sentencia <span class="ent">➍</span> se encarga de esto y devuelve el último índice.</p>
<p class="indent">Si llamas a la función <span class="literal" translate="no">dispense()</span> para simular un gran número de billetes de dólar desembolsados por el cajero automático, verás que la relación entre el número de veces que aparece cada billete obedece fielmente a la probabilidad especificada. Esta técnica nos resultará útil para crear <em>fractales</em> en el próximo capítulo.</p>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="ch05_2.html">anterior</a><a href="ch05.html">Subtema 3 de 5: (Ver todo)</a><a href="ch05_4.html">siguiente</a><br/></p>
<br/><a href="ch05_3.docx" target="_blank"></a></footer>
</body>
</html>
