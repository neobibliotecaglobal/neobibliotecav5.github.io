<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
<meta charset="utf-8"/>
<title>Apéndice B: Visión general de los temas de Python</title>
<link href="style.css" media="all" rel="stylesheet" type="text/css"/>
<link href="core.css" media="all" rel="stylesheet" type="text/css"/>
<style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<div id="sbo-rt-content"><h2 class="h2" id="app02"><a id="page_221"></a><strong><span class="big">B</span></strong><br translate="no"/> Visión general de los temas de Python</h2>
<div class="image1"><img alt="image" src="images/common-01.jpg" translate="no"/></div>
<p class="noindent">El objetivo de este apéndice es doble: proporcionar un rápido repaso de algunos temas de Python que no se introdujeron a fondo en los capítulos e introducir temas que te ayudarán a escribir mejores programas en Python.</p>
<h3 class="h3" id="app02lev1sec01"><strong>if __name__ == '__main__'</strong></h3>
<p class="noindent">A lo largo del libro, hemos utilizado el siguiente bloque de código, donde <span class="literal" translate="no">func()</span> es una función que hemos definido en el programa:</p>
<p class="programs" translate="no">if __name__ == '__main__':<br translate="no"/>    # Do something<br translate="no"/>    func()</p>
<p class="indent">Este bloque de código garantiza que las sentencias dentro del bloque sólo se ejecuten cuando el programa se ejecute solo.</p>
<p class="indent"><a id="page_222"></a>Cuando se ejecuta un programa, la variable especial <span class="literal" translate="no">__name__</span> se establece automáticamente en <span class="literal" translate="no">__main__</span>, por lo que la condición <span class="literal" translate="no">if</span> se evalúa como <span class="literal" translate="no">True</span> y se llama a la función <span class="literal" translate="no">func()</span>. Sin embargo, <span class="literal" translate="no">__name__</span> se establece de forma diferente cuando importas el programa en otro programa (ver "<a href="app02.html#app02lev1sec07">Reutilizar código</a>" en <a href="app02.html#page_235">la página 235</a>).</p>
<p class="indent">He aquí una demostración rápida. Considera el siguiente programa, que llamaremos <em>factorial.py</em>:</p>
<p class="programs" translate="no">   # Find the factorial of a number<br translate="no"/>   def fact(n):<br translate="no"/>       p = 1<br translate="no"/>       for i in range(1, n+1):<br translate="no"/>           p = p*i<br translate="no"/>       return p<br translate="no"/><br translate="no"/><span class="ent">➊</span> print(__name__)<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/>       n = int(input('Enter an integer to find the factorial of: '))<br translate="no"/>       f = fact(n)<br translate="no"/>       print('Factorial of {0}: {1}'.format(n, f))</p>
<p class="indent">El programa define una función, <span class="literal" translate="no">fact()</span>, que calcula el factorial del número entero que se le pasa. Cuando lo ejecutas, imprime <span class="literal" translate="no">__main__</span>, que corresponde a la sentencia <span class="literal" translate="no">print</span> en <span class="ent">➊,</span> porque <span class="literal" translate="no">__name__</span> se establece automáticamente en <span class="literal" translate="no">__main__</span>. A continuación, pide que se introduzca un número entero, calcula el factorial y lo imprime:</p>
<p class="programs" translate="no">__main__<br translate="no"/>Enter an integer to find the factorial of: 5<br translate="no"/>Factorial of 5: 120</p>
<p class="indent">Ahora, supongamos que necesitas calcular el factorial en otro programa. En lugar de volver a escribir la función, decides reutilizar esta función importándola:</p>
<p class="programs" translate="no">from factorial import fact<br translate="no"/>if __name__ == '__main__':<br translate="no"/>    print('Factorial of 5: {0}'.format(fact(5)))</p>
<p class="indent">Ten en cuenta que ambos programas deben estar en el mismo directorio. Cuando ejecutes este programa, obtendrás la siguiente salida:</p>
<p class="programs" translate="no">factorial<br translate="no"/>Factorial of 5: 120</p>
<p class="indent">Cuando tu programa es importado por otro programa, el valor de la variable <span class="literal" translate="no">__main__</span> se establece en el nombre de archivo de ese programa, sin la extensión. En este caso, el valor de <span class="literal" translate="no">__name__</span> es <span class="literal" translate="no">factorial</span> en lugar de <span class="literal" translate="no">__main__</span>. Como la condición <span class="literal" translate="no">__name__ == '__main__'</span> ahora se evalúa como <span class="literal" translate="no">False</span>, el programa ya no solicita la entrada del usuario. ¡Elimina la condición para ver por ti mismo lo que ocurre!</p>
<p class="indent"><a id="page_223"></a>En resumen, es una buena práctica utilizar <span class="literal" translate="no">if __name__ == '__main__'</span> en tus programas para que las sentencias que quieres que se ejecuten cuando tu programa se ejecute como independiente <em>tampoco</em> se ejecuten cuando tu programa se importe a otro programa.</p>
<h3 class="h3" id="app02lev1sec02"><strong>Comprensión de listas</strong></h3>
<p class="noindent">Supongamos que tenemos una lista de enteros y queremos crear una nueva lista que contenga los cuadrados de los elementos de la lista original. Esta es una forma de hacerlo que ya te resultará familiar:</p>
<p class="programs" translate="no">   &gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3, 4]</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">x_square = []</span><br translate="no"/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">for n in x:</span><br translate="no"/><span class="ent">➋</span> <span class="codestrong">x_square.append(n**2)</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">x_square</span><br translate="no"/>   [1, 4, 9, 16]</p>
<p class="indent">Aquí utilizamos un patrón de código que hemos utilizado en varios programas a lo largo del libro. Creamos una lista vacía, <span class="literal" translate="no">x_square</span>, y luego la vamos añadiendo sucesivamente a medida que calculamos el cuadrado. Podemos hacerlo de forma más eficiente utilizando <em>comprensiones de lista</em>:</p>
<p class="programs" translate="no"><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong">x_square = [n**2 for n in x]</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">x_square</span><br translate="no"/>   [1, 4, 9, 16]</p>
<p class="indent">La sentencia <span class="ent">➌</span> se denomina comprensión de <em>lista</em> en Python. Consiste en una expresión -aquí, <span class="literal" translate="no">n**2</span>- seguida de un bucle <span class="literal" translate="no">for</span>, <span class="literal" translate="no">for n in x</span>. Observa que básicamente nos permite combinar las dos expresiones <span class="ent">➊</span> y <span class="ent">➋</span> en una sola para crear una nueva lista en una sola expresión.</p>
<p class="indent">Como otro ejemplo, considera uno de los programas que escribimos en "<a href="ch02.html#ch02lev3sec05">Dibujar la trayectoria</a>" en <a href="ch02.html#page_51">la página 51</a> para dibujar la trayectoria de un cuerpo en movimiento de proyectil. En estos programas, tenemos el siguiente bloque de código para calcular las <em>coordenadas</em> <em>x</em> e <em>y</em> del cuerpo en cada instante de tiempo:</p>
<p class="programs" translate="no"># Find time intervals<br translate="no"/>intervals = frange(0, t_flight, 0.001)<br translate="no"/># List of x and y coordinates<br translate="no"/>x = []<br translate="no"/>y = []<br translate="no"/>for t in intervals:<br translate="no"/>    x.append(u*math.cos(theta)*t)<br translate="no"/>    y.append(u*math.sin(theta)*t - 0.5*g*t*t)</p>
<p class="indent">Utilizando la comprensión de listas, puedes reescribir el bloque de código como sigue:</p>
<p class="programs" translate="no"># Find time intervals<br translate="no"/>intervals = frange(0, t_flight, 0.001)<br translate="no"/># List of x and y coordinates<br translate="no"/><a id="page_224"></a><br translate="no"/>x = [u*math.cos(theta)*t for t in intervals]<br translate="no"/>y = [u*math.sin(theta)*t - 0.5*g*t*t for t in intervals]</p>
<p class="indent">Ahora el código es más compacto, ya que no tenías que crear las listas vacías, escribir un bucle <span class="literal" translate="no">for</span> y añadir a las listas. La comprensión de listas te permite hacer esto en una sola sentencia.</p>
<p class="indent">También puedes añadir condicionales a una comprensión de lista para elegir selectivamente qué elementos de la lista se evalúan en la expresión. Considera, una vez más, el primer ejemplo:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3, 4]</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">x_square = [n**2 for n in x if n%2 == 0]</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">x_square</span><br translate="no"/>[4, 16]</p>
<p class="indent">En esta comprensión de lista, utilizamos la condición <span class="literal" translate="no">if</span> para decirle explícitamente a Python que evalúe la expresión <span class="literal" translate="no">n**2</span> sólo en los elementos pares de la lista <span class="literal" translate="no">x</span>.</p>
<h3 class="h3" id="app02lev1sec03"><strong>Estructura de datos del diccionario</strong></h3>
<p class="noindent">La primera vez que utilizamos un diccionario Python fue en el <a href="ch04.html#ch04">Capítulo 4</a>, cuando implementamos el método <span class="literal" translate="no">subs()</span> en SymPy. Exploremos los diccionarios de Python con más detalle. Considera un diccionario sencillo:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span></p>
<p class="indent">Este código crea un diccionario con dos claves -<span class="literal" translate="no">'key1'</span> y <span class="literal" translate="no">'key2'</span>- con los valores <span class="literal" translate="no">5</span> y <span class="literal" translate="no">20</span>, respectivamente. Sólo las cadenas, los números y las tuplas pueden ser claves en un diccionario Python. Estos tipos de datos se denominan tipos de datos <em>inmutables</em> -una vez creados, no pueden modificarse-, por lo que una lista no puede ser una clave porque podemos añadir y eliminar elementos de una lista.</p>
<p class="indent">Ya sabemos que para recuperar el valor correspondiente a <span class="literal" translate="no">'key1'</span> en el diccionario, tenemos que especificarlo como <span class="literal" translate="no">d['key1']</span>. Éste es uno de los casos de uso más habituales de un diccionario. Un caso de uso relacionado es comprobar si el diccionario contiene una determinada clave, <span class="literal" translate="no">'x'</span>. Podemos comprobarlo de la siguiente manera:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">'x' in d</span><br translate="no"/>False</p>
<p class="indent">Una vez creado un diccionario, podemos añadirle un nuevo par clave-valor, de forma similar a como podemos añadir elementos a una lista. He aquí un ejemplo:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">if 'x' in d:</span><br translate="no"/> <span class="codestrong">print(d['x'])</span><br translate="no"/><span class="codestrong">else:</span><br translate="no"/> <span class="codestrong">d['x'] = 1</span><br translate="no"/><a id="page_225"></a><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">d</span><br translate="no"/>{'key1': 5, 'x': 1, 'key2': 20}</p>
<p class="indent">Este fragmento de código comprueba si la clave <span class="literal" translate="no">'x'</span> ya existe en el diccionario, <span class="literal" translate="no">d</span>. Si es así, imprime el valor que le corresponde; si no, añade la clave al diccionario con <span class="literal" translate="no">1</span> como valor correspondiente. De forma similar al comportamiento de Python con los conjuntos, Python no puede garantizar un orden concreto de los pares clave-valor en un diccionario. Los pares clave-valor pueden estar en cualquier orden, independientemente del orden de inserción.</p>
<p class="indent">Además de especificar la clave como índice del diccionario, también podemos utilizar el método <span class="literal" translate="no">get()</span> para recuperar el valor correspondiente a la clave:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">d.get('x')</span><br translate="no"/>1</p>
<p class="indent">Si especificas una clave inexistente al método <span class="literal" translate="no">get()</span>, se devuelve <span class="literal" translate="no">None</span>. En cambio, si lo haces utilizando el estilo índice de recuperación, obtendrás un error.</p>
<p class="indent">El método <span class="literal" translate="no">get()</span> también te permite establecer un valor por defecto para claves inexistentes:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">d.get('y', 0)</span><br translate="no"/>0</p>
<p class="indent">No hay ninguna clave <span class="literal" translate="no">'y'</span> en el diccionario <span class="literal" translate="no">d</span>, por lo que se devuelve <span class="literal" translate="no">0</span>. Sin embargo, si hay una clave, se devuelve el valor en su lugar:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">d['y'] = 1</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">d.get('y', 0)</span><br translate="no"/>1</p>
<p class="indent">Los métodos <span class="literal" translate="no">keys()</span> y <span class="literal" translate="no">values()</span> devuelven cada uno una estructura de datos en forma de lista con todas las claves y valores, respectivamente, de un diccionario:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">d.keys()</span><br translate="no"/>dict_keys(['key1', 'x', 'key2', 'y'])<br translate="no"/>&gt;&gt;&gt; <span class="codestrong">d.values()</span><br translate="no"/>dict_values([5, 1, 20, 1])</p>
<p class="indent">Para iterar sobre los pares clave y valor de un diccionario, utiliza el método <span class="literal" translate="no">items()</span>:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">d.items()</span><br translate="no"/>dict_items([('key1', 5), ('x', 1), ('key2', 20), ('y', 1)])</p>
<p class="indent">Este método devuelve una <em>vista</em> de tuplas, y cada tupla es un par clave-valor. Podemos utilizar el siguiente fragmento de código para imprimirlas bien:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">for k, v in d.items():</span><br translate="no"/> <span class="codestrong">print(k, v)</span><br translate="no"/><a id="page_226"></a><br translate="no"/>key1 5<br translate="no"/>x 1<br translate="no"/>key2 20<br translate="no"/>y 1</p>
<p class="indent">Las vistas son más eficientes en memoria que las listas, y no te permiten añadir o eliminar elementos.</p>
<h3 class="h3" id="app02lev1sec04"><strong>Múltiples valores de retorno</strong></h3>
<p class="noindent">En los programas que hemos escrito hasta ahora, la mayoría de las funciones devuelven un único valor, pero a veces las funciones devuelven varios valores. Vimos un ejemplo de una función de este tipo en "<a href="ch03.html#ch03lev1sec04">Medir la dispersión</a>" en <a href="ch03.html#page_71">la página 71</a>, donde en el programa para hallar el rango, devolvimos tres números de la función <span class="literal" translate="no">find_range()</span>. Aquí tienes otro ejemplo del enfoque que adoptamos allí:</p>
<p class="programs" translate="no">import math<br translate="no"/>def components(u, theta):<br translate="no"/>    x = u*math.cos(theta)<br translate="no"/>    y = u*math.sin(theta)<br translate="no"/>    return x, y</p>
<p class="indent">La función <span class="literal" translate="no">components()</span> acepta como parámetros una velocidad, <span class="literal" translate="no">u</span>, y un ángulo, <span class="literal" translate="no">theta</span>, en radianes, y calcula las componentes <span class="literal" translate="no">x</span> y <span class="literal" translate="no">y</span> y las devuelve. Para devolver los componentes calculados, simplemente enumeramos las etiquetas Python correspondientes en la sentencia return separadas por una coma. Esto crea y devuelve una tupla formada por los elementos <span class="literal" translate="no">x</span> y <span class="literal" translate="no">y</span>. En el código de llamada, recibimos los valores múltiples:</p>
<p class="programs" translate="no">if __name__ == '__main__':<br translate="no"/>    theta = math.radians(45)<br translate="no"/>    x, y = components(theta)</p>
<p class="indent">Como la función <span class="literal" translate="no">components()</span> devuelve una tupla, podemos recuperar los valores devueltos utilizando índices de tupla:</p>
<p class="programs" translate="no">c = components(theta)<br translate="no"/>x = c[0]<br translate="no"/>y = c[1]</p>
<p class="indent">Esto tiene ventajas porque no tenemos que conocer todos los valores diferentes que se devuelven. Por ejemplo, no tienes que escribir <span class="literal" translate="no">x,y,z = myfunc1()</span> cuando la función devuelva tres valores o <span class="literal" translate="no">a,x,y,z = myfunc1()</span> cuando la función devuelva cuatro valores, y así sucesivamente.</p>
<p class="indent">En cualquiera de los casos anteriores, el código que llama a la función <span class="literal" translate="no">components()</span> debe saber cuál de los valores devueltos corresponde a cada componente de la velocidad, ya que no hay forma de saberlo a partir de los propios valores.</p>
<p class="indent"><a id="page_227"></a>Un enfoque fácil de utilizar es devolver en su lugar un objeto diccionario, como vimos en el caso de la función <span class="literal" translate="no">solve()</span> de SymPy cuando se utiliza con el argumento de la palabra clave <span class="literal" translate="no">dict=True</span>. He aquí cómo podemos reescribir la función de componentes anterior para que devuelva un diccionario:</p>
<p class="programs" translate="no">import math<br translate="no"/><br translate="no"/>def components(theta):<br translate="no"/>    x = math.cos(theta)<br translate="no"/>    y = math.sin(theta)<br translate="no"/><br translate="no"/>    return {'x': x, 'y': y}</p>
<p class="indent">Aquí, devolvemos un diccionario con las claves <span class="literal" translate="no">'x'</span> y <span class="literal" translate="no">'y'</span> que hacen referencia a los componentes <span class="literal" translate="no">x</span> y <span class="literal" translate="no">y</span> y a sus correspondientes valores numéricos. Con esta nueva definición de la función, no tenemos que preocuparnos del orden de los valores devueltos. Sólo utilizamos la clave <span class="literal" translate="no">'x'</span> para recuperar el componente <span class="literal" translate="no">x</span> y la clave <span class="literal" translate="no">'y'</span> para recuperar el componente <span class="literal" translate="no">y</span>:</p>
<p class="programs" translate="no">if __name__ == '__main__':<br translate="no"/>    theta = math.radians(45)<br translate="no"/>    c = components(theta)<br translate="no"/>    y = c['y']<br translate="no"/>    x = c['x']<br translate="no"/>    print(x, y)</p>
<p class="indent">Este enfoque elimina la necesidad de utilizar índices para referirnos a un valor devuelto concreto. El código siguiente reescribe el programa para encontrar el rango (ver "<a href="ch03.html#ch03lev1sec04">Medir la dispersión</a>" en <a href="ch03.html#page_71">la página 71</a>) de forma que los resultados se devuelvan como un diccionario en lugar de una tupla:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Find the range using a dictionary to return values<br translate="no"/>   '''<br translate="no"/>   def find_range(numbers):<br translate="no"/>       lowest = min(numbers)<br translate="no"/>       highest = max(numbers)<br translate="no"/>       # Find the range<br translate="no"/>       r = highest-lowest<br translate="no"/>       return {'lowest':lowest, 'highest':highest, 'range':r}<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/>       donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]<br translate="no"/>       result = find_range(donations)<br translate="no"/><span class="ent">➊</span>     print('Lowest: {0} Highest: {1} Range: {2}'.<br translate="no"/>              format(result['lowest'], result['highest'], result['range']))</p>
<p class="indent">La función <span class="literal" translate="no">find_range()</span> devuelve ahora un diccionario con las claves <span class="literal" translate="no">lowest</span>, <span class="literal" translate="no">highest</span>, y <span class="literal" translate="no">range</span> y con el número más bajo, el número más alto y el rango como valores correspondientes. En <span class="ent">➊,</span> simplemente utilizamos la clave correspondiente para recuperar el valor correspondiente.</p>
<p class="indent"><a id="page_228"></a>Si sólo nos interesara el rango de un grupo de números y no nos importaran los números más bajo y más alto, sólo utilizaríamos <span class="literal" translate="no">result['range']</span> y no nos preocuparíamos de qué otros valores se devuelven.</p>
<h3 class="h3" id="app02lev1sec05"><strong>Manejo de excepciones</strong></h3>
<p class="noindent">En el <a href="ch01.html#ch01">Capítulo 1</a>, aprendimos que intentar convertir una cadena como <span class="literal" translate="no">'1.1'</span> en un número entero utilizando la función <span class="literal" translate="no">int()</span> produce una excepción <span class="literal" translate="no">ValueError</span>. Pero con un bloque <span class="literal" translate="no">try...except</span>, podemos imprimir un mensaje de error fácil de usar:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">try:</span><br translate="no"/> <span class="codestrong">int('1.1')</span><br translate="no"/><span class="codestrong">except ValueError:</span><br translate="no"/> <span class="codestrong">print('Failed to convert 1.1 to an integer')</span><br translate="no"/><br translate="no"/>Failed to convert 1.1 to an integer</p>
<p class="indent">Cuando cualquier sentencia del bloque <span class="literal" translate="no">try</span> lanza una excepción, el tipo de excepción lanzada se compara con el especificado por la sentencia <span class="literal" translate="no">except</span>. Si hay coincidencia, el programa se reanuda en el bloque <span class="literal" translate="no">except</span>. Si la excepción no coincide, la ejecución del programa se detiene y muestra la excepción. He aquí un ejemplo:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">try:</span><br translate="no"/> <span class="codestrong">print(1/0)</span><br translate="no"/><span class="codestrong">except ValueError:</span><br translate="no"/> <span class="codestrong">print('Division unsuccessful')</span><br translate="no"/><br translate="no"/>Traceback (most recent call last):<br translate="no"/>  File "&lt;pyshell#66&gt;", line 2, in &lt;module&gt;<br translate="no"/>    print(1/0)<br translate="no"/>ZeroDivisionError: division by zero</p>
<p class="indent">Este bloque de código intenta una división por 0, lo que provoca una excepción <span class="literal" translate="no">ZeroDivisionError</span>. Aunque la división se realiza en un bloque <span class="literal" translate="no">try...except</span>, el tipo de excepción se especifica incorrectamente, y la excepción no se maneja correctamente. La forma correcta de gestionar esta excepción es especificar <span class="literal" translate="no">ZeroDivisionError</span> como tipo de excepción.</p>
<h4 class="h4" id="app02lev2sec01"><strong><em>Especificar varios tipos de excepción</em></strong></h4>
<p class="noindent">También puedes especificar varios tipos de excepción. Considera la función <span class="literal" translate="no">reciprocal()</span>, que devuelve el recíproco del número que se le pasa:</p>
<p class="programs" translate="no">def reciprocal(n):<br translate="no"/>    try:<br translate="no"/>        print(1/n)<br translate="no"/>    except (ZeroDivisionError, TypeError):<br translate="no"/>        print('You entered an invalid number')</p>
<p class="indent"><a id="page_229"></a>Definimos la función <span class="literal" translate="no">reciprocal()</span>, que imprime el recíproco de la entrada del usuario. Sabemos que si se llama a la función con 0, provocará una excepción <span class="literal" translate="no">ZeroDivisionError</span>. En cambio, si pasas una cadena, provocará una excepción <span class="literal" translate="no">TypeError</span>. La función considera ambos casos como entrada no válida y especifica tanto <span class="literal" translate="no">ZeroDivisionError</span> como <span class="literal" translate="no">TypeError</span> en la sentencia <span class="literal" translate="no">except</span> como una tupla.</p>
<p class="indent">Intentemos llamar a la función con una entrada válida, es decir, un número distinto de cero:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">reciprocal(5)</span><br translate="no"/>0.2</p>
<p class="indent">A continuación, llamamos a la función con 0 como argumento:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">reciprocal(0)</span><br translate="no"/>Enter an integer: <span class="codestrong">0</span><br translate="no"/>You entered an invalid number</p>
<p class="indent">El argumento <span class="literal" translate="no">0</span> provoca la excepción <span class="literal" translate="no">ZeroDivisionError</span>, que está en la tupla de tipos de excepción especificada en la sentencia <span class="literal" translate="no">except</span>, por lo que el código imprime un mensaje de error.</p>
<p class="indent">Ahora, introduzcamos una cadena:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">reciprocal('1')</span></p>
<p class="indent">En este caso, hemos introducido un número no válido, lo que provoca la excepción <span class="literal" translate="no">TypeError</span>. Esta excepción también está en la tupla de excepciones especificadas, por lo que el código imprime un mensaje de error. Si quieres dar un mensaje de error más específico, podemos especificar varias sentencias <span class="literal" translate="no">except</span> como se indica a continuación:</p>
<p class="programs" translate="no"><span class="codestrong">def reciprocal(n):</span><br translate="no"/> <span class="codestrong">try:</span><br translate="no"/> <span class="codestrong">print(1/n)</span><br translate="no"/> <span class="codestrong">except TypeError:</span><br translate="no"/> <span class="codestrong">print('You must specify a number')</span><br translate="no"/> <span class="codestrong">except ZeroDivisionError:</span><br translate="no"/> <span class="codestrong">print('Division by 0 is invalid')</span><br translate="no"/><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">reciprocal(0)</span><br translate="no"/>Division by 0 is invalid<br translate="no"/>&gt;&gt;&gt; <span class="codestrong">reciprocal('1')</span><br translate="no"/>You must specify a number</p>
<p class="indent">Además de <span class="literal" translate="no">TypeError</span>, <span class="literal" translate="no">ValueError</span>, y <span class="literal" translate="no">ZeroDivisionError</span>, existen otros tipos de excepción incorporados. La documentación de Python en <em><a href="https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions">https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions</a></em> enumera las excepciones incorporadas para Python 3.4.</p>
<h4 class="h4" id="app02lev2sec02"><a id="page_230"></a><strong><em>El bloque else</em></strong></h4>
<p class="noindent">El bloque <span class="literal" translate="no">else</span> se utiliza para especificar qué sentencias ejecutar cuando no hay ninguna excepción. Considera un ejemplo del programa que escribimos para dibujar la trayectoria de un proyectil (ver "<a href="ch02.html#ch02lev3sec05">Dibujar la trayectoria</a>" en <a href="ch02.html#page_51">la página 51</a>):</p>
<p class="programs" translate="no">   if __name__ == '__main__':<br translate="no"/>       try:<br translate="no"/>           u = float(input('Enter the initial velocity (m/s): '))<br translate="no"/>           theta = float(input('Enter the angle of projection (degrees): '))<br translate="no"/>       except ValueError:<br translate="no"/>           print('You entered an invalid input')<br translate="no"/><span class="ent">➊</span>     else:<br translate="no"/>           draw_trajectory(u, theta)<br translate="no"/>           plt.show()</p>
<p class="indentb">Si la entrada para <span class="literal" translate="no">u</span> o <span class="literal" translate="no">theta</span> no se pudiera convertir a un número de coma flotante, no tendría sentido que el programa llamara a las funciones <span class="literal" translate="no">draw_trajectory()</span> y <span class="literal" translate="no">plt.show()</span>. En su lugar, especificamos estas dos sentencias en el bloque <span class="literal" translate="no">else</span> en <span class="ent">➊.</span> Utilizar <span class="literal" translate="no">try...except...else</span> te permitirá gestionar distintos tipos de errores durante el tiempo de ejecución y tomar las medidas adecuadas cuando haya un error o cuando no lo haya:</p>
<p class="order">1. Si hay una excepción y existe una sentencia <span class="literal" translate="no">except</span> correspondiente al tipo de excepción planteada, la ejecución se transfiere al bloque <span class="literal" translate="no">except</span> correspondiente.</p>
<p class="order">2. Si no hay excepción, la ejecución se transfiere al bloque <span class="literal" translate="no">else</span>.</p>
<h3 class="h3" id="app02lev1sec06"><strong>Leer archivos en Python</strong></h3>
<p class="noindent">Abrir un archivo es el primer paso para leer datos de él. Empecemos con un ejemplo rápido. Considera un archivo que consiste en una colección de números con un número por línea:</p>
<p class="programs" translate="no">100<br translate="no"/>60<br translate="no"/>70<br translate="no"/>900<br translate="no"/>100<br translate="no"/>200<br translate="no"/>500<br translate="no"/>500<br translate="no"/>503<br translate="no"/>600<br translate="no"/>1000<br translate="no"/>1200</p>
<p class="indent"><a id="page_231"></a>Queremos escribir una función que lea el archivo y devuelva una lista de esos números:</p>
<p class="programs" translate="no">   def read_data(path):<br translate="no"/>       numbers = []<br translate="no"/><span class="ent">➊</span>     f = open(path)<br translate="no"/><span class="ent">➋</span>     for line in f:<br translate="no"/>           numbers.append(float(line))<br translate="no"/>       f.close()<br translate="no"/>       return numbers</p>
<p class="indent">En primer lugar, definimos la función <span class="literal" translate="no">read_data()</span> y creamos una lista vacía para almacenar todos los números. En <span class="ent">➊,</span> utilizamos la función <span class="literal" translate="no">open()</span> para abrir el archivo cuya ubicación se ha especificado mediante el argumento ruta. Un ejemplo de la ruta sería <em>/home/nombredeusuario/mydata</em>.txt en Linux, <em>C:\mydata.txt</em> en Microsoft Windows, o <em>/Usuarios/nombredeusuario/mydata.txt</em> en OS X. La función <span class="literal" translate="no">open()</span> devuelve un objeto archivo, al que utilizamos la etiqueta <span class="literal" translate="no">f</span> para referirnos. Podemos repasar cada línea del archivo utilizando un bucle <span class="literal" translate="no">for</span> en <span class="ent">➋.</span> Como cada línea se devuelve como una cadena, la convertimos en un número y lo añadimos a la lista <span class="literal" translate="no">numbers</span>. El bucle deja de ejecutarse una vez que se han leído todas las líneas, y cerramos el archivo utilizando el método <span class="literal" translate="no">close()</span>. Por último, devolvemos la lista <span class="literal" translate="no">numbers</span>.</p>
<p class="indent">Esto es similar a cómo leímos los números de un archivo en <a href="ch03.html#ch03">el Capítulo 3</a>, aunque no tuvimos que cerrar el archivo explícitamente porque allí utilizamos un enfoque diferente. Utilizando el método del Capítulo <a href="ch03.html#ch03">3</a>, reescribiríamos la función anterior de la siguiente manera:</p>
<p class="programs" translate="no">   def read_data(path):<br translate="no"/>       numbers = []<br translate="no"/><span class="ent">➊</span>     with open(path) as f:<br translate="no"/>           for line in f:<br translate="no"/>               numbers.append(float(line))<br translate="no"/><span class="ent">➋</span>     return numbers</p>
<p class="indent">La declaración clave aquí está en <span class="ent">➊.</span> Es similar a escribir <span class="literal" translate="no">f = open(path)</span>, pero sólo parcialmente. Además de abrir el archivo y asignar el objeto archivo devuelto por <span class="literal" translate="no">open()</span> a <span class="literal" translate="no">f</span>, también establece un nuevo <em>contexto</em> con todas las sentencias de ese bloque -en este caso, todas las sentencias anteriores a la sentencia <span class="literal" translate="no">return</span>. Cuando se han ejecutado todas las sentencias del cuerpo, el archivo se cierra automáticamente. Es decir, cuando la ejecución llega a la sentencia <span class="ent">➋,</span> el archivo se cierra sin necesidad de llamar explícitamente al método <span class="literal" translate="no">close()</span>. Este método también significa que si se produce alguna excepción mientras se trabaja con el archivo, éste se cerrará antes de que salga el programa. Este es el método preferido para trabajar con archivos.</p>
<h4 class="h4" id="app02lev2sec03"><a id="page_232"></a><strong><em>Leer todas las líneas a la vez</em></strong></h4>
<p class="noindent">En lugar de leer las líneas una a una para construir una lista, podemos utilizar el método <span class="literal" translate="no">readlines()</span> para leer todas las líneas a la vez en una lista. El resultado es una función más compacta:</p>
<p class="programs" translate="no">   def read_data(path):<br translate="no"/>       with open(path) as f:<br translate="no"/><span class="ent">➊</span>         lines = f.readlines()<br translate="no"/>       numbers = [float(n) for n in lines]<br translate="no"/>       return numbers</p>
<p class="indent">Leemos todas las líneas del archivo en una lista utilizando el método <span class="literal" translate="no">readlines()</span> en <span class="ent">➊.</span> A continuación, convertimos cada uno de los elementos de la lista en un número de coma flotante utilizando la función <span class="literal" translate="no">float()</span> y la comprensión de listas. Por último, devolvemos la lista <span class="literal" translate="no">numbers</span>.</p>
<h4 class="h4" id="app02lev2sec04"><strong><em>Especificar el nombre del archivo como entrada</em></strong></h4>
<p class="noindent">La función <span class="literal" translate="no">read_data()</span> toma como argumento la ruta del archivo. Si tu programa te permite especificar el nombre del archivo como entrada, esta función debería funcionar para cualquier archivo, siempre que éste contenga datos que esperemos leer. Aquí tienes un ejemplo:</p>
<p class="programs" translate="no">if __name__=='__main__':<br translate="no"/>    data_file = input('Enter the path of the file: ')<br translate="no"/>    data = read_data(data_file)<br translate="no"/>    print(data)</p>
<p class="indent">Una vez que hayas añadido este código al final de la función <span class="literal" translate="no">read_data()</span> y la ejecutes, te pedirá que introduzcas la ruta al archivo. A continuación, imprimirá los números que lea del archivo:</p>
<p class="programscustom" translate="no">Enter the path of the file <span class="codestrong">/home/amit/work/mydata.txt</span><br translate="no"/>[100.0,60.0,70.0,900.0,100.0,200.0,500.0,500.0,503.0,600.0,1000.0,1200.0]</p>
<h4 class="h4" id="app02lev2sec05"><strong><em>Tratamiento de errores en la lectura de archivos</em></strong></h4>
<p class="noindent">Hay un par de cosas que pueden ir mal al leer archivos: (1) el archivo no se puede leer, o (2) los datos del archivo no están en el formato esperado. Aquí tienes un ejemplo de lo que ocurre cuando no se puede leer un archivo:</p>
<p class="programs" translate="no">Enter the path of the file: <span class="codestrong">/home/amit/work/mydata2.txt</span><br translate="no"/>Traceback (most recent call last):<br translate="no"/>  File "read_file.py", line 11, in &lt;module&gt;<br translate="no"/>    data = read_data(data_file)<br translate="no"/>  File "read_file.py", line 4, in read_data<br translate="no"/>    with open(path) as f:<br translate="no"/>FileNotFoundError: [Errno 2] No such file or directory: '/home/amit/work/<br translate="no"/>mydata2.txt'</p>
<p class="indent"><a id="page_233"></a>Como he introducido una ruta de archivo que no existe, se lanza la excepción <span class="literal" translate="no">FileNotFoundError</span> cuando intentamos abrir el archivo. Podemos hacer que el programa muestre un mensaje de error fácil de usar modificando nuestra función <span class="literal" translate="no">read_data()</span> de la siguiente manera:</p>
<p class="programs" translate="no">def read_data(path):<br translate="no"/>    numbers = []<br translate="no"/>    try:<br translate="no"/>        with open(path) as f:<br translate="no"/>            for line in f:<br translate="no"/>                numbers.append(float(line))<br translate="no"/>    except FileNotFoundError:<br translate="no"/>        print('File not found')<br translate="no"/>    return numbers</p>
<p class="indent">Ahora, cuando especifiques una ruta de archivo inexistente, recibirás en su lugar un mensaje de error:</p>
<p class="programs" translate="no">Enter the path of the file: <span class="codestrong">/home/amit/work/mydata2.txt</span><br translate="no"/>File not found</p>
<p class="indent">La segunda fuente de errores puede ser que los datos del archivo no sean los que tu programa espera leer. Por ejemplo, considera un archivo que tenga lo siguiente:</p>
<p class="programs" translate="no">10<br translate="no"/>20<br translate="no"/>3o<br translate="no"/>1/5<br translate="no"/>5.6</p>
<p class="indent">La tercera línea de este archivo no es convertible a un número de coma flotante porque contiene la letra <span class="literal" translate="no">o</span> en lugar del número <span class="literal" translate="no">0</span>, y la cuarta línea consiste en <span class="literal" translate="no">1/5</span>, una fracción en forma de cadena, que <span class="literal" translate="no">float()</span> no puede manejar.</p>
<p class="indent">Si proporcionas este archivo de datos al programa anterior, producirá el siguiente error:</p>
<p class="programs" translate="no">Enter the path of the file: <span class="codestrong">bad_data.txt</span><br translate="no"/>Traceback (most recent call last):<br translate="no"/>  File "read_file.py", line 13, in &lt;module&gt;<br translate="no"/>    data = read_data(data_file)<br translate="no"/>  File "read_file.py", line 6, in read_data<br translate="no"/>    numbers.append(float(line))<br translate="no"/>ValueError: could not convert string to float: '3o\n'</p>
<p class="indent">La tercera línea del archivo es <span class="literal" translate="no">3o</span>, no el número <span class="literal" translate="no">30</span>, así que cuando intentamos convertirlo en un número de coma flotante, el resultado es <span class="literal" translate="no">ValueError</span>. Hay dos enfoques que puedes adoptar cuando hay datos de este tipo en un archivo. La primera <a id="page_234"></a>es informar del error y salir del programa. La función <span class="literal" translate="no">read_data()</span> modificada quedaría como sigue:</p>
<p class="programs" translate="no">   def read_data(path):<br translate="no"/>       numbers = []<br translate="no"/>       try:<br translate="no"/>           with open(path) as f:<br translate="no"/>               for line in f:<br translate="no"/><span class="ent">➊</span>               try:<br translate="no"/><span class="ent">➋</span>                   n = float(line)<br translate="no"/>                 except ValueError:<br translate="no"/>                     print('Bad data: {0}'.format(line))<br translate="no"/><span class="ent">➌</span>                   break<br translate="no"/><span class="ent">➍</span>               numbers.append(n)<br translate="no"/>       except FileNotFoundError:<br translate="no"/>           print('File not found')<br translate="no"/>       return numbers</p>
<p class="indent">Insertamos otro bloque <span class="literal" translate="no">try...except</span> en la función que comienza en <span class="ent">➊,</span> y convertimos la línea en un número de coma flotante en <span class="ent">➋.</span> Si el programa lanza la excepción <span class="literal" translate="no">ValueError</span>, imprimimos un mensaje de error con la línea en cuestión y salimos del bucle <span class="literal" translate="no">for</span> utilizando <span class="literal" translate="no">break</span> en <span class="ent">➌.</span> A continuación, el programa deja de leer el archivo. La lista devuelta, <span class="literal" translate="no">numbers</span>, contiene todos los datos que se leyeron correctamente antes de encontrar los datos erróneos. Si no hay error, añadimos el número de coma flotante a la lista <span class="literal" translate="no">numbers</span> en <span class="ent">➍.</span></p>
<p class="indent">Ahora, cuando proporciones el archivo <em>datos_malos.txt</em> al programa, sólo leerá las dos primeras líneas, mostrará el mensaje de error y saldrá:</p>
<p class="programs" translate="no">Enter the path of the file: <span class="codestrong">bad_data.txt</span><br translate="no"/>Bad data: 3o<br translate="no"/><br translate="no"/>[10.0, 20.0]</p>
<p class="indent">Devolver datos parciales puede no ser deseable, así que podríamos sustituir la sentencia break en <span class="ent">➌</span> por <span class="literal" translate="no">return</span> y no se devolvería ningún dato.</p>
<p class="indent">El segundo enfoque consiste en ignorar el error y continuar con el resto del archivo. Aquí tienes una función <span class="literal" translate="no">read_data()</span> modificada que hace esto:</p>
<p class="programs" translate="no">   def read_data(path):<br translate="no"/>       numbers = []<br translate="no"/>       try:<br translate="no"/>           with open(path) as f:<br translate="no"/>               for line in f:<br translate="no"/>                   try:<br translate="no"/>                       n = float(line)<br translate="no"/>                   except ValueError:<br translate="no"/>                       print('Bad data: {0}'.format(line))<br translate="no"/><span class="ent">➊</span>                     continue<br translate="no"/>                   numbers.append(n)<br translate="no"/>       except FileNotFoundError:<br translate="no"/>           print('File not found')<br translate="no"/>       return numbers</p>
<p class="indent"><a id="page_235"></a>El único cambio aquí es que en lugar de salir del bucle <span class="literal" translate="no">for</span>, simplemente continuamos con la siguiente iteración utilizando la sentencia <span class="literal" translate="no">continue</span> en <span class="ent">➊.</span> La salida del programa es ahora la siguiente:</p>
<p class="programs" translate="no">Bad data: 3o<br translate="no"/><br translate="no"/>Bad data: 1/5<br translate="no"/><br translate="no"/>[10.0, 20.0, 5.6]</p>
<p class="indent">La aplicación específica en la que estés leyendo el archivo determinará cuál de los enfoques anteriores quieres adoptar para tratar los datos erróneos.</p>
<h3 class="h3" id="app02lev1sec07"><strong>Reutilizar el código</strong></h3>
<p class="noindent">A lo largo de este libro, hemos utilizado clases y funciones que formaban parte de la biblioteca estándar de Python o que estaban disponibles tras instalar paquetes de terceros, como matplotlib y SymPy. Ahora veremos un ejemplo rápido de cómo podemos importar nuestros propios programas en otros programas.</p>
<p class="indent">Consideremos la función <span class="literal" translate="no">find_corr_x_y()</span> que escribimos en "<a href="ch03.html#ch03lev1sec05">Cálculo de la correlación entre dos conjuntos de datos</a>" en <a href="ch03.html#page_75">la página 75</a>. Crearemos un archivo aparte, <em>correlación.py</em>, que sólo contiene la definición de la función:</p>
<p class="programs" translate="no">'''<br translate="no"/>Function to calculate the linear correlation coefficient<br translate="no"/>'''<br translate="no"/><br translate="no"/>def find_corr_x_y(x,y):<br translate="no"/>    # Size of each set<br translate="no"/>    n = len(x)<br translate="no"/><br translate="no"/>    # Find the sum of the products<br translate="no"/>    prod=[]<br translate="no"/>    for xi,yi in zip(x,y):<br translate="no"/>        prod.append(xi*yi)<br translate="no"/><br translate="no"/>    sum_prod_x_y = sum(prod)<br translate="no"/>    sum_x = sum(x)<br translate="no"/>    sum_y = sum(y)<br translate="no"/>    squared_sum_x = sum_x**2<br translate="no"/>    squared_sum_y = sum_y**2<br translate="no"/><br translate="no"/>    x_square=[]<br translate="no"/>    for xi in x:<br translate="no"/>        x_square.append(xi**2)<br translate="no"/>    x_square_sum = sum(x_square)<br translate="no"/><br translate="no"/>    y_square=[]<br translate="no"/>    for yi in y:<br translate="no"/>        y_square.append(yi**2)<br translate="no"/>    y_square_sum = sum(y_square)<br translate="no"/><br translate="no"/>    numerator = n*sum_prod_x_y - sum_x*sum_y<br translate="no"/>    denominator_term1 = n*x_square_sum - squared_sum_x<br translate="no"/>    denominator_term2 = n*y_square_sum - squared_sum_y<br translate="no"/>    denominator = (denominator_term1*denominator_term2)**0.5<br translate="no"/><br translate="no"/>    correlation = numerator/denominator<br translate="no"/><br translate="no"/>    return correlation</p>
<p class="indent"><a id="page_236"></a>Sin la extensión de archivo <em>.py</em>, un archivo Python se denomina módulo. Suele reservarse para archivos que definen clases y funciones que se utilizarán en otros programas. El siguiente programa importa la función <span class="literal" translate="no">find_corr_x_y()</span> del módulo de correlación que acabamos de definir:</p>
<p class="programs" translate="no">from correlation import find_corr_x_y<br translate="no"/>if __name__ == '__main__':<br translate="no"/>    high_school_math = [83, 85, 84, 96, 94, 86, 87, 97, 97, 85]<br translate="no"/>    college_admission = [85, 87, 86, 97, 96, 88, 89, 98, 98, 87]<br translate="no"/>    corr = find_corr_x_y(high_school_math, college_admission)<br translate="no"/>    print('Correlation coefficient: {0}'.format(corr))</p>
<p class="indent">Este programa encuentra la correlación entre las notas de matemáticas del instituto y las puntuaciones de admisión a la universidad de los estudiantes que consideramos en <a href="ch03.html#ch3tab3">la Tabla 3-3</a> de la <a href="ch03.html#page_80">página 80</a>. Importamos la función <span class="literal" translate="no">find_corr_x_y()</span> del módulo de correlación, creamos las listas que representan los dos conjuntos de notas y llamamos a la función <span class="literal" translate="no">find_corr_x_y()</span> con las dos listas como argumentos. Cuando ejecutes el programa, imprimirá el coeficiente de correlación. Ten en cuenta que los dos archivos deben estar en el mismo directorio, estrictamente para simplificar las cosas.</p>
</div>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<a href="app01.html">← Anterior</a><a href="index.html">Siguiente →</a><br/><br/><em>Recursos no desglosados:</em><br/><a href="app02.docx" target="_blank">&gt; Acceso sin conexión (formato Word / DOCX)</a><br/><a href="..\EN\doing-math-with-python\app02.html" target="_blank">&gt; Lectura en inglés</a></footer></body>
</html>