<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/>
<meta charset="utf-8"/>
<title>Capítulo 7: Resolución de problemas de cálculo</title>
<link href="style.css" media="all" rel="stylesheet" type="text/css"/>
<link href="core.css" media="all" rel="stylesheet" type="text/css"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h3 class="h3" id="ch07lev1sec06"><strong>Encontrar el máximo global mediante el ascenso del gradiente</strong></h3>
<p class="noindent">A veces sólo nos interesa encontrar el máximo global de una función en lugar de todos los máximos y mínimos locales y globales. Por ejemplo, podemos querer descubrir el ángulo de proyección para el que una bola recorrerá la máxima distancia horizontal. Vamos a aprender un nuevo enfoque más práctico para resolver un problema de este tipo. Este enfoque hace uso únicamente de la primera derivada, por lo que sólo es aplicable a funciones para las que pueda calcularse la primera derivada.</p>
<p class="indent">Este método se denomina <em>método</em> del gradiente ascendente, que es un enfoque iterativo para encontrar el máximo global. Como el método del ascenso gradiente implica muchos cálculos, es perfecto para resolverlo mediante programación y no a mano. Vamos a probarlo utilizando el problema de ejemplo de encontrar el ángulo de proyección. En el <a href="ch02.html#ch02">Capítulo 2</a>, dedujimos la expresión</p>
<div class="image2"><img alt="image" src="images/e0191-01.jpg" translate="no"/></div>
<p class="noindent">para calcular el tiempo de vuelo de un cuerpo en movimiento de proyectil que es lanzado con una velocidad <em>u</em> a un ángulo <em>θ</em>. El <em>alcance</em> de un proyectil, <em>R</em>, es la distancia horizontal total recorrida por el proyectil y viene dada por el producto de <em><sub>ux</sub></em> <em>×</em><sub>tflight</sub>. Aquí, <em><sub>ux</sub></em> es la componente horizontal de la velocidad inicial y es igual a <em>u</em> <em>cosθ</em>. Sustituyendo las fórmulas de <em><sub>ux</sub></em> y <sub>tflight</sub>, obtenemos la expresión</p>
<div class="image2"><img alt="image" src="images/e0191-02.jpg" translate="no"/></div>
<p class="indent">El gráfico de <a href="ch07.html#ch7fig4">la Figura 7-4</a> muestra valores de <em>θ</em> entre 0 y 90 grados y el alcance correspondiente (distancia recorrida) para cada ángulo. En el gráfico podemos ver que el alcance máximo se obtiene cuando el ángulo de proyección es de unos 45 grados. Ahora aprenderemos a utilizar el método del gradiente ascendente para hallar numéricamente este valor de <em>θ</em>.</p>
<div class="image"><a id="page_192"></a><img alt="image" src="images/f07-04.jpg" translate="no"/></div>
<p class="figuret"><a id="ch7fig4"></a><em>Figura 7-4: Alcance de un proyectil lanzado con una velocidad inicial de 25 m/s con distintos ángulos de proyección</em></p>
<p class="indent">El método de ascenso por gradiente es un método iterativo: empezamos con un valor inicial de θ <em>-digamos</em>, 0,001, o <sub>θold</sub> = 0,001- y nos acercamos gradualmente al valor de <em>θ</em> que corresponde al alcance máximo<a href="ch07.html#ch7fig5">(Figura 7-5</a>). El paso que nos acerca es la ecuación</p>
<div class="image2"><img alt="image" src="images/e0192-01.jpg" translate="no"/></div>
<p class="noindent">donde <em>λ</em> es el <em>tamaño del paso</em> y</p>
<div class="image2"><img alt="image" src="images/e0192-02.jpg" translate="no"/></div>
<p class="noindentb">es la derivada de <em>R</em> respecto a <em>θ</em>. Una vez fijado <sub>θold</sub> = 0,001, hacemos lo siguiente</p>
<p class="order">1. Calcula <sub>θnuevo</sub> utilizando la ecuación anterior.</p>
<p class="order">2. Si la diferencia absoluta <sub>θnew</sub> - <sub>θold</sub> es mayor que un valor, <em>ε</em>, fijamos <sub>θold</sub> = <sub>θnew</sub> y volvemos al paso 1. En caso contrario, vamos al paso 3.</p>
<p class="order">3. <sub>θnew</sub> es un valor aproximado de <em>θ</em> para el que <em>R</em> tiene el valor máximo.</p>
<p class="indentt">El valor de <em>épsilon</em><em>(ε</em>) determina cuándo decidimos detener la iteración del algoritmo. Se trata en "<a href="ch07.html#ch07lev2sec09">El papel del tamaño del paso y</a>épsilon" en <a href="ch07.html#page_197">la página 197</a>.</p>
<div class="image"><a id="page_193"></a><img alt="image" src="images/f07-05.jpg" translate="no"/></div>
<p class="figuret"><a id="ch7fig5"></a><em>Figura 7-5: El método de ascenso gradiente nos lleva iterativamente hacia el punto máximo de la función.</em></p>
<p class="indent">La siguiente función <span class="literal" translate="no">grad_ascent()</span> implementa el algoritmo de ascenso gradiente. El parámetro <span class="literal" translate="no">x0</span> es el valor inicial de la variable en el que comenzar la iteración, <span class="literal" translate="no">f1x</span> es la derivada de la función cuyo máximo queremos encontrar, y <span class="literal" translate="no">x</span> es el objeto <span class="literal" translate="no">Symbol</span> correspondiente a la variable de la función.</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Use gradient ascent to find the angle at which the projectile<br translate="no"/>   has maximum range for a fixed velocity, 25 m/s<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   import math<br translate="no"/>   from sympy import Derivative, Symbol, sin<br translate="no"/><br translate="no"/>   def grad_ascent(x0, f1x, x):<br translate="no"/><span class="ent">➊</span>     epsilon = 1e-6<br translate="no"/><span class="ent">➋</span>     step_size = 1e-4<br translate="no"/><span class="ent">➌</span>     x_old = x0<br translate="no"/><span class="ent">➍</span>     x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()<br translate="no"/><span class="ent">➎</span>     while abs(x_old - x_new) &gt; epsilon:<br translate="no"/>           x_old = x_new<br translate="no"/>           x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()<br translate="no"/><br translate="no"/>       return x_new<br translate="no"/><a id="page_194"></a><br translate="no"/><span class="ent">➏</span> def find_max_theta(R, theta):<br translate="no"/>       # Calculate the first derivative<br translate="no"/>       R1theta = Derivative(R, theta).doit()<br translate="no"/>       theta0 = 1e-3<br translate="no"/>       theta_max = grad_ascent(theta0, R1theta, theta)<br translate="no"/><span class="ent">➐</span>     return theta_max<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/><br translate="no"/>       g = 9.8<br translate="no"/>       # Assume initial velocity<br translate="no"/>       u = 25<br translate="no"/>       # Expression for range<br translate="no"/>       theta = Symbol('theta')<br translate="no"/><span class="ent">➑</span>     R = u**2*sin(2*theta)/g<br translate="no"/><br translate="no"/><span class="ent">➒</span>     theta_max = find_max_theta(R, theta)<br translate="no"/>       print('Theta: {0}'.format(math.degrees(theta_max)))<br translate="no"/>       print('Maximum Range: {0}'.format(R.subs({theta:theta_max})))</p>
<p class="indent">Establecemos el valor épsilon en <span class="literal" translate="no">1e-6</span> y el tamaño del paso en <span class="literal" translate="no">1e-4</span> en <span class="ent">➊</span> y <span class="ent">➋,</span> respectivamente. El valor épsilon debe ser siempre un valor positivo muy pequeño cercano a 0, y el tamaño del paso debe elegirse de forma que la variable se incremente en pequeñas cantidades en cada iteración del algoritmo. La elección del valor de épsilon y del tamaño del paso se trata con un poco más de detalle en "<a href="ch07.html#ch07lev2sec09">El papel del tamaño del paso y de épsilon</a>" en <a href="ch07.html#page_197">la página 197</a>.</p>
<p class="indent">Ajustamos <span class="literal" translate="no">x_old</span> a <span class="literal" translate="no">x0</span> en <span class="ent">➌</span> y calculamos <span class="literal" translate="no">x_new</span> por primera vez en <span class="ent">➍.</span> Utilizamos el método <span class="literal" translate="no">subs()</span> para sustituir el valor de <span class="literal" translate="no">x_old</span> en lugar de la variable y luego utilizamos <span class="literal" translate="no">evalf()</span> para calcular el valor numérico. Si la diferencia absoluta <span class="literal" translate="no">abs(x_old – x_new)</span> es mayor que <span class="literal" translate="no">epsilon</span>, el bucle <span class="literal" translate="no">while</span> en <span class="ent">➎</span> sigue ejecutándose, y seguimos actualizando el valor de <span class="literal" translate="no">x_old</span> y <span class="literal" translate="no">x_new</span> según los pasos 1 y 2 del algoritmo de ascenso gradiente. Una vez que salimos del bucle -es decir, de <span class="literal" translate="no">abs(x_old – x_new) &gt; epsilon</span>- devolvemos <span class="literal" translate="no">x_new</span>, el valor de la variable correspondiente al valor máximo de la función.</p>
<p class="indent">Empezamos a definir la función <span class="literal" translate="no">find_max_theta()</span> en <span class="ent">➏.</span> En esta función, calculamos la derivada de primer orden de <span class="literal" translate="no">R</span>; creamos una etiqueta, <span class="literal" translate="no">theta0</span>, y la establecemos en <span class="literal" translate="no">1e-3</span>; y llamamos a la función <span class="literal" translate="no">grad_ascent()</span> con estos dos valores como argumentos, además de un tercer argumento, el objeto símbolo <span class="literal" translate="no">theta</span>. Una vez obtenido el valor de <em>θ</em> correspondiente al valor máximo de la función (<span class="literal" translate="no">theta_max</span>), lo devolvemos en <span class="ent">➐.</span></p>
<p class="indent">Por último, creamos la expresión que representa el rango horizontal en <span class="ent">➑,</span> habiendo establecido la velocidad inicial, <span class="literal" translate="no">u = 25</span>, y el objeto símbolo <span class="literal" translate="no">theta</span> correspondiente al ángulo <em>θ</em>. A continuación, llamamos a la función <span class="literal" translate="no">find_max_theta()</span> con <span class="literal" translate="no">R</span> y <span class="literal" translate="no">theta</span> en <span class="ent">➒.</span></p>
<p class="indent">Cuando ejecutes este programa, deberías ver la siguiente salida:</p>
<p class="programs" translate="no">Theta: 44.99999978475661<br translate="no"/>Maximum Range: 63.7755102040816</p>
<p class="indent"><a id="page_195"></a>El valor de <em>θ</em> se imprime en grados y resulta ser próximo a 45 grados, como era de esperar. Si cambias la velocidad inicial por otros valores, verás que el ángulo de proyección en el que se alcanza el alcance máximo es siempre próximo a 45 grados.</p>
<h4 class="h4" id="ch07lev2sec07"><strong><em>Un programa genérico para el ascenso por gradiente</em></strong></h4>
<p class="noindent">Podemos modificar ligeramente el programa anterior para hacer un programa genérico de ascenso por gradiente:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Use gradient ascent to find the maximum value of a<br translate="no"/>   single-variable function<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   from sympy import Derivative, Symbol, sympify<br translate="no"/><br translate="no"/>   def grad_ascent(x0, f1x, x):<br translate="no"/>       epsilon = 1e-6<br translate="no"/>       step_size = 1e-4<br translate="no"/>       x_old = x0<br translate="no"/>       x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()<br translate="no"/>       while abs(x_old - x_new) &gt; epsilon:<br translate="no"/>           x_old = x_new<br translate="no"/>           x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()<br translate="no"/><br translate="no"/>       return x_new<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/><br translate="no"/>       f = input('Enter a function in one variable: ')<br translate="no"/>       var = input('Enter the variable to differentiate with respect to: ')<br translate="no"/>       var0 = float(input('Enter the initial value of the variable: '))<br translate="no"/>       try:<br translate="no"/>           f = sympify(f)<br translate="no"/>       except SympifyError:<br translate="no"/>           print('Invalid function entered')<br translate="no"/>       else:<br translate="no"/><span class="ent">➊</span>         var = Symbol(var)<br translate="no"/><span class="ent">➋</span>         d = Derivative(f, var).doit()<br translate="no"/><span class="ent">➌</span>         var_max = grad_ascent(var0, d, var)<br translate="no"/>           print('{0}: {1}'.format(var.name, var_max))<br translate="no"/>           print('Maximum value: {0}'.format(f.subs({var:var_max})))</p>
<p class="indent">La función <span class="literal" translate="no">grad_ascent()</span> sigue siendo la misma. Ahora, sin embargo, el programa pide al usuario que introduzca la función, la variable de la función y el valor inicial de la variable, donde comenzará el ascenso gradiente. Una vez que estamos seguros de que SymPy puede reconocer la entrada del usuario, creamos un objeto Símbolo correspondiente a la variable en <span class="ent">➊,</span> hallamos la primera derivada con respecto a ella en <span class="ent">➋,</span> y llamamos a la función <span class="literal" translate="no">grad_ascent()</span> con estos tres argumentos. El valor máximo se obtiene en <span class="ent">➌.</span></p>
<p class="indent"><a id="page_196"></a>Aquí tienes un ejemplo de ejecución:</p>
<p class="programs" translate="no">Enter a function in one variable: <span class="codestrong">25*25*sin(2*theta)/9.8</span><br translate="no"/>Enter the variable to differentiate with respect to: <span class="codestrong">theta</span><br translate="no"/>Enter the initial value of the variable: <span class="codestrong">0.001</span><br translate="no"/>theta: 0.785360029379083<br translate="no"/>Maximum value: 63.7755100185965</p>
<p class="indent">La entrada de la función es la misma que en nuestra primera implementación del gradiente ascendente, y el valor de <em>θ</em> se imprime en radianes.</p>
<p class="indent">Aquí tienes otra ejecución del programa, que encontrará el valor máximo de <em>cosy</em>:</p>
<p class="programs" translate="no">Enter a function in one variable: <span class="codestrong">cos(y)</span><br translate="no"/>Enter the variable to differentiate with respect to: <span class="codestrong">y</span><br translate="no"/>Enter the initial value of the variable: <span class="codestrong">0.01</span><br translate="no"/>y: 0.00999900001666658<br translate="no"/>Maximum value: 0.999950010415832</p>
<p class="indent">El programa también funciona correctamente para una función como <span class="literal" translate="no">cos(y) + k</span>, donde <span class="literal" translate="no">k</span> es una constante:</p>
<p class="programs" translate="no">Enter a function in one variable: <span class="codestrong">cos(y) + k</span><br translate="no"/>Enter the variable to differentiate with respect to: <span class="codestrong">y</span><br translate="no"/>Enter the initial value of the variable: <span class="codestrong">0.01</span><br translate="no"/>y: 0.00999900001666658<br translate="no"/>Maximum value: k + 0.999950010415832</p>
<p class="indent">Sin embargo, una función como <span class="literal" translate="no">cos(ky)</span> no funcionará porque su derivada de primer orden, <span class="literal" translate="no">kcos(ky)</span>, aún contiene <span class="literal" translate="no">k</span>, y SymPy no sabe nada sobre su valor. Por lo tanto, SymPy no puede realizar un paso clave en el algoritmo de ascenso gradiente, a saber, la comparación <span class="literal" translate="no">abs(x_old - x_new) &gt; epsilon</span>.</p>
<h4 class="h4" id="ch07lev2sec08"><strong><em>Advertencia sobre el valor inicial</em></strong></h4>
<p class="noindent">El valor inicial de la variable a partir de la cual iniciamos la iteración del método de ascenso gradiente desempeña un papel muy importante en el algoritmo. Consideremos la función <sup>x5</sup> - <sup>30x3</sup> + <em>50x</em>, que hemos utilizado como ejemplo en <a href="ch07.html#ch7fig3">la Figura 7-3</a>. Vamos a encontrar el máximo utilizando nuestro programa genérico de ascenso por gradiente:</p>
<p class="programs" translate="no">Enter a function in one variable: <span class="codestrong">x**5 - 30*x**3 + 50*x</span><br translate="no"/>Enter the variable to differentiate with respect to: <span class="codestrong">x</span><br translate="no"/>Enter the initial value of the variable: <span class="codestrong">-2</span><br translate="no"/>x: -4.17445116397103<br translate="no"/>Maximum value: 705.959460322318</p>
<p class="indent">El algoritmo de ascenso por gradiente se detiene cuando encuentra el <em>pico más cercano</em>, que no siempre es el máximo global. En este ejemplo, cuando parte del valor inicial -2, se detiene en el pico que también corresponde al máximo global <a id="page_197"></a>(aproximadamente 706) en el dominio considerado. Para comprobarlo mejor, probemos con otro valor inicial:</p>
<p class="programs" translate="no">Enter a function in one variable: <span class="codestrong">x**5 - 30*x**3 + 50*x</span><br translate="no"/>Enter the variable to differentiate with respect to: <span class="codestrong">x</span><br translate="no"/>Enter the initial value of the variable: <span class="codestrong">0.5</span><br translate="no"/>x: 0.757452532565767<br translate="no"/>Maximum value: 25.0846622605419</p>
<p class="indent">En este caso, el pico más cercano en el que se detiene el algoritmo de ascenso gradiente no es el verdadero máximo global de la función. <a href="ch07.html#ch7fig6">La figura 7-6</a> muestra el resultado del algoritmo de ascenso por gradiente en ambos casos.</p>
<div class="image"><img alt="image" src="images/f07-06.jpg" translate="no"/></div>
<p class="figuret"><a id="ch7fig6"></a><em>Figura 7-6: Resultados del algoritmo de ascenso por gradiente con distintos valores iniciales. El ascenso por gradiente siempre nos lleva al pico más cercano.</em></p>
<p class="indent">Por tanto, al utilizar este método, el valor inicial debe elegirse con cuidado. Algunas variaciones del algoritmo intentan resolver esta limitación.</p>
<h4 class="h4" id="ch07lev2sec09"><strong><em>El papel del tamaño del paso y el épsilon</em></strong></h4>
<p class="noindent">En el algoritmo de ascenso gradiente, el siguiente valor de la variable se calcula mediante la ecuación</p>
<div class="image2"><img alt="image" src="images/e0197-01.jpg" translate="no"/></div>
<p class="noindent">donde <em>λ</em> es el tamaño del <em>paso</em>. El tamaño del paso determina la distancia del siguiente paso. Debe ser pequeño para evitar <em>pasar por encima de</em> un pico. Es decir, si el valor actual <a id="page_198"></a>de <em>x</em> está cerca del valor que corresponde al valor máximo de la función, el siguiente paso no debería ir más allá del pico. En ese caso, el algoritmo no tendrá éxito. Por otra parte, los valores muy pequeños tardarán más en calcularse. Hemos utilizado un tamaño de paso fijo de <sup>10-3</sup>, pero puede que éste <em>no</em> sea el valor más adecuado para todas las funciones.</p>
<p class="indent">El valor de épsilon<em>(ε</em>) que determina cuándo decidimos detener la iteración del algoritmo debe ser un valor lo suficientemente pequeño como para que estemos convencidos de que el valor de <em>x</em> no está cambiando. Esperamos que la primera derivada, <em>f′</em><em>(x</em>), sea 0 en el punto máximo, y lo ideal es que la diferencia absoluta <sub>|θnew</sub> - <sub>θold|</sub> sea 0 (véase el paso 2 del algoritmo de ascenso gradiente en <a href="ch07.html#page_192">la página 192</a>). Sin embargo, debido a imprecisiones numéricas, puede que no obtengamos exactamente una diferencia de 0; por ello, el valor de épsilon se elige para que sea un valor cercano a 0, que, a efectos prácticos, nos diría que el valor de <em>x</em> ya no está cambiando. He utilizado <sup>10-6</sup> como épsilon para todas las funciones. Este valor, aunque suficientemente pequeño y adecuado para las funciones que tienen solución para <em>f′</em><em>(x</em>) = 0, como <span class="literal" translate="no">sin(x)</span>, puede no ser el valor adecuado para otras funciones. Por lo tanto, es una buena idea verificar el valor máximo al final para asegurarse de que es correcto y, si es necesario, ajustar el valor de <span class="literal" translate="no">epsilon</span> en consecuencia.</p>
<p class="indent">El paso 2 del algoritmo de ascenso gradiente también implica que, para que el algoritmo termine, la ecuación <em>f′</em><em>(x</em>) = 0 debe tener solución, lo que no ocurre con una función como <em><sup>ex</sup></em> o log<em>(x</em>). Por tanto, si proporcionas una de estas funciones como entrada al programa anterior, el programa no te dará una solución y seguirá ejecutándose. Podemos hacer que el programa de ascenso gradiente sea más útil para estos casos incorporando una comprobación para saber si <em>f′</em><em>(x</em>) = 0 tiene solución. Aquí tienes el programa modificado:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Use gradient ascent to find the maximum value of a<br translate="no"/>   single-variable function. This also checks for the existence<br translate="no"/>   of a solution for the equation f'(x)=0.<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   from sympy import Derivative, Symbol, sympify, solve<br translate="no"/><br translate="no"/>   def grad_ascent(x0, f1x, x):<br translate="no"/>       # Check if f1x=0 has a solution<br translate="no"/><span class="ent">➊</span>     if not solve(f1x):<br translate="no"/>           print('Cannot continue, solution for {0}=0 does not exist'.format(f1x))<br translate="no"/>           return<br translate="no"/>       epsilon = 1e-6<br translate="no"/>       step_size = 1e-4<br translate="no"/>       x_old = x0<br translate="no"/>       x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()<br translate="no"/>       while abs(x_old - x_new) &gt; epsilon:<br translate="no"/>           x_old = x_new<br translate="no"/>           x_new = x_old + step_size*f1x.subs({x:x_old}).evalf()<br translate="no"/><br translate="no"/>       return x_new<br translate="no"/><a id="page_199"></a><br translate="no"/>   if __name__ == '__main__':<br translate="no"/><br translate="no"/>       f = input('Enter a function in one variable: ')<br translate="no"/>       var = input('Enter the variable to differentiate with respect to: ')<br translate="no"/>       var0 = float(input('Enter the initial value of the variable: '))<br translate="no"/>       try:<br translate="no"/>           f = sympify(f)<br translate="no"/>       except SympifyError:<br translate="no"/>           print('Invalid function entered')<br translate="no"/>       else:<br translate="no"/>           var = Symbol(var)<br translate="no"/>           d = Derivative(f, var).doit()<br translate="no"/>           var_max = grad_ascent(var0, d, var)<br translate="no"/><span class="ent">➋</span>         if var_max:<br translate="no"/>              print('{0}: {1}'.format(var.name, var_max))<br translate="no"/>              print('Maximum value: {0}'.format(f.subs({var:var_max})))</p>
<p class="indent">En esta modificación de la función <span class="literal" translate="no">grad_ascent()</span>, llamamos a la función <span class="literal" translate="no">solve()</span> de SymPy en <span class="ent">➊</span> para determinar si la ecuación <em>f′</em>(<em>x</em>) = 0, aquí <span class="literal" translate="no">f1x</span>, tiene solución. Si no es así, imprimimos un mensaje y volvemos. Otra modificación aparece en el bloque <span class="literal" translate="no">__main__</span> en <span class="ent">➋.</span> Comprobamos si la función <span class="literal" translate="no">grad_ascent()</span> ha devuelto correctamente un resultado; si es así, procedemos a imprimir el valor máximo de la función y el valor correspondiente de la variable.</p>
<p class="indent">Estos cambios permiten al programa manejar funciones como log<em>(x</em>) y <em><sup>ex</sup></em>:</p>
<p class="programs" translate="no">Enter a function in one variable: <span class="codestrong">log(x)</span><br translate="no"/>Enter the variable to differentiate with respect to: <span class="codestrong">x</span><br translate="no"/>Enter the initial value of the variable: <span class="codestrong">0.1</span><br translate="no"/>Cannot continue, solution for 1/x=0 does not exist</p>
<p class="indent">Verás lo mismo para <em><sup>ex</sup></em>.</p>
<div class="sidebar">
<p class="sidebart"><strong>ALGORITMO DE DESCENSO DE GRADIENTE</strong></p>
<p class="noindent">El algoritmo inverso del algoritmo de ascenso por gradiente es el algoritmo de <em>descenso</em> por gradiente, que es un método para encontrar el valor mínimo de una función. Es similar al algoritmo de ascenso por gradiente, pero en lugar de "subir" por la función, "bajamos". El Desafío nº 2 de la <a href="ch07.html#page_205">página 205</a> analiza la diferencia entre estos dos algoritmos y te da la oportunidad de poner en práctica el inverso.</p>
</div>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="ch07_6.html">anterior</a><a href="ch07.html">Subtema 7 de 11: (Ver todo)</a><a href="ch07_8.html">siguiente</a><br/></p>
<br/><a href="ch07_7.docx" target="_blank"></a></footer>
</body>
</html>
