<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/>
<meta charset="utf-8"/>
<title>Capítulo 6: Dibujo de formas geométricas y fractales</title>
<link href="style.css" media="all" rel="stylesheet" type="text/css"/>
<link href="core.css" media="all" rel="stylesheet" type="text/css"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h3 class="h3" id="ch06lev1sec01"><a id="page_150"></a><strong>Dibujar formas geométricas con los parches de Matplotlib</strong></h3>
<p class="noindent">En matplotlib, <em>los par</em> ches nos permiten dibujar formas geométricas, a cada una de las cuales nos referimos como un <em>parche</em>. Puedes especificar, por ejemplo, el radio y el centro de un círculo para añadir el círculo correspondiente a tu gráfico. Esto es bastante diferente de cómo hemos utilizado matplotlib hasta ahora, que ha consistido en suministrar las <em>coordenadas</em> <em>x</em> e <em>y</em> de los puntos a trazar. Sin embargo, antes de que podamos escribir un programa para utilizar la función de parches, tendremos que entender un poco mejor cómo se crea un gráfico con matplotlib. Considera el siguiente programa, que traza los puntos (1, 1), (2, 2) y (3, 3) utilizando matplotlib:</p>
<p class="programs" translate="no">&gt;&gt;&gt; <span class="codestrong">import matplotlib.pyplot as plt</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3]</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">y = [1, 2, 3]</span><br translate="no"/>&gt;&gt;&gt; <span class="codestrong">plt.plot(x, y)</span><br translate="no"/>[&lt;matplotlib.lines.Line2D object at 0x7fe822d67a20&gt;]<br translate="no"/>&gt;&gt;&gt; <span class="codestrong">plt.show()</span></p>
<p class="indent">Este programa crea una ventana matplotlib que muestra una línea que pasa por los puntos dados. En realidad, cuando se llama a la función <span class="literal" translate="no">plt.plot()</span>, se crea un objeto <span class="literal" translate="no">Figure</span>, dentro del cual se crean los ejes y, finalmente, se trazan los datos dentro de los ejes (ver <a href="ch06.html#ch6fig1">Figura 6-1</a>)<a href="footnote.html#fn03" id="fn_03"><sup>.1</sup></a></p>
<div class="image"><img alt="image" src="images/f06-01.jpg" translate="no"/></div>
<p class="figuret"><a id="ch6fig1"></a><em>Figura 6-1: Arquitectura de un gráfico matplotlib</em></p>
<p class="indent"><a id="page_151"></a>El siguiente programa vuelve a crear este gráfico, pero también crearemos explícitamente el objeto <span class="literal" translate="no">Figure</span> y le añadiremos ejes, en lugar de limitarnos a llamar a la función <span class="literal" translate="no">plot()</span> y confiar en ella para crearlos:</p>
<p class="programs" translate="no">   &gt;&gt;&gt; <span class="codestrong">import matplotlib.pyplot as plt</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3]</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">y = [1, 2, 3]</span><br translate="no"/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">fig = plt.figure()</span><br translate="no"/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong">ax = plt.axes()</span><br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">plt.plot(x, y)</span><br translate="no"/>   [&lt;matplotlib.lines.Line2D object at 0x7f9bad1dcc18&gt;]<br translate="no"/>   &gt;&gt;&gt; <span class="codestrong">plt.show()</span><br translate="no"/>   &gt;&gt;&gt;</p>
<p class="indent">Aquí, creamos el objeto <span class="literal" translate="no">Figure</span> utilizando la función <span class="literal" translate="no">figure()</span> en <span class="ent">➊,</span> y luego creamos los ejes utilizando la función <span class="literal" translate="no">axes()</span> en <span class="ent">➋.</span> La función <span class="literal" translate="no">axes()</span> también añade los ejes al objeto <span class="literal" translate="no">Figure</span>. Las dos últimas líneas son iguales que en el programa anterior. Esta vez, cuando llamamos a la función <span class="literal" translate="no">plot()</span>, ésta ve que ya existe un objeto <span class="literal" translate="no">Figure</span> con un objeto <span class="literal" translate="no">Axes</span> y procede directamente a trazar los datos que se le suministran.</p>
<p class="indent">Además de crear manualmente los objetos <span class="literal" translate="no">Figure</span> y <span class="literal" translate="no">Axes</span>, puedes utilizar dos funciones diferentes del módulo <span class="literal" translate="no">pyplot</span> para obtener una referencia a los objetos <span class="literal" translate="no">Figure</span> y <span class="literal" translate="no">Axes</span> actuales. Cuando llamas a la función <span class="literal" translate="no">gcf()</span>, te devuelve una referencia al <span class="literal" translate="no">Figure</span> actual, y cuando llamas a la función <span class="literal" translate="no">gca()</span>, te devuelve una referencia al <span class="literal" translate="no">Axes</span> actual. Una característica interesante de estas funciones es que cada una creará el objeto respectivo si aún no existe. El funcionamiento de estas funciones quedará más claro cuando las utilicemos más adelante en este capítulo.</p>
<h4 class="h4" id="ch06lev2sec01"><strong><em>Dibujar un círculo</em></strong></h4>
<p class="noindent">Para dibujar un círculo, puedes añadir el parche <span class="literal" translate="no">Circle</span> al objeto actual <span class="literal" translate="no">Axes</span>, como se demuestra en el siguiente ejemplo:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Example of using matplotlib's Circle patch<br translate="no"/>   '''<br translate="no"/>   import matplotlib.pyplot as plt<br translate="no"/><br translate="no"/>   def create_circle():<br translate="no"/><span class="ent">➊</span>     circle = plt.Circle((0, 0), radius = 0.5)<br translate="no"/>       return circle<br translate="no"/><br translate="no"/>   def show_shape(patch):<br translate="no"/><span class="ent">➋</span>     ax = plt.gca()<br translate="no"/>       ax.add_patch(patch)<br translate="no"/>       plt.axis('scaled')<br translate="no"/>       plt.show()<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/><span class="ent">➌</span>     c = create_circle()<br translate="no"/>       show_shape(c)</p>
<p class="indent"><a id="page_152"></a>En este programa, hemos separado la creación del objeto parche <span class="literal" translate="no">Circle</span> y la adición del parche a la figura en dos funciones: <span class="literal" translate="no">create_circle()</span> y <span class="literal" translate="no">show_shape()</span>. En <span class="literal" translate="no">create_circle()</span>, hacemos un círculo con centro en (0, 0) y radio de 0,5 creando un objeto <span class="literal" translate="no">Circle</span> con las coordenadas del centro (0, 0) pasadas como tupla y con el radio de 0,5 pasado mediante el argumento de palabra clave del mismo nombre en <span class="ent">➊.</span> La función devuelve el objeto <span class="literal" translate="no">Circle</span> creado.</p>
<p class="indent">La función <span class="literal" translate="no">show_shape()</span> está escrita de forma que funcione con cualquier parche de matplotlib. Primero obtiene una referencia al objeto <span class="literal" translate="no">Axes</span> actual utilizando la función <span class="literal" translate="no">gca()</span> en <span class="ent">➋.</span> Después, añade el parche que se le ha pasado utilizando la función <span class="literal" translate="no">add_patch()</span> y, por último, llama a la función <span class="literal" translate="no">show()</span> para mostrar la figura. Aquí llamamos a la función <span class="literal" translate="no">axis()</span> con el parámetro <span class="literal" translate="no">scaled</span>, que básicamente indica a matplotlib que ajuste automáticamente los límites de los ejes. Necesitaremos esta declaración en todos los programas que utilicen parches para escalar automáticamente los ejes. Por supuesto, también puedes especificar valores fijos para los límites, como vimos en el <a href="ch02.html#ch02">capítulo 2</a>.</p>
<p class="indent">En <span class="ent">➌,</span> llamamos a la función <span class="literal" translate="no">create_circle()</span> utilizando la etiqueta <span class="literal" translate="no">c</span> para referirnos al objeto <span class="literal" translate="no">Circle</span> devuelto. A continuación, llamamos a la función <span class="literal" translate="no">show_shape()</span>, pasando <span class="literal" translate="no">c</span> como argumento. Cuando ejecutes el programa, verás una ventana matplotlib que muestra el círculo (ver <a href="ch06.html#ch6fig2">Figura 6-2</a>).</p>
<div class="image"><img alt="image" src="images/f06-02.jpg" translate="no"/></div>
<p class="figuret"><a id="ch6fig2"></a><em>Figura 6-2: Un círculo con centro en (0, 0) y radio de 0,5</em></p>
<p class="indent"><a id="page_153"></a>Como puedes ver, el círculo no parece exactamente un círculo. Esto se debe a la relación de aspecto automática, que determina la relación entre la longitud de los <em>ejes</em> <em>x</em> e <em>y</em>. Si insertas la sentencia <span class="literal" translate="no">ax.set_aspect('equal')</span> después de <span class="ent">➋,</span> verás que el círculo sí parece un círculo. La función <span class="literal" translate="no">set_aspect()</span> se utiliza para establecer la relación de aspecto del gráfico; utilizando el argumento <span class="literal" translate="no">equal</span>, pedimos a matplotlib que establezca la relación de la longitud de los <em>ejes</em> <em>x</em> e y en 1:1.</p>
<p class="indent">Tanto el color de las aristas como el color de las caras (color de relleno) del parche pueden cambiarse utilizando los argumentos de palabra clave <span class="literal" translate="no">ec</span> y <span class="literal" translate="no">fc</span>. Por ejemplo, si pasas <span class="literal" translate="no">fc='g'</span> y <span class="literal" translate="no">ec='r'</span> crearás un círculo con un color de cara verde y un color de borde rojo.</p>
<p class="indent">Matplotlib admite otros parches, como <span class="literal" translate="no">Ellipse</span>, <span class="literal" translate="no">Polygon</span> y <span class="literal" translate="no">Rectangle</span>.</p>
<h4 class="h4" id="ch06lev2sec02"><strong><em>Crear figuras animadas</em></strong></h4>
<p class="noindent">A veces podemos querer crear figuras con formas en movimiento. El soporte para animación de Matplotlib nos ayudará a conseguirlo. Al final de esta sección, crearemos una versión animada del programa de dibujo de trayectorias de proyectiles.</p>
<p class="indent">Primero, veamos un ejemplo más sencillo. Dibujaremos una figura de matplotlib con un círculo que empieza siendo pequeño y crece hasta un radio determinado indefinidamente (a menos que se cierre la ventana de matplotlib):</p>
<p class="programs" translate="no">   '''<br translate="no"/>   A growing circle<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   from matplotlib import pyplot as plt<br translate="no"/>   from matplotlib import animation<br translate="no"/><br translate="no"/>   def create_circle():<br translate="no"/>       circle = plt.Circle((0, 0), 0.05)<br translate="no"/>       return circle<br translate="no"/><br translate="no"/>   def update_radius(i, circle):<br translate="no"/>       circle.radius = i*0.5<br translate="no"/>       return circle,<br translate="no"/><br translate="no"/>   def create_animation():<br translate="no"/><span class="ent">➊</span>     fig = plt.gcf()<br translate="no"/>       ax = plt.axes(xlim=(-10, 10), ylim=(-10, 10))<br translate="no"/>       ax.set_aspect('equal')<br translate="no"/>       circle = create_circle()<br translate="no"/><span class="ent">➋</span>     ax.add_patch(circle)<br translate="no"/><span class="ent">➌</span>     anim = animation.FuncAnimation(<br translate="no"/>           fig, update_radius, fargs = (circle,), frames=30, interval=50)<br translate="no"/>       plt.title('Simple Circle Animation')<br translate="no"/>       plt.show()<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/>       create_animation()</p>
<p class="indentb"><a id="page_154"></a>Empezaremos importando el módulo <span class="literal" translate="no">animation</span> del paquete matplotlib. La función <span class="literal" translate="no">create_animation()</span> realiza aquí la funcionalidad principal. Obtiene una referencia al objeto <span class="literal" translate="no">Figure</span> actual utilizando la función <span class="literal" translate="no">gcf()</span> en <span class="ent">➊</span> y luego crea los ejes con límites de -10 y 10 tanto para <em>el</em> <em>eje</em> <em>x</em> como para el <em>eje y</em>. Después, crea un objeto <span class="literal" translate="no">Circle</span> que represente un círculo con radio 0,05 y centro en (0, 0) y añade este círculo a los ejes actuales en <span class="ent">➋.</span> A continuación, creamos un objeto <span class="literal" translate="no">FuncAnimation</span> <span class="ent">➌,</span> que pasa los siguientes datos sobre la animación que queremos crear:</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">fig</span></span> Este es el objeto <span class="literal" translate="no">Figure</span> actual.</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">update_radius</span></span> Esta función se encargará de dibujar <em>cada</em> fotograma. Toma dos argumentos: un número de fotograma que se le pasa automáticamente al llamarla y el objeto parche que queremos actualizar cada fotograma. Esta función también debe devolver el objeto.</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">fargs</span></span> Esta tupla consta de todos los argumentos que hay que pasar a la función <span class="literal" translate="no">update_radius()</span> aparte del número de fotograma. Si no hay argumentos que pasar, no es necesario especificar este argumento.</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">frames</span></span> Es el número de fotogramas de la animación. Nuestra función <span class="literal" translate="no">update_radius()</span> es llamada así muchas veces. Aquí, hemos elegido arbitrariamente 30 fotogramas.</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">interval</span></span> Este es el intervalo de tiempo en milisegundos entre dos fotogramas. Si tu animación parece demasiado lenta, disminuye este valor; si parece demasiado rápida, auméntalo.</p>
<p class="indentt">A continuación, establecemos un título mediante la función <span class="literal" translate="no">title()</span> y, por último, mostramos la figura mediante la función <span class="literal" translate="no">show()</span>.</p>
<p class="indent">Como ya hemos dicho, la función <span class="literal" translate="no">update_radius()</span> se encarga de actualizar la propiedad del círculo que cambiará en cada fotograma. Aquí, fijamos el radio en <span class="literal" translate="no">i*0.5</span>, donde <span class="literal" translate="no">i</span> es el número de fotograma. Como resultado, verás un círculo que crece en cada fotograma durante 30 fotogramas, por lo que el radio del círculo más grande es 15. Como los límites de los ejes están fijados en -10 y 10, esto da el efecto de que el círculo sobrepasa las dimensiones de la figura. Cuando ejecutes el programa, verás tu primera figura animada, como se muestra en la <a href="ch06.html#ch6fig3">Figura 6-3</a>.</p>
<p class="indent">Observarás que la animación continúa hasta que cierras la ventana de matplotlib. Éste es el comportamiento por defecto, que puedes cambiar estableciendo el argumento de la palabra clave en <span class="literal" translate="no">repeat=False</span> cuando crees el objeto <span class="literal" translate="no">FuncAnimation</span>.</p>
<div class="image"><a id="page_155"></a><img alt="image" src="images/f06-03.jpg" translate="no"/></div>
<p class="figuret"><a id="ch6fig3"></a><em>Figura 6-3: Animación de un círculo simple</em></p>
<div class="sidebar">
<p class="sidebart"><strong>OBJETO FUNCANIMACIÓN Y PERSISTENCIA</strong></p>
<p class="noindent">Probablemente hayas observado en el programa del círculo animado que asignamos el objeto <span class="literal" translate="no">FuncAnimation</span> creado a la etiqueta <span class="literal" translate="no">anim</span> aunque no volvamos a utilizarlo en ningún otro lugar. Esto se debe a un problema con el comportamiento actual de matplotlib: no almacena ninguna referencia al objeto <span class="literal" translate="no">FuncAnimation</span>, por lo que está sujeto a la recolección de basura por parte de Python. Esto significa que la animación no se creará. Crear una etiqueta que haga referencia al objeto evita que esto ocurra.</p>
<p class="indent">Para saber más sobre este tema, puedes seguir las discusiones en <em><a href="https://github.com/matplotlib/matplotlib/issues/1656/">https://github.com/matplotlib/matplotlib/issues/1656/.</a></em></p>
</div>
<h4 class="h4" id="ch06lev2sec03"><a id="page_156"></a><strong><em>Animar la trayectoria de un proyectil</em></strong></h4>
<p class="noindent">En el <a href="ch02.html#ch02">Capítulo 2</a>, dibujamos la trayectoria de una pelota en movimiento de proyectil. Aquí, nos basaremos en este dibujo, haciendo uso del soporte de animación de matplotlib para animar la trayectoria, de modo que se acerque más a la demostración de cómo verías viajar una pelota en la vida real:</p>
<p class="programs" translate="no">   '''<br translate="no"/>   Animate the trajectory of an object in projectile motion<br translate="no"/>   '''<br translate="no"/><br translate="no"/>   from matplotlib import pyplot as plt<br translate="no"/>   from matplotlib import animation<br translate="no"/>   import math<br translate="no"/><br translate="no"/>   g = 9.8<br translate="no"/><br translate="no"/>   def get_intervals(u, theta):<br translate="no"/><br translate="no"/>       t_flight = 2*u*math.sin(theta)/g<br translate="no"/>       intervals = []<br translate="no"/>       start = 0<br translate="no"/>       interval = 0.005<br translate="no"/>       while start &lt; t_flight:<br translate="no"/>           intervals.append(start)<br translate="no"/>           start = start + interval<br translate="no"/>       return intervals<br translate="no"/><br translate="no"/>   def update_position(i, circle, intervals, u, theta):<br translate="no"/><br translate="no"/>       t = intervals[i]<br translate="no"/>       x = u*math.cos(theta)*t<br translate="no"/>       y = u*math.sin(theta)*t - 0.5*g*t*t<br translate="no"/>       circle.center = x, y<br translate="no"/>       return circle,<br translate="no"/><br translate="no"/>   def create_animation(u, theta):<br translate="no"/><br translate="no"/>       intervals = get_intervals(u, theta)<br translate="no"/><br translate="no"/>       xmin = 0<br translate="no"/>       xmax = u*math.cos(theta)*intervals[-1]<br translate="no"/>       ymin = 0<br translate="no"/>       t_max = u*math.sin(theta)/g<br translate="no"/><span class="ent">➊</span>     ymax = u*math.sin(theta)*t_max - 0.5*g*t_max**2<br translate="no"/>       fig = plt.gcf()<br translate="no"/><span class="ent">➋</span>     ax = plt.axes(xlim=(xmin, xmax), ylim=(ymin, ymax))<br translate="no"/><br translate="no"/>       circle = plt.Circle((xmin, ymin), 1.0)<br translate="no"/>       ax.add_patch(circle)<br translate="no"/><a id="page_157"></a><br translate="no"/><span class="ent">➌</span>     anim = animation.FuncAnimation(fig, update_position,<br translate="no"/>                           fargs=(circle, intervals, u, theta),<br translate="no"/>                           frames=len(intervals), interval=1,<br translate="no"/>                           repeat=False)<br translate="no"/><br translate="no"/>       plt.title('Projectile Motion')<br translate="no"/>       plt.xlabel('X')<br translate="no"/>       plt.ylabel('Y')<br translate="no"/>       plt.show()<br translate="no"/><br translate="no"/>   if __name__ == '__main__':<br translate="no"/>       try:<br translate="no"/>           u = float(input('Enter the initial velocity (m/s): '))<br translate="no"/>           theta = float(input('Enter the angle of projection (degrees): '))<br translate="no"/>       except ValueError:<br translate="no"/>           print('You entered an invalid input')<br translate="no"/>       else:<br translate="no"/>           theta = math.radians(theta)<br translate="no"/>           create_animation(u, theta)</p>
<p class="indent">La función <span class="literal" translate="no">create_animation()</span> acepta dos argumentos: <span class="literal" translate="no">u</span> y <span class="literal" translate="no">theta</span>. Estos argumentos corresponden a la velocidad inicial y al ángulo de proyección<em>(θ</em>), que se suministraron como entrada al programa. La función <span class="literal" translate="no">get_intervals()</span> se utiliza para encontrar los intervalos de tiempo en los que calcular las <em>coordenadas</em> <em>x</em> e <em>y</em>. Esta función se implementa haciendo uso de la misma lógica que utilizamos en el <a href="ch02.html#ch02">Capítulo 2</a>, cuando implementamos una función independiente, <span class="literal" translate="no">frange()</span>, para ayudarnos.</p>
<p class="indent">Para establecer los límites de los ejes de la animación, necesitaremos encontrar los valores mínimo y máximo de <em>x</em> e <em>y</em>. El valor mínimo de cada uno es 0, que es el valor inicial de cada uno. El valor máximo de la coordenada <em>x</em> es el valor de la coordenada al final del vuelo de la pelota, que es el último intervalo de tiempo de la lista <span class="literal" translate="no">intervals</span>. El valor máximo de la coordenada <em>y</em> es cuando la bola está en su punto más alto, es decir, en <span class="ent">➊,</span> donde calculamos ese punto mediante la fórmula</p>
<div class="image2"><img alt="image" src="images/e0157-01.jpg" translate="no"/></div>
<p class="indent">Una vez que tenemos los valores, creamos los ejes en <span class="ent">➋,</span> pasando los límites de eje adecuados. En las dos sentencias siguientes, creamos una representación de la bola y la añadimos al objeto <span class="literal" translate="no">Axes</span> de la figura creando un círculo de radio <span class="literal" translate="no">1.0</span> en (<span class="literal" translate="no">xmin</span>, <span class="literal" translate="no">ymin</span>)-las coordenadas mínimas de los ejes <em>x</em> e <em>y</em>, respectivamente.</p>
<p class="indentb">A continuación, creamos el objeto <span class="literal" translate="no">FuncAnimation</span> <span class="ent">➌,</span> suministrándole el objeto figura actual y los siguientes argumentos:</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">update_position</span></span> Esta función cambiará el centro del círculo en cada fotograma. La idea aquí es que se crea un nuevo fotograma por cada intervalo de tiempo, por lo que fijamos el número de fotogramas al tamaño de los intervalos de tiempo <a id="page_158"></a>(consulta la descripción de <span class="literal" translate="no">frames</span> en esta lista). Calculamos las <em>coordenadas</em> <em>x e</em> <em>y</em> de la bola en el instante de tiempo en el <span class="literal" translate="no">i</span>intervalo de tiempo, y fijamos el centro del círculo a estos valores.</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">fargs</span></span> La función <span class="literal" translate="no">update_position()</span> necesita acceder a la lista de intervalos de tiempo, intervalos, velocidad inicial y theta, que se especifican mediante este argumento de palabra clave.</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">frames</span></span> Como dibujaremos un fotograma por intervalo de tiempo, fijamos el número de fotogramas al tamaño de la lista <span class="literal" translate="no">intervals</span>.</p>
<p class="itemlist"><span class="literal" translate="no"><span class="codestrong">repeat</span></span> Como ya comentamos en el primer ejemplo de animación, la animación se repite indefinidamente por defecto. No queremos que eso ocurra en este caso, así que fijamos esta palabra clave en <span class="literal" translate="no">False</span>.</p>
<p class="indentt">Cuando ejecutes el programa, te pedirá las entradas iniciales y luego creará la animación, como se muestra en la <a href="ch06.html#ch6fig4">Figura 6-4</a>.</p>
<div class="image"><img alt="image" src="images/f06-04.jpg" translate="no"/></div>
<p class="figuret"><a id="ch6fig4"></a><em>Figura 6-4: Animación de la trayectoria de un proyectil</em></p>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="ch06_1.html">anterior</a><a href="ch06.html">Subtema 2 de 5: (Ver todo)</a><a href="ch06_3.html">siguiente</a><br/></p>
<br/><a href="ch06_2.docx" target="_blank"></a></footer>
</body>
</html>
