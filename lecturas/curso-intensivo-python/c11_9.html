<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css"/>
<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style><meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h3 id="h2-502703c11-0004">Una prueba que pasa</h3>
<p class="BodyFirst">Con <code translate="no">pytest</code>, escribir tu primera prueba unitaria es bastante sencillo. Escribiremos una única función de prueba. La función de prueba llamará a la función que estamos probando y haremos una afirmación sobre el valor devuelto. Si nuestra afirmación es correcta, la prueba pasará; si la afirmación es incorrecta, la prueba fallará.</p>
<p><span epub:type="pagebreak" id="Page_213" title="213"></span>Aquí tienes la primera prueba de la función <code translate="no">get_formatted_name()</code>:</p>
<p class="CodeLabel" translate="no"><b>test_name_function.py</b></p>
<pre translate="no"><code translate="no">from name_function import get_formatted_name

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> def test_first_last_name():
    """Do names like 'Janis Joplin' work?"""
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>     formatted_name = get_formatted_name('janis', 'joplin')
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>     assert formatted_name == 'Janis Joplin'</code></pre>
<p>Antes de ejecutar la prueba, echemos un vistazo más de cerca a esta función. El nombre del archivo de prueba es importante; debe empezar por <em translate="no">test_</em>. Cuando le pidamos a <code translate="no">pytest</code> que ejecute las pruebas que hemos escrito, buscará cualquier archivo que empiece por <em translate="no">test_</em>, y ejecutará todas las pruebas que encuentre en ese archivo.</p>
<p>En el archivo de prueba, primero importamos la función que queremos probar: <code translate="no">get_formatted_name()</code>. Después definimos una función de prueba: en este caso, <code translate="no">test_first_last_name()</code> <span aria-label="annotation1" class="CodeAnnotation">❶.</span> Se trata de un nombre de función más largo que el que hemos estado utilizando, por una buena razón. En primer lugar, las funciones de prueba deben empezar por la palabra <em translate="no">test</em>, seguida de un guión bajo. Cualquier función que empiece por <code translate="no">test_</code> será <em translate="no">discovered</em> por <code translate="no">pytest</code>, y se ejecutará como parte del proceso de prueba.</p>
<p>Además, los nombres de las pruebas deben ser más largos y descriptivos que el nombre típico de una función. Nunca llamarás a la función tú mismo; <code translate="no">pytest</code> encontrará la función y la ejecutará por ti. Los nombres de las funciones de prueba deben ser lo suficientemente largos como para que, si ves el nombre de la función en un informe de prueba, tengas una buena idea de qué comportamiento se estaba probando.</p>
<p>A continuación, llamamos a la función que estamos probando <span aria-label="annotation2" class="CodeAnnotation">❷.</span> Aquí llamamos a <code translate="no">get_formatted_name()</code> con los argumentos <code translate="no">'janis'</code> y <code translate="no">'joplin'</code>, igual que utilizamos cuando ejecutamos <em translate="no">names.py</em>. Asignamos el valor de retorno de esta función a <code translate="no">formatted_name</code>.</p>
<p>Por último, hacemos una afirmación <span aria-label="annotation3" class="CodeAnnotation">❸.</span> Una <em translate="no">assertion</em> es una afirmación sobre una condición. Aquí afirmamos que el valor de <code translate="no">formatted_name</code> debe ser <code translate="no">'Janis Joplin'</code>.</p>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="c11_8.html">anterior</a><a href="c11.html">Subtema 9 de 22: (Ver todo)</a><a href="c11_10.html">siguiente</a><br/></p>
<br/><a href="c11_9.docx" target="_blank"></a></footer>
</body>
</html>
