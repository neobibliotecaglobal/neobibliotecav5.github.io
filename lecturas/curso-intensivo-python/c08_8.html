<!DOCTYPE html>

<html lang="es">
<head><meta charset="utf-8"/>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css"/>
<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style><meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
    body {
        width: 74%;
        min-height: 84vh;
        font-size: 16px;
        line-height: 1.5;
        margin: 0;
        padding-left: 13%;
        padding-right: 13%;
        padding-top: 3%;
        }
    
    @media screen and (max-width: 768px) {
        body {
            width: 92%;
            padding-left: 4%;
            padding-right: 4%;
            padding-top: 2%;
            font-size: 14px;
        }
    }
    
    @media screen and (max-width: 480px) {
        body {
            width: 96%;
            padding-left: 2%;
            padding-right: 2%;
            padding-top: 1%;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
<h3 id="h2-502703c08-0003"><span epub:type="pagebreak" id="Page_132" title="132"></span>Argumentos posicionales</h3>
<p class="BodyFirst">Cuando llamas a una función, Python debe hacer coincidir cada argumento de la llamada a la función con un parámetro de la definición de la función. La forma más sencilla de hacerlo es basándose en el orden de los argumentos proporcionados. Los valores emparejados de esta forma se denominan <em translate="no">positional arguments</em>.</p>
<p>Para ver cómo funciona esto, considera una función que muestra información sobre mascotas. La función nos dice qué tipo de animal es cada mascota y el nombre de la mascota, como se muestra aquí:</p>
<p class="CodeLabel" translate="no"><b>pets.py</b></p>
<pre translate="no"><code translate="no"><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> def describe_pet(animal_type, pet_name):
    """Display information about a pet."""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> describe_pet('hamster', 'harry')</code></pre>
<p>La definición muestra que esta función necesita un tipo de animal y el nombre del animal <span aria-label="annotation1" class="CodeAnnotation">❶.</span> Cuando llamamos a <code translate="no">describe_pet()</code>, necesitamos proporcionar un tipo de animal y un nombre, en ese orden. Por ejemplo, en la llamada a la función, el argumento <code translate="no">'hamster'</code> se asigna al parámetro <code translate="no">animal_type</code> y el argumento <code translate="no">'harry'</code> se asigna al parámetro <code translate="no">pet_name</code> <span aria-label="annotation2" class="CodeAnnotation">❷.</span> En el cuerpo de la función, estos dos parámetros se utilizan para mostrar información sobre la mascota que se está describiendo.</p>
<p>La salida describe un hámster llamado Harry:</p>
<pre translate="no"><code translate="no">I have a hamster.
My hamster's name is Harry.</code></pre>
<h4 id="h3-502703c08-0001">Llamadas múltiples a una función</h4>
<p class="BodyFirst">Puedes llamar a una función tantas veces como sea necesario. La descripción de una segunda mascota distinta sólo requiere una llamada más a <code translate="no">describe_pet()</code>:</p>
<pre translate="no"><code translate="no"><span class="LiteralGray">def describe_pet(animal_type, pet_name):</span>
<span class="LiteralGray">    """Display information about a pet."""</span>
<span class="LiteralGray">    print(f"\nI have a {animal_type}.")</span>
<span class="LiteralGray">    print(f"My {animal_type}'s name is {pet_name.title()}.")</span>

<span class="LiteralGray">describe_pet('hamster', 'harry')</span>
describe_pet('dog', 'willie')</code></pre>
<p>En esta segunda llamada a la función, pasamos a <code translate="no">describe_pet()</code> los argumentos <code translate="no">'dog'</code> y <code translate="no">'willie'</code>. Al igual que con el anterior conjunto de argumentos que utilizamos, Python hace coincidir <code translate="no">'dog'</code> con el parámetro <code translate="no">animal_type</code> y <code translate="no">'willie'</code> con el parámetro <code translate="no">pet_name</code>. Como antes, la función hace su trabajo, pero esta vez imprime los valores de un perro llamado Willie. Ahora tenemos un hámster llamado Harry y un perro llamado Willie:</p>
<pre translate="no"><code translate="no">I have a hamster.
My hamster's name is Harry.

<span epub:type="pagebreak" id="Page_133" title="133"></span>I have a dog.
My dog's name is Willie.</code></pre>
<p>Llamar a una función varias veces es una forma muy eficaz de trabajar. El código que describe una mascota se escribe una vez en la función. Luego, cada vez que quieras describir una nueva mascota, llamas a la función con la información de la nueva mascota. Aunque el código para describir una mascota se ampliara a 10 líneas, podrías describir una nueva mascota en una sola línea llamando de nuevo a la función.</p>
<h4 id="h3-502703c08-0002">El orden importa en los argumentos posicionales</h4>
<p class="BodyFirst">Puedes obtener resultados inesperados si confundes el orden de los argumentos en una llamada a función cuando utilizas argumentos posicionales:</p>
<pre translate="no"><code translate="no"><span class="LiteralGray">def describe_pet(animal_type, pet_name):</span>
<span class="LiteralGray">    """Display information about a pet."""</span>
<span class="LiteralGray">    print(f"\nI have a {animal_type}.")</span>
<span class="LiteralGray">    print(f"My {animal_type}'s name is {pet_name.title()}.")</span>

describe_pet('harry', 'hamster')</code></pre>
<p>En esta llamada a la función, enumeramos primero el nombre y después el tipo de animal. Como el argumento <code translate="no">'harry'</code> aparece primero esta vez, ese valor se asigna al parámetro <code translate="no">animal_type</code>. Del mismo modo, <code translate="no">'hamster'</code> se asigna a <code translate="no">pet_name</code>. Ahora tenemos un "harry" llamado "Hamster":</p>
<pre translate="no"><code translate="no">I have a harry.
My harry's name is Hamster.</code></pre>
<p>Si obtienes resultados raros como éste, comprueba que el orden de los argumentos en tu llamada a la función coincide con el orden de los parámetros en la definición de la función.</p>
<footer>
<style>
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1em;
            padding-bottom: 2em;
            border-top: 1px solid #eaeaea;
        }
        
        footer a {
            color: #0000FF; /* Color azul para los enlaces */
            text-decoration: none; /* Opcional: elimina el subrayado de los enlaces */
            margin-left: 1em;
            margin-right: 1em;
        }
        footer a:hover {
            text-decoration: underline; /* Opcional: subraya el enlace al pasar el mouse */
        }
    </style>
<p><a href="c08_7.html">anterior</a><a href="c08.html">Subtema 8 de 40: (Ver todo)</a><a href="c08_9.html">siguiente</a><br/></p>
<br/><a href="c08_8.docx" target="_blank"></a></footer>
</body>
</html>
