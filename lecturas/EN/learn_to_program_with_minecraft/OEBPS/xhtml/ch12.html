<html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis">
<head>
<title>Learn to Program with Minecraft</title>
<link href="../styles/9781593276706.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:40af8c70-d268-482b-9282-0b537fc6ae71" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_261"></span><strong><span class="blue1"><span class="big">12</span></span></strong><br/><strong>GETTING CLASSY WITH OBJECT-ORIENTED PROGRAMMING</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">Reusability is a very important aspect of programming. It saves time and effort. You’ve seen this with loops and functions, and now you’ll learn about <em>object-oriented programming</em>.</p>
<p class="indent">Object-oriented programming is an approach to programming that groups functions and variables together to create <em>classes</em>. Each class can be used to create <em>objects</em> that share the same variables and functions as the class. You can create many objects from the same class, making the class’s variables and functions reusable.</p>
<p class="indent">When a function is part of a class, it’s called a <em>method</em>, and a variable that’s part of a class is called an <em>attribute</em>.</p>
<p class="indent">In this chapter, you’ll learn object-oriented programming and use classes to reuse code. Mastering object-oriented programming and classes makes building programs a breeze, and you can even use object-oriented programming to make games. In the missions in this chapter, you’ll use classes to make some basic programs. You’ll start by creating a simple building, but soon you’ll build an entire town.</p>
<h3 class="h3" id="ch12lev1sec01"><span epub:type="pagebreak" id="page_262"></span><strong><span class="blue1">Object-Oriented Basics</span></strong></h3>
<p class="noindent">Object-oriented programming is very popular, and you can use it to create all kinds of cool software, but it can be a tricky concept to understand. Let’s relate it to something that’s more familiar: you.</p>
<p class="indent">You’re a person. You have a number of methods: you can eat, breathe, sleep, count to 10, and do lots of other things. You also have attributes: name, age, height, shoe size, and so on.</p>
<p class="indent">Your friend Mary has the same methods as you; she too can eat, breathe, sleep, count to 10, and do lots of other things. She also has the same attributes (name, age, and so on), although they contain different values.</p>
<p class="indent">In fact, everyone has these methods and attributes. You can describe people as a class. You and Mary are both people, so you could say you are both objects in the <span class="literal">Person</span> class.</p>
<p class="indent">In object-oriented programming, objects are called <em>instances</em> of a class. All objects share the methods and attributes of the class, but the values of the attributes can be different for each object.</p>
<p class="indent">Let’s jump into Python and make a class.</p>
<h3 class="h3" id="ch12lev1sec02"><strong><span class="blue1">Creating a Class</span></strong></h3>
<p class="noindent">You’ll start by creating a class and then create all your objects from that class. To create a class, you use the <span class="literal">class</span> keyword, the name you want to call the class, and the <span class="literal">object</span> class in parentheses (I’ll explain the <span class="literal">object</span> class in “<a href="ch12.xhtml#ch12lev2sec07">Inheriting a Class</a>” on <a href="ch12.xhtml#page_278">page 278</a>):</p>
<p class="programs"><span class="orange">class</span> <span class="blue1">ClassName</span>(<span class="rose">object</span>):<br/>    <span class="orange">def</span> <span class="blue1">__init_</span>_(self):<br/>        <span class="red"># Body of init</span></p>
<p class="indent">It’s good practice to capitalize the names of your classes. This makes it easier to tell the difference between classes and functions, which should start with a lowercase letter.</p>
<p class="indent">When you create a new class, you need to include the <span class="literal">__init__()</span> method and pass in <span class="literal">self</span> as an argument. The <span class="literal">self</span> argument is required by every method in a class. It references the class the method belongs to. The <span class="literal">__init__()</span> method tells Python what you want the class to do when you use it for the first time in a program. This is called <em>initializing</em> the class, which is what <span class="literal">__init__()</span> is short for.</p>
<p class="indent">For example, let’s create a class called <span class="literal">Cat</span> and then make some cat objects. The <span class="literal">Cat</span> class will store two attributes for each cat, their <span class="literal">name</span> and their <span class="literal">weight</span> in kilograms. Each cat object will have its own <span class="literal">name</span> and <span class="literal">weight</span> values. Open a new file in IDLE’s text editor and save it as <em>catClass.py</em> in a new folder called <em>classes</em>. Enter the following code to create a class called <span class="literal">Cat</span>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs">   <span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br/><span class="ent">➊</span>     <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, weight):<br/><span class="ent">➋</span>         self.name = name<br/><span class="ent">➌</span>         self.weight = weight</p>
<p class="indent"><span epub:type="pagebreak" id="page_263"></span>In this example, the <span class="literal">__init__()</span> method takes three arguments <span class="ent">➊</span>. The first is <span class="literal">self</span>, which is a required argument in every class method. The second argument, <span class="literal">name</span>, and the last argument, <span class="literal">weight</span>, are additional arguments to create attributes for all the cats.</p>
<p class="indent">The last two lines create the attributes <span class="literal">name</span> <span class="ent">➋</span> and <span class="literal">weight</span> <span class="ent">➌</span> and set them to the values of the <span class="literal">name</span> and <span class="literal">weight</span> arguments. When you create attributes inside a class, you use dot notation with <span class="literal">self</span>. Attributes are always identified by a <span class="literal">self</span>, which tells Python that an attribute belongs to the class.</p>
<p class="indent">Next, you’ll learn how to use this class to create instances of objects.</p>
<h4 class="h4" id="ch12lev2sec01"><strong><span class="blue1">Creating an Object</span></strong></h4>
<p class="noindent">Using the newly created class, let’s create some cat objects, or instances of the <span class="literal">Cat</span> class.</p>
<p class="indent">Initializing an object is similar to creating a variable. To initialize an object, you enter the name of the object, an equal sign (<span class="literal">=</span>), and the class name. You pass arguments to the class in parentheses, just as you do with a function call.</p>
<p class="indent">For example, let’s adopt a cat and name it Fluff. Using the <span class="literal">Cat</span> class, we can create a cat object called <span class="literal">fluff</span> by adding the following code on the last line of <em>catClass.py</em> (notice that it’s not indented):</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">class Cat(object):</span><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span><br/><br/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)</p>
<p class="indent">When you create an object, the number of arguments you provide depends on the arguments in its <span class="literal">__init__()</span> function. Here we include two arguments, one for <span class="literal">name</span> (<span class="literal">"Fluff"</span>) and one for <span class="literal">weight</span> (<span class="literal">4.5</span>). You don’t need to include the <span class="literal">self</span> argument when creating an object because the <span class="literal">self</span> argument is added automatically by Python.</p>
<p class="indent">Creating an object is also known as <em>calling a constructor</em>. The <span class="literal">__init__()</span> method is often referred to as a constructor because it constructs a class when called. The <span class="literal">__init__()</span> method is a special type of method because you don’t reference it by name. Instead, it runs when you create an object using the name of the class. For example, here the code <span class="literal">fluff = Cat("Fluff", 4.5)</span> calls the <span class="literal">__init__()</span> method, which constructs a <span class="literal">Cat</span> object called <span class="literal">fluff</span>.</p>
<p class="indent">Next, you’ll learn how to access the <span class="literal">fluff</span> object’s attributes.</p>
<h4 class="h4" id="ch12lev2sec02"><strong><span class="blue1">Accessing Attributes</span></strong></h4>
<p class="noindent">You can access the attributes of an object to get more information about that object. For example, add the following code to <em>catClass.py</em> after the <span class="literal">fluff</span> object to print the <span class="literal">weight</span> attribute of the <span class="literal">fluff</span> object:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="rose">print</span>(fluff.weight)</p>
<p class="indent"><span epub:type="pagebreak" id="page_264"></span>The value that prints when you run the program should be 4.5, because that’s what you set the <span class="literal">weight</span> attribute to when you created the object.</p>
<p class="indent">Notice that we’re using dot notation between the object’s name, <span class="literal">fluff</span>, and the <span class="literal">weight</span> attribute. The dot means you want to use the attribute that belongs to a specific object. In this case, the value of the <span class="literal">weight</span> attribute belongs to the <span class="literal">fluff</span> object. Whenever you get or set the value of an object’s attribute, you use dot notation.</p>
<p class="indent">You can change the value of an attribute as you would any other variable—by using an equal sign (<span class="literal">=</span>). For example, let’s change Fluff’s weight to 5 because he gained weight during the winter holidays. We do this by changing the <span class="literal">weight</span> attribute in the <span class="literal">fluff</span> object to 5:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs">fluff.weight = 5</p>
<p class="indent">Now whenever you access the <span class="literal">weight</span> attribute on the <span class="literal">fluff</span> object, it will be 5.</p>
<p class="indent">Using the knowledge you now have about making a class and creating an instance of it, let’s make some cool stuff in Minecraft.</p>
<h4 class="h4a" id="ch12lev2sec03"><strong>Mission #68: Location Objects</strong></h4>
<p class="noindent">Throughout the book, you’ve stored locations, such as your house, a castle, or a palace, in your Minecraft world. You’ve used variables, lists, tuples, and dictionaries to do this in a variety of ways.</p>
<p class="indent">You can also create and store related information, like locations, using object-oriented programming. For example, you can use objects to store the coordinates of a bunch of different locations.</p>
<p class="indent">Each location has an x-, y-, and z-coordinate, but the values for each location are different. By creating a location class, you can store and access the coordinates of different locations. That will help you keep track of all the awesome things you build in Minecraft. You’ll be able to easily access the coordinates of all your Minecraft creations so you can teleport the player to them in an instant!</p>
<p class="indent"><a href="ch12.xhtml#ch12ex1">Listing 12-1</a> contains the start of the <span class="literal">Location</span> class. When the code is finished, it can be used to store the coordinates of a location in a single object. Copy the code into a new file called <em>locationClass.py</em> in the <em>classes</em> folder.</p>
<p class="sidenote"><span class="blue"><em>locationClass.py</em></span></p>
<p class="programs">   <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br/>   mc = Minecraft.create()<br/><br/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Location</span>(<span class="rose">object</span>):<br/>       <span class="orange">def</span> <span class="blue1">__init_</span>_(self, x, y, z):<br/><span class="ent">➋</span>         self.x = x<br/><span class="ent">➌</span>         <span class="red"># Add the y and z attributes here</span><br/><br/><span class="ent">➍</span> bedroom = Location(64, 52, -8)<br/><span class="ent">➎</span> mc.player.setTilePos(bedroom.x, bedroom.y, bedroom.z)</p>
<p class="examplet"><a id="ch12ex1"></a><em>Listing 12-1: The start of the</em> <span class="literal"><span class="codeitalic">Location</span></span> <em>class</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_265"></span>To start the class, I included the <span class="literal">class</span> keyword and named the class <span class="literal">Location</span> <span class="ent">➊</span>. At <span class="ent">➍</span> is the code to initialize an object called <span class="literal">bedroom</span>, which will store the location of the bedroom in my Minecraft home. The <span class="literal">setTilePos()</span> method sets the player’s position to the bedroom’s location—the <span class="literal">bedroom</span> object’s <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span> attributes <span class="ent">➎</span>. However, the program is incomplete. You need to finish the <span class="literal">__init__()</span> method of the class and set the <span class="literal">y</span> and <span class="literal">z</span> attributes to the values of the arguments passed to the <span class="literal">__init__()</span> method. I set the value of the <span class="literal">x</span> attribute <span class="ent">➋</span>, but it’s your task to do the same for the <span class="literal">y</span> and <span class="literal">z</span> attributes <span class="ent">➌</span>. Don’t forget to use the location of your own bedroom at <span class="ent">➍</span>!</p>
<p class="indent"><a href="ch12.xhtml#ch12fig1">Figure 12-1</a> shows the completed program in action as it teleports the player into my bedroom.</p>
<div class="image"><img alt="image" src="../images/f12-01.jpg"/></div>
<p class="figcap"><a id="ch12fig1"></a><em>Figure 12-1: The program has teleported the player into my bedroom.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb01"><strong>BONUS OBJECTIVE: HOME SWEET HOME</strong></p>
<p class="noindent">Which other rooms in your house do you want to teleport to? Create more objects using the <span class="literal">Location</span> class to zip around your house in style!</p>
</div>
<h3 class="h3" id="ch12lev1sec03"><strong><span class="blue1">Understanding Methods</span></strong></h3>
<p class="noindent">Classes can contain methods, which are functions associated with the class. Writing class methods lets you create functions that all instances of that class can use. This is a great way to save time and reuse code, because you’ll only have to write one method.</p>
<p class="indent">To create a method, you write a function in the body of a class using the <span class="literal">def</span> keyword. You’ve used the <span class="literal">def</span> keyword in previous chapters to create functions. Methods are also created with the <span class="literal">def</span> keyword, but they’re indented under the class they belong to. For example, let’s update the <span class="literal">Cat</span> class in <span epub:type="pagebreak" id="page_266"></span><em>catClass.py</em>. We want the cat to be able to eat, so let’s add a method called <span class="literal">eat()</span> to the <span class="literal">Cat</span> class. Enter the code and make the changes to <em>catClass.py</em> as you follow along:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">class Cat(object):</span><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span><br/><br/>    <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br/>        self.weight = self.weight + 0.05<br/>        <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)</p>
<p class="indent">Notice that the method definition and body of the method are indented by an extra four spaces so Python knows they belong to the class.</p>
<p class="indent">Like functions, methods can take arguments. Here the <span class="literal">eat()</span> method takes an argument called <span class="literal">food</span> that states what the cat is eating. The <span class="literal">eat()</span> method increases the <span class="literal">weight</span> attribute of the cat by <span class="literal">0.05</span> and then prints a message that the cat is eating the food.</p>
<p class="indent">After creating an object, you can call any of its class’s methods. For example, you can call the <span class="literal">eat()</span> method using the <span class="literal">fluff</span> object. Add this code to the end of <em>catClass.py</em>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">fluff = Cat("Fluff", 4.5)</span><br/>fluff.eat(<span class="green">"tuna"</span>)</p>
<p class="indent">Here we see our earlier code, where we created an object called <span class="literal">fluff</span> that is part of the <span class="literal">Cat</span> class. Then we call the <span class="literal">eat()</span> method and give it the argument <span class="literal">"tuna"</span>. When you run the program, the output will look like this:</p>
<p class="programs"><span class="blue1">Fluff is eating tuna</span></p>
<p class="indent">Now Fluff is happily eating tuna. Remember that the <span class="literal">eat()</span> method also increases the weight attribute. After calling the <span class="literal">eat()</span> method, add the code to print <span class="literal">fluff</span>’s weight.</p>
<p class="indent">You can also call methods from inside the class by calling a method inside another method. Let’s create another method called <span class="literal">eatAndSleep()</span> inside the <span class="literal">Cat</span> class. The <span class="literal">eatAndSleep()</span> method calls the <span class="literal">eat()</span> method and then prints that the cat is sleeping. Add this code to <em>catClass.py</em>, just after the <span class="literal">eat()</span> method (make sure you indent the new method as shown so Python knows it’s part of the class):</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs">   <span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br/>       self.eat(food)<br/>       <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)</p>
<p class="indent">To call a method from inside the class it belongs to, you add <span class="literal">self.</span> to the beginning of the method name. Here the <span class="literal">eat()</span> method is called using <span class="literal">self.eat()</span>. Note that this is different from calling a method outside of <span epub:type="pagebreak" id="page_267"></span>a class. When you do that, you only have to enter the object name and the method you’re calling. For example, the following code calls the new <span class="literal">eatAndSleep()</span> method on the <span class="literal">fluff</span> object. Add it to your <em>catClass.py</em> file. This should be the last line of code in your program:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs">fluff.eatAndSleep(<span class="green">"tuna"</span>)</p>
<p class="indent">Here is the output that you should get when you run the program:</p>
<p class="programs"><span class="blue1">Fluff is eating tuna</span><br/><span class="blue1">Fluff is now sleeping...</span></p>
<p class="indent">Here’s the full program so you can see where all the pieces belong:</p>
<p class="programs"><span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br/>    <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, weight):<br/>        self.name = name<br/>        self.weight = weight<br/><br/>    <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br/>        self.weight = self.weight + 0.05<br/>        <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)<br/><br/>    <span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br/>        self.eat(food)<br/>        <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)<br/><br/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)<br/><span class="rose">print</span>(fluff.weight)<br/>fluff.eat(<span class="green">"tuna"</span>)<br/>fluff.eatAndSleep(<span class="green">"tuna"</span>)</p>
<p class="indent">Let’s take the new skills you’ve learned into the world of Minecraft!</p>
<h4 class="h4a" id="ch12lev2sec04"><strong>Mission #69: Ghost House</strong></h4>
<p class="noindent">The best thing about programming with Python and Minecraft is that you can start with a silly idea and run with it. Your idea might start small, but with just a few lines of code, you can build a fun program very quickly.</p>
<p class="indent">Wouldn’t it be fun to build a ghost house that appeared in a game, only to disappear 30 seconds later? The house could then reappear somewhere else and then disappear again if you wanted it to.</p>
<p class="indent">Here’s the first version of the ghost house program. Save <a href="ch12.xhtml#ch12ex2">Listing 12-2</a> in a file called <em>ghostHouse.py</em> in the <em>classes</em> folder.</p>
<p class="sidenote"><span class="blue"><em>ghostHouse.py</em></span></p>
<p class="programs">   <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br/>   mc = Minecraft.create()<br/><br/>   <span class="orange">import</span> time<br/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Building</span>(<span class="rose">object</span>):<br/><span class="ent">➋</span>     <span class="orange">def</span> <span class="blue1">__init_</span>_(self, x, y, z, width, height, depth):<br/>           self.x = x<br/>           self.y = y<br/>           self.z = z<br/><br/>           self.width = width<br/>           self.height = height<br/>           self.depth = depth<br/><br/><span class="ent">➌</span>     <span class="orange">def</span> <span class="blue1">build</span>(self):<br/>           mc.setBlocks(self.x, self.y, self.z,<br/>                        self.x + self.width, self.y + self.height,<br/>                        self.z + self.depth, 4)<br/><br/>           mc.setBlocks(self.x + 1, self.y + 1, self.z + 1,<br/>                        self.x + self.width - 1, self.y + self.height - 1,<br/>                        self.z + self.depth - 1, 0)<br/><span class="ent">➍</span>         <span class="red"># Call the buildDoor() and buildWindows() methods here</span><br/><br/><span class="ent">➎</span>     <span class="orange">def</span> <span class="blue1">clear</span>(self):<br/>           mc.setBlocks(self.x, self.y, self.z,<br/>                        self.x + self.width, self.y + self.height,<br/>                        self.z + self.depth, 0)<br/><span class="ent">➏</span>         <span class="red"># Remove the doors and windows here</span><br/><br/>   pos = mc.player.getTilePos()<br/>   x = pos.x<br/>   y = pos.y<br/>   z = pos.z<br/><br/><span class="ent">➐</span> ghostHouse = Building(x, y, z, 10, 6, 8) ghostHouse.build()<br/>   time.sleep(30)<br/><br/>   ghostHouse.clear()<br/><span class="ent">➑</span> ghostHouse.x = 8</p>
<p class="sidenote"><span class="blue"><em>ghostHouse.py</em></span></p>
<p class="examplet"><span epub:type="pagebreak" id="page_268"></span><a id="ch12ex2"></a><em>Listing 12-2: The</em> <span class="literal"><span class="codeitalic">Building</span></span> <em>class creates a building.</em></p>
<p class="indent"><a href="ch12.xhtml#ch12ex2">Listing 12-2</a> uses a class called <span class="literal">Building</span> <span class="ent">➊</span> with an <span class="literal">__init__()</span> method to set the house’s position and size <span class="ent">➋</span>. It creates a <span class="literal">Building</span> object with the name <span class="literal">ghostHouse</span> <span class="ent">➐</span>. The building appears and then mysteriously disappears after 30 seconds using the <span class="literal">build()</span> <span class="ent">➌</span> and <span class="literal">clear()</span> <span class="ent">➎</span> methods. The only problem is that it doesn’t look like a house. Right now it looks like a large, empty shell made of cobblestone.</p>
<p class="indent">You need to make the ghost house look more like a house and less like a shell, because ghost shells aren’t as scary as ghost houses. To make the building look more house-like, your mission is to add a method that builds a door at the front of the house and a second method that adds windows. Call these two methods from inside the <span class="literal">build()</span> method so they’re built at the same time <span class="ent">➍</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_269"></span>After adding the methods to build a door and windows, you’ll need to update the <span class="literal">clear()</span> method to delete them ➏; otherwise, they’ll be left behind when the house disappears.</p>
<p class="indent">When you’ve added the extra methods, move the building to a new location by changing the <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span> attributes of the <span class="literal">ghostHouse</span> object and adding more calls to the <span class="literal">build()</span> and <span class="literal">clear()</span> methods. I’ve started this for you by changing the house’s <span class="literal">x</span> position ➑.</p>
<p class="indent">When you run the program, the ghost house should suddenly appear and then disappear 30 seconds later, only to reappear somewhere else. Spooky!</p>
<p class="indent"><a href="ch12.xhtml#ch12fig2">Figure 12-2</a> shows my ghost house.</p>
<div class="image"><img alt="image" src="../images/f12-02.jpg"/></div>
<p class="figcap"><a id="ch12fig2"></a><em>Figure 12-2: The ghost house appears and then disappears.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb02"><span epub:type="pagebreak" id="page_270"></span><strong>BONUS OBJECTIVE: HOME IMPROVEMENT</strong></p>
<p class="noindent">At the moment, the ghost house is very basic. Using the amazing Python skills you’ve learned in this book, add whatever you want to the <span class="literal">build()</span> function to customize your house.</p>
</div>
<h3 class="h3" id="ch12lev1sec04"><strong><span class="blue1">Returning Values with Methods</span></strong></h3>
<p class="noindent">Like functions, methods can also return values, or an object’s attributes, using the <span class="literal">return</span> keyword. For example, let’s say we want to convert Fluff the cat’s weight from kilograms to grams. A kilogram is equal to 1000 grams, so to make the conversion, you multiply the <span class="literal">weight</span> attribute by 1000 and return it. Add the following <span class="literal">getWeightInGrams()</span> method to the <span class="literal">Cat</span> class in <em>catClass.py</em>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">class Cat(object):</span><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span><br/><br/>    <span class="orange">def</span> <span class="blue1">getWeightInGrams</span>(self):<br/>        <span class="orange">return</span> self.weight * 1000</p>
<p class="indent">To output the value returned by the method, you create an object and call the method. In the following code, the <span class="literal">fluff</span> object is used, and the method is called inside a <span class="literal">print()</span> function to get the cat’s weight in grams:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">fluff = Cat("Fluff", 4.5)</span><br/><span class="rose">print</span>(fluff.getWeightInGrams())</p>
<p class="indent">Now when you run the file, it will output the following:</p>
<p class="programs"><span class="blue1">4500</span></p>
<p class="indent">In the next mission, we’ll extend the ghost house program to include a method that returns information about the building.</p>
<h4 class="h4a" id="ch12lev2sec05"><strong>Mission #70: Ghost Castle</strong></h4>
<p class="noindent">I have all kinds of names in mind for the different places I’ve built in my Minecraft world: the beach house, the plant farm, the animal farm, the storage room, the palace, the underwater palace, the underground palace, and loads more. The problem is that the names only exist in my head!</p>
<p class="indent">With classes, you can create attributes like location and size for things you build, as you saw in Mission #69 (<a href="ch12.xhtml#page_267">page 267</a>). You can also include names!</p>
<p class="indent"><span epub:type="pagebreak" id="page_271"></span>Let’s name the ghost house and have Python remember it for us. We’ll update the <span class="literal">Building</span> class from Mission #69 to add an extra method that returns the name of the building. Copy <a href="ch12.xhtml#ch12ex3">Listing 12-3</a> into a new file called <em>ghostCastle.py</em> in the <em>classes</em> folder.</p>
<p class="sidenote"><span class="blue"><em>ghostCastle.py</em></span></p>
<p class="programs">   <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br/>   mc = Minecraft.create()<br/>   <span class="orange">import</span> time<br/><br/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">NamedBuilding</span>(<span class="rose">object</span>):<br/><span class="ent">➋</span>     <span class="orange">def</span> <span class="blue1">__init_</span>_(self, x, y, z, width, height, depth, name):<br/>           self.x = x<br/>           self.y = y<br/>           self.z = z<br/><br/>           self.width = width<br/>           self.height = height<br/>           self.depth = depth<br/><br/><span class="ent">➌</span>         self.name = name<br/><br/>           <span class="orange">def</span> <span class="blue1">build</span>(self):<br/>           mc.setBlocks(self.x, self.y, self.z,<br/>                        self.x + self.width, self.y + self.height,<br/>                        self.z + self.depth, 4)<br/><br/>           mc.setBlocks(self.x + 1, self.y + 1, self.z + 1,<br/>                        self.x + self.width - 1, self.y + self.height - 1,<br/>                        self.z + self.depth - 1, 0)<br/><br/>       <span class="orange">def</span> <span class="blue1">clear</span>(self):<br/>           mc.setBlocks(self.x, self.y, self.z,<br/>                        self.x + self.width, self.y + self.height,<br/>                        self.z + self.depth, 0)<br/><br/><span class="ent">➍</span>     <span class="orange">def</span> <span class="blue1">getInfo</span>():<br/>           <span class="red"># Add the body of the getInfo() method here</span><br/><br/>   pos = mc.player.getTilePos()<br/>   x = pos.x<br/>   y = pos.y<br/>   z = pos.z<br/>   ghostCastle = NamedBuilding(x, y, z, 10, 16, 16, <span class="green">"Ghost Castle"</span>)<br/>   ghostCastle.build()<br/><span class="ent">➎</span> mc.postToChat(ghostCastle.getInfo())<br/><br/>   time.sleep(30)<br/><br/>   ghostCastle.clear()</p>
<p class="examplet"><em><a id="ch12ex3"></a>Listing 12-3:</em> <span class="literal"><span class="codeitalic">NamedBuilding</span></span> <em>is very similar to the</em> <span class="literal"><span class="codeitalic">Building</span></span> <em>class, except it has an extra attribute called</em> <span class="literal"><span class="codeitalic">name</span></span> <em>and an extra method that returns a description of the building.</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_272"></span>First, I changed the name of the class to <span class="literal">NamedBuilding</span> so we won’t confuse it with the <span class="literal">Building</span> class from the previous mission <span class="ent">➊</span>. I’ve added an extra argument and attribute to the constructor called <span class="literal">name</span> <span class="ent">➋</span>. The argument allows you to give a name to the building, and the constructor assigns the name to the <span class="literal">name</span> attribute <span class="ent">➌</span>.</p>
<p class="indent">Your mission is to add a method called <span class="literal">getInfo()</span> to the new class <span class="literal">NamedBuilding</span> that returns the name and position of the building. I’ve added the start of the <span class="literal">getInfo()</span> method for you at <span class="ent">➍</span>. You just need to add the body. The <span class="literal">getInfo()</span> method is called on the <span class="literal">ghostCastle</span> object at <span class="ent">➎</span> so it outputs the string returned by the method to the Minecraft chat. For example, if the ghost castle is located at <span class="literal">x = -310</span>, <span class="literal">y = 64</span>, <span class="literal">z = 1081</span>, the <span class="literal">getInfo()</span> method should return the string <span class="literal">"Ghost Castle's location is at -310, 64, 1081"</span>.</p>
<p class="indent"><a href="ch12.xhtml#ch12fig3">Figure 12-3</a> shows my working program. Although the ghost castle is taller, it looks like the house from Mission #69. This is because the <span class="literal">build()</span> methods are the same for both, but feel free to change your version of the code so your building looks more like a castle.</p>
<div class="image"><img alt="image" src="../images/f12-03.jpg"/></div>
<p class="figcap"><a id="ch12fig3"></a><em>Figure 12-3: The description of the ghost castle is displayed.</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb03"><strong>BONUS OBJECTIVE: A WARM WELCOME</strong></p>
<p class="noindent">Wouldn’t it be cool if the name of any building you walked into appeared in the chat automatically? Well, it’s possible, but it’s a bit challenging. If you want to try this, you can use the <em>shower.py</em> program from Mission #32 (<a href="ch06.xhtml#page_124">page 124</a>) as a starting point. The file should be in your <em>ifStatements</em> folder. You can use the program to detect the coordinates of the player and, if they’re inside the building, call the <span class="literal">building</span> object’s <span class="literal">getInfo()</span> method.</p>
</div>
<h3 class="h3" id="ch12lev1sec05"><span epub:type="pagebreak" id="page_273"></span><strong><span class="blue1">Creating Multiple Objects</span></strong></h3>
<p class="noindent">You can make several objects from the same class by creating objects with different names using the same class constructor (remember that <em>constructor</em> is another name for the <span class="literal">__init__()</span> method). For example, let’s say we found a second cat named Stella who is now friends with Fluff. Open <em>catClass.py</em> and enter the following code to add Stella:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">class Cat(object):</span><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span><br/><br/><span class="ash">fluff = Cat("Fluff", 4.5)</span><br/>stella = Cat(<span class="green">"Stella"</span>, 3.9)</p>
<p class="indent">Now we have two cat objects, <span class="literal">fluff</span> and <span class="literal">stella</span>. Each has the same attributes, <span class="literal">name</span> and <span class="literal">weight</span>, but with different values.</p>
<p class="indent">Add the following code to <em>catClass.py</em> to print the cats’ names:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="rose">print</span>(fluff.name)<br/><span class="rose">print</span>(stella.name)</p>
<p class="indent">When you run the file, you’ll get this output:</p>
<p class="programs"><span class="blue1">Fluff</span><br/><span class="blue1">Stella</span></p>
<p class="indent">The two cat objects also have access to the same methods. Both can call the <span class="literal">eat()</span> function. Add this code to <em>catClass.py</em>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs">fluff.eat(<span class="green">"tuna"</span>)<br/>stella.eat(<span class="green">"cake"</span>)</p>
<p class="indent">And the output will look like this:</p>
<p class="programs"><span class="blue1">Fluff is eating tuna</span><br/><span class="blue1">Stella is eating cake</span></p>
<p class="indent">Writing a class makes creating lots of objects very easy. Let’s try creating multiple objects with Minecraft!</p>
<h4 class="h4a" id="ch12lev2sec06"><strong>Mission #71: Ghost Town</strong></h4>
<p class="noindent">What’s scarier than one ghost house? That’s right, two ghost houses. But three ghost houses would be even scarier. And more than three ghost houses? I need to stop thinking about this, or I won’t get any sleep tonight!</p>
<p class="indent"><span epub:type="pagebreak" id="page_274"></span>In Mission #69 (<a href="ch12.xhtml#page_267">page 267</a>), you made a class that builds a house that disappears. Now you can create several objects using the same class, and Python will remember each of the object’s attributes and methods. You can make as many houses as you want, and you can make them appear and disappear with ease.</p>
<p class="indent">Your mission is to create four or more ghost house objects and arrange them in a village. After a certain amount of time, make them all disappear and reappear elsewhere on the map, just like a real ghost town.</p>
<p class="indent">Open <em>ghostHouse.py</em> in IDLE—we’ll use this as a base. When you created a house in the <em>ghostHouse.py</em> program, your code should have looked like this:</p>
<p class="sidenote"><span class="blue"><em>ghostHouse.py</em></span></p>
<p class="programs">ghostHouse = Building(17, 22, -54, 10, 6, 8)<br/>ghostHouse.build()<br/><br/>time.sleep(30)<br/><br/>ghostHouse.clear()</p>
<p class="indent">Save <em>ghostHouse.py</em> as a new file called <em>ghostVillage.py</em>, and then create three or more objects in the file using the <span class="literal">Building</span> class to build the village. To help you get started, I’ve created a second object called <span class="literal">shop</span> in <a href="ch12.xhtml#ch12ex4">Listing 12-4</a>. I’ve also set the variables <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span> to hold the player’s current position, which we find using <span class="literal">player.getTilePos()</span>. This makes it easier to build the village all around you.</p>
<p class="sidenote"><span class="blue"><em>ghostVillage.py</em></span></p>
<p class="programs">pos = mc.player.getTilePos()<br/>x = pos.x<br/>y = pos.y<br/>z = pos.z<br/>ghostHouse = Building(x, y, z, 10, 6, 8)<br/>shop = Building(x + 12, y, z, 8, 12, 10)<br/><span class="red"># Create more ghost building objects here</span><br/><br/>ghostHouse.build()<br/>shop.build()<br/><span class="red"># Build more ghost building objects here</span><br/><br/>time.sleep(30)<br/><br/>ghostHouse.clear()<br/>shop.clear()</p>
<p class="examplet"><a id="ch12ex4"></a><em>Listing 12-4: Creating multiple ghost building objects</em></p>
<p class="indent"><a href="ch12.xhtml#ch12fig4">Figure 12-4</a> shows my ghost village. After 30 seconds, the ghost buildings suddenly disappear.</p>
<div class="image"><span epub:type="pagebreak" id="page_275"></span><img alt="image" src="../images/f12-04.jpg"/></div>
<p class="figcap"><a id="ch12fig4"></a><em>Figure 12-4: Look at all the ghost buildings in the ghost village!</em></p>
<h3 class="h3" id="ch12lev1sec06"><strong><span class="blue1">Class Attributes</span></strong></h3>
<p class="noindent">Sometimes you might want to set attributes that have the same value for every object instance in a class. It would be redundant to pass the same argument to the class every time an object is created. Instead, you can create a preset attribute in the class, and all the instances of objects in that class will share those attributes.</p>
<p class="indent">When multiple objects share the same attribute, it’s called a <em>class attribute</em>. For example, all the cat objects we’ve created are owned by Craig (me). I can revisit the <span class="literal">Cat</span> class in the <em>catClass.py</em> file, create a class attribute called <span class="literal">owner</span>, and set it to <span class="literal">"Craig"</span>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">class Cat(object):</span><br/>    owner = <span class="green">"Craig"</span><br/><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span></p>
<p class="indent">As you can see, class attributes don’t use <span class="literal">self</span> before their name. In this example, <span class="literal">owner</span> is a class attribute and <span class="literal">self.name</span> is an attribute. Notice that you define class attributes outside the <span class="literal">__init__()</span> function.</p>
<p class="indent">Class attributes work the same as any other attribute in an object. For example, you can access the value of a class attribute as you would a normal attribute. In this case, to find Fluff’s owner, we can print the <span class="literal">owner</span> class attribute of the <span class="literal">fluff</span> object:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">fluff = Cat("Fluff", 4.5)</span><br/><span class="rose">print</span>(fluff.owner)</p>
<p class="indent"><span epub:type="pagebreak" id="page_276"></span>The printed value should be <span class="literal">"Craig"</span>. If we printed Stella’s owner, the value would be the same because class attributes are the same for every object in that class:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="ash">stella = Cat("Stella", 3.9)</span><br/><span class="rose">print</span>(stella.owner)</p>
<p class="indent">The printed value here is also <span class="literal">"Craig"</span>.</p>
<p class="indent">You can change the value of class attributes for individual objects. This will change the value of the attribute for that object, but no other objects in the class. For example, Stella has been adopted by my friend Matthew, so we need to change Stella’s owner to <span class="literal">"Matthew"</span>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs">stella.owner = <span class="green">"Matthew"</span><br/><span class="ash">print(stella.owner)</span><br/><span class="ash">print(fluff.owner)</span></p>
<p class="indent">When the <span class="literal">owner</span> attribute of <span class="literal">stella</span> is printed, it shows <span class="literal">"Matthew"</span>, but <span class="literal">fluff</span>’s owner is still <span class="literal">"Craig"</span>.</p>
<p class="indent">After all the changes we’ve made to <em>catClass.py</em>, the final program looks like the following. It’s also available in the book’s resources at <em><a href="https://www.nostarch.com/programwithminecraft/">https://www.nostarch.com/programwithminecraft/</a></em>.</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<p class="programs"><span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br/>    owner = <span class="green">"Craig"</span><br/><br/>    <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, weight):<br/>        self.name = name<br/>        self.weight = weight<br/><br/>    <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br/>        self.weight = self.weight + 0.05<br/>        <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)<br/><br/>    <span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br/>        self.eat(food)<br/>        <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)<br/><br/>    <span class="orange">def</span> <span class="blue1">getWeightInGrams</span>(self):<br/>        <span class="orange">return</span> self.weight * 1000<br/><br/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)<br/><span class="rose">print</span>(fluff.owner)<br/>stella = Cat(<span class="green">"Stella"</span>, 3.9)<br/><span class="rose">print</span>(stella.owner)<br/><br/><span class="rose">print</span>(fluff.weight)<br/>fluff.eat(<span class="green">"tuna"</span>)<br/>fluff.eatAndSleep(<span class="green">"tuna"</span>)<br/><br/><span class="rose">print</span>(fluff.getWeightInGrams())<br/><span class="rose">print</span>(fluff.name)<br/><span class="rose">print</span>(stella.name)<br/><br/>fluff.eat(<span class="green">"tuna"</span>)<br/>stella.eat(<span class="green">"cake"</span>)<br/><br/>stella.owner = <span class="green">"Matthew"</span><br/><span class="rose">print</span>(stella.owner)<br/><span class="rose">print</span>(fluff.owner)</p>
<p class="indent"><span epub:type="pagebreak" id="page_277"></span>Now that you’ve seen how to use objects, let’s see how to make them even more powerful with inheritance.</p>
<h3 class="h3" id="ch12lev1sec07"><strong><span class="blue1">Understanding Inheritance</span></strong></h3>
<p class="noindent"><em>Inheritance</em> occurs when classes share the same methods and attributes as other classes. For example, ducks are a type of bird. They share the same methods as other birds (flying, eating, and so on), and they have the same attributes as other birds (weight, wingspan, and so on). So you could say that <em>ducks</em> inherit their attributes and methods from the class <em>birds</em>. <a href="ch12.xhtml#ch12fig5">Figure 12-5</a> shows this relationship in a diagram.</p>
<div class="image"><img alt="image" src="../images/f12-05.jpg"/></div>
<p class="figcap"><a id="ch12fig5"></a><em>Figure 12-5: Penguins and ducks are both types of birds.</em></p>
<p class="indent">The class that other classes inherit from is called a <em>superclass</em>; the class that inherits from the superclass is called a <em>subclass</em>.</p>
<p class="indent">Inheritance is useful because it allows you to create subtle differences between similar objects. For example, penguins are also a type of bird, but they can swim underwater, unlike most birds. To represent penguins, you need to create a subclass that inherits from the bird class but has adaptations so the penguins can swim underwater. These adaptations are the reason you create subclasses: you can keep the main superclass features to avoid having to write the code again, and just add the methods and attributes you need in the subclass.</p>
<h4 class="h4" id="ch12lev2sec07"><span epub:type="pagebreak" id="page_278"></span><strong><span class="blue1">Inheriting a Class</span></strong></h4>
<p class="noindent">When a subclass inherits from a superclass, the subclass can use all the superclass’s methods and attributes. The subclass can also add extra classes and attributes without altering the original superclass.</p>
<p class="indent">Let’s use the birds example to illustrate this. First, we’ll write the code for the <span class="literal">Bird</span> superclass. Open a new file in IDLE, name it <em>birdClass.py</em>, and then add the following code to make the class:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs"><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Bird</span>(<span class="rose">object</span>):<br/><span class="ent">➋</span>     <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, wingspan):<br/>           self.name = name<br/>           self.wingspan = wingspan<br/><br/><span class="ent">➌</span>     <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br/>           <span class="rose">print</span>(<span class="green">"chirp"</span>)<br/><span class="ent">➍</span>     <span class="orange">def</span> <span class="blue1">fly</span>(self):<br/>       <span class="rose">print</span>(<span class="green">"flap"</span>)</p>
<p class="indent">We create a class called <span class="literal">Bird</span> <span class="ent">➊</span>, but notice that the <span class="literal">Bird</span> class inherits from <span class="literal">object</span>. The <span class="literal">object</span> class is a base class that all other classes will be built on top of. All classes inherit from the <span class="literal">object</span> class, and you use it when there are no other superclasses to inherit from. Even if there are several levels of inheritance where lots of classes inherit from each other, the <span class="literal">object</span> class will always be the superclass used on the highest level of inheritance.</p>
<p class="indent">The <span class="literal">Bird</span> class’s <span class="literal">__init__()</span> method takes two arguments that set two attributes: the <span class="literal">name</span> of the bird and its <span class="literal">wingspan</span> <span class="ent">➋</span>. It has two methods: <span class="literal">birdcall()</span> <span class="ent">➌</span> and <span class="literal">fly()</span> <span class="ent">➍</span>. At the moment, the <span class="literal">birdcall()</span> method just prints <span class="literal">"chirp"</span> and the <span class="literal">fly()</span> method just prints <span class="literal">"flap"</span>.</p>
<p class="indent">In the same file, create an object called <span class="literal">gardenBird</span> using the <span class="literal">Bird</span> class:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs">gardenBird = Bird(<span class="green">"Geoffrey"</span>, 12)<br/>gardenBird.birdcall()<br/>gardenBird.fly()</p>
<p class="indent">This code will output:</p>
<p class="programs"><span class="blue1">chirp</span><br/><span class="blue1">flap</span></p>
<p class="indent">Now that you’ve created a superclass, you can create a subclass that inherits from the superclass but gets its own method. You’ll do that in the next section.</p>
<h4 class="h4" id="ch12lev2sec08"><span epub:type="pagebreak" id="page_279"></span><strong><span class="blue1">Adding New Methods to Subclasses</span></strong></h4>
<p class="noindent">Let’s add a class for penguins to <em>birdClass.py</em> and call it <span class="literal">Penguin</span>. Because penguins can swim underwater, you can add an extra method to the <span class="literal">Penguin</span> class called <span class="literal">swim()</span>:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs"><span class="orange">class</span> <span class="blue1">Penguin</span>(Bird):<br/>    <span class="orange">def</span> <span class="blue1">swim</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"swimming"</span>)</p>
<p class="indent">When you define a subclass and want it to inherit from another super-class instead of <span class="literal">object</span>, you put the name of the superclass to inherent from in parentheses. Notice that I didn’t create an <span class="literal">__init__()</span> method for the <span class="literal">Penguin</span> class. The reason is that it inherits from the <span class="literal">Bird</span> class, so it uses the <span class="literal">Bird</span> class <span class="literal">__init__()</span> method. Let’s use that <span class="literal">__init__()</span> method and test the <span class="literal">swim()</span> function by creating a penguin:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs">sarahThePenguin = Penguin(<span class="green">"Sarah"</span>, 10)<br/>sarahThePenguin.swim()</p>
<p class="indent">This code will output the following:</p>
<p class="programs"><span class="blue1">swimming</span></p>
<p class="indent">The <span class="literal">Penguin</span> class can also use the <span class="literal">fly()</span> and <span class="literal">birdcall()</span> methods because it inherits them from <span class="literal">Bird</span>.</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs">sarahThePenguin.fly()<br/>sarahThePenguin.birdcall()</p>
<p class="indent">In this case, the output will look like this:</p>
<p class="programs"><span class="blue1">flap</span><br/><span class="blue1">chirp</span></p>
<p class="indent">But <span class="literal">flap</span> and <span class="literal">chirp</span> don’t make sense for a penguin because penguins can’t fly and their birdcall is more of a quack! We’ll learn how to override inherited methods and fix this in “<a href="ch12.xhtml#ch12lev1sec08">Overriding Methods and Attributes</a>” on <a href="ch12.xhtml#page_282">page 282</a>.</p>
<p class="indent">But first, let’s return to Minecraft and create some new ghost buildings using inheritance.</p>
<h4 class="h4a" id="ch12lev2sec09"><strong>Mission #72: Ghost Hotel</strong></h4>
<p class="noindent">Houses and hotels are both types of buildings: they have doors, windows, rooms, stairs, and walls. Hotels are just fancy houses with extras like balconies, lots of rooms, and a pretty entrance.</p>
<p class="indent"><span epub:type="pagebreak" id="page_280"></span>How can you program some ghost hotels using the code you’ve already created for ghost houses? The basic structure of the buildings is the same. So let’s say the only difference is that ghost hotels have extra methods to create carpets inside the rooms and add flowers around the edge of the building. That means the ghost hotel class can inherit all the methods from the ghost house class. Then all the ghost hotel class needs is two extra methods for the carpets and flowers.</p>
<p class="indent">In IDLE, create a new file and save it as <em>ghostHotel.py</em> in the <em>classes</em> folder. Copy and paste the code for the <span class="literal">Building</span> class from the <em>ghostHouse.py</em> pro-gram into the file.</p>
<p class="indent">Create a new class called <span class="literal">FancyBuilding</span> that inherits from the <span class="literal">Building</span> class. The <span class="literal">FancyBuilding</span> class should have a new method called <span class="literal">upgrade()</span> that adds carpet inside the building and flowers around the walls. <a href="ch12.xhtml#ch12ex5">Listing 12-5</a> shows my code for the <span class="literal">upgrade()</span> method, but feel free to customize your hotels.</p>
<p class="sidenote"><span class="blue"><em>ghostHotel.py</em></span></p>
<p class="programs"><span class="red"># Create a FancyBuilding class here</span><br/><br/>    <span class="orange">def</span> <span class="blue1">upgrade</span>(self):<br/>        <span class="red"># Carpet</span><br/>        mc.setBlocks(self.x + 1, self.y, self.z + 1,<br/>                     self.x + self.width - 1, self.y, self.z + self.depth - 1,<br/>                     35, 6)<br/><br/>    <span class="red"># Flowers</span><br/>    mc.setBlocks(self.x - 1, self.y, self.z -1,<br/>                 self.x - 1, self.y, self.z + self.depth + 1,<br/>                 37)<br/>    mc.setBlocks(self.x - 1, self.y, self.z - 1,<br/>                 self.x + self.width + 1, self.y, self.z – 1,<br/>                 37)<br/>    mc.setBlocks(self.x + self.width + 1, self.y, self.z - 1,<br/>                 self.x + self.width + 1, self.y, self.z + self.depth + 1,<br/>                 37)<br/>    mc.setBlocks(self.x - 1, self.y, self.z + self.depth + 1,<br/>                 self.x + self.width + 1, self.y, self.z + self.depth = 1,<br/>                 37)<br/><br/><span class="red"># Create an instance of the FancyBuilding class</span><br/><span class="red"># Call the build() and upgrade() methods</span></p>
<p class="examplet"><a id="ch12ex5"></a><em>Listing 12-5: A method for the</em> <span class="literal"><span class="codeitalic">FancyBuilding</span></span> <em>class that adds carpet and flowers to the building</em></p>
<p class="indent">After you’ve created the class and added the new method, create an instance of the <span class="literal">FancyBuilding</span> class and call it <span class="literal">ghostHotel</span>. Build the ghost hotel using the <span class="literal">build()</span> method, and then add the extra bits using the <span class="literal">upgrade()</span> method.</p>
<p class="indent"><a href="ch12.xhtml#ch12fig6">Figure 12-6</a> shows my fancy ghost hotel.</p>
<div class="image"><span epub:type="pagebreak" id="page_281"></span><img alt="image" src="../images/f12-06.jpg"/></div>
<p class="figcap"><a id="ch12fig6"></a><em>Figure 12-6: Look at those flowers and that carpet!</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb04"><strong>BONUS OBJECTIVE: FANCY VILLAGE</strong></p>
<p class="noindent">In Mission #71, you created a ghost village in which all the buildings looked about the same. It’s rare to see identical buildings in real towns. Change the ghost village program by creating several classes that inherit from the <span class="literal">Building</span> class. You could make a <span class="literal">Shop</span> class, a <span class="literal">Hospital</span> class, and a <span class="literal">Restaurant</span> class, for example. Then when you create the objects, you can choose which type of building to create by using the different classes.</p>
</div>
<h3 class="h3" id="ch12lev1sec08"><span epub:type="pagebreak" id="page_282"></span><strong><span class="blue1">Overriding Methods and Attributes</span></strong></h3>
<p class="noindent">It’s possible for a subclass to redefine methods and attributes from its super-class. This is useful when you want to use the same name for a method but you want it to behave differently in the subclass.</p>
<p class="indent">In “<a href="ch12.xhtml#ch12lev1sec07">Understanding Inheritance</a>” on <a href="ch12.xhtml#page_277">page 277</a>, we created a <span class="literal">Bird</span> class and a <span class="literal">Penguin</span> class. The <span class="literal">Penguin</span> class inherited from <span class="literal">Bird</span> so it shared all its methods. But penguins can’t fly, and their birdcall is more of a quack sound than a chirp. So, we should change the <span class="literal">fly()</span> and <span class="literal">birdcall()</span> methods to reflect this. Open <em>birdClass.py</em> and add this code:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs">   <span class="ash">class Penguin(Bird):</span><br/>       <span class="ash">def swim(self):</span><br/>           <span class="ash">print("swimming")</span><br/><br/><span class="ent">➊</span>     <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br/>           <span class="rose">print</span>(<span class="green">"sort of a quack"</span>)<br/><br/><span class="ent">➋</span>     <span class="orange">def</span> <span class="blue1">fly</span>(self):<br/>           <span class="rose">print</span>(<span class="green">"Penguins cannot fly :("</span>)</p>
<p class="indent">I’ve made two changes to the <span class="literal">Penguin</span> class. I’ve added a <span class="literal">birdcall()</span> <span class="ent">➊</span> method and a <span class="literal">fly()</span> <span class="ent">➋</span> method. Because both methods are spelled the same as they are in the <span class="literal">Bird</span> superclass, they will override the superclass’s methods.</p>
<p class="indent">Call the methods by adding this code to <em>birdClass.py</em>:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs">sarahThePenguin.fly()<br/>sarahThePenguin.birdcall()</p>
<p class="indent">Now when you run the program, you’ll get this output:</p>
<p class="programs"><span class="blue1">Penguins cannot fly :(</span><br/><span class="blue1">sort of a quack</span></p>
<p class="indent">Overriding a method from a superclass will change what the method does for the subclass but not the superclass. So penguins won’t be able to fly, but other birds that inherit from <span class="literal">Bird</span> will still be able to fly.</p>
<p class="indent">You can also overwrite the <span class="literal">__init__()</span> method in a subclass. This means that when the subclass object is created, it can have different attributes or behaviors than the superclass.</p>
<p class="indent">For example, let’s create a <span class="literal">Parrot</span> subclass of <span class="literal">Bird</span> in the same file. Parrots can be different colors, so let’s include an extra argument in the <span class="literal">__init__()</span> method for a <span class="literal">color</span> attribute:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs">   <span class="orange">class</span> <span class="blue1">Parrot</span>(Bird):<br/><span class="ent">➊</span>     <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, wingspan, color):<br/>           self.name = name<br/>           self.wingspan = wingspan<br/>           self.color = color</p>
<p class="indent"><span epub:type="pagebreak" id="page_283"></span>I’ve included a new <span class="literal">__init__()</span> method for the <span class="literal">Parrot</span> class that has an extra argument, <span class="literal">color</span> <span class="ent">➊</span>, when compared to the original <span class="literal">Bird</span> class.</p>
<p class="indent">Now when we create a new <span class="literal">Parrot</span> object, we can access the <span class="literal">color</span> attribute. We can also access the <span class="literal">birdcall()</span> and <span class="literal">fly()</span> methods because they were inherited from the <span class="literal">Bird</span> superclass:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs">freddieTheParrot = Parrot(<span class="green">"Freddie"</span>, 12, <span class="green">"blue"</span>)<br/><span class="rose">print</span>(freddieTheParrot.color)<br/>freddieTheParrot.fly()<br/>freddieTheParrot.birdcall()</p>
<p class="indent">This code will output the following:</p>
<p class="programs"><span class="blue1">blue</span><br/><span class="blue1">flap</span><br/><span class="blue1">chirp</span></p>
<p class="indent">Remember that you can overwrite any method that a subclass inherits from a superclass; you can even overwrite the <span class="literal">__init__()</span> method. This gives you a lot of control over objects and their many attributes and methods.</p>
<p class="indent">After all the changes we’ve made to <em>birdClass.py</em>, the final program looks like the following. It’s also available in the book’s resources at <em><a href="https://www.nostarch.com/programwithminecraft/">https://www.nostarch.com/programwithminecraft/</a></em>.</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<p class="programs"><span class="orange">class</span> <span class="blue1">Bird</span>(<span class="rose">object</span>):<br/>    <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, wingspan):<br/>        self.name = name<br/>        self.wingspan = wingspan<br/><br/>    <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"chirp"</span>)<br/><br/>    <span class="orange">def</span> <span class="blue1">fly</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"flap"</span>)<br/><br/><br/><span class="orange">class</span> <span class="blue1">Penguin</span>(Bird):<br/>    <span class="orange">def</span> <span class="blue1">swim</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"swimming"</span>)<br/><br/>    <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"sort of a quack"</span>)<br/><br/>    <span class="orange">def</span> <span class="blue1">fly</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"Penguins cannot fly :("</span>)<br/><br/><br/><span class="orange">class</span> <span class="blue1">Parrot</span>(Bird):<br/>    <span class="orange">def</span> <span class="blue1">__init_</span>_(self, name, wingspan, color):<br/>        self.name = name<br/>        self.wingspan = wingspan<br/>        self.color = color<br/><br/>gardenBird = Bird(<span class="green">"Geoffrey"</span>, 12)<br/>gardenBird.birdcall()<br/>gardenBird.fly()<br/><br/>sarahThePenguin = Penguin(<span class="green">"Sarah"</span>, 10)<br/>sarahThePenguin.swim()<br/>sarahThePenguin.fly()<br/>sarahThePenguin.birdcall()<br/><br/>freddieTheParrot = Parrot(<span class="green">"Freddie"</span>, 12, <span class="green">"blue"</span>)<br/><span class="rose">print</span>(freddieTheParrot.color)<br/>freddieTheParrot.fly()<br/>freddieTheParrot.birdcall()</p>
<p class="indent"><span epub:type="pagebreak" id="page_284"></span>You’ll try overriding methods and attributes in the next mission.</p>
<h4 class="h4a" id="ch12lev2sec10"><strong>Mission #73: Ghost Tree</strong></h4>
<p class="noindent">You’ve created several forms of ghost buildings. Let’s take it to the next level and create a ghost tree. That’s an amazing idea, but how can we do it? The <span class="literal">Building</span> class is for buildings, which have walls and ceilings—trees don’t have walls or ceilings. Worry not! You can work around this by modifying your ghost <span class="literal">Building</span> class.</p>
<p class="indent">Like the ghost buildings, the ghost tree will appear and disappear using the <span class="literal">build()</span> and <span class="literal">clear()</span> methods. But the methods need to work differently because trees look different from houses. So, you need to create a class that inherits from the <span class="literal">Building</span> class and then override the <span class="literal">build()</span> and <span class="literal">clear()</span> methods.</p>
<p class="indent">To get you started, I’ve grabbed the function that creates a tree from the <em>forest.py</em> file (<a href="ch08.xhtml#page_153">page 153</a>) and put it in <a href="ch12.xhtml#ch12ex6">Listing 12-6</a>. Copy it into a new file called <em>ghostTree.py</em> in the <em>classes</em> folder.</p>
<p class="sidenote"><span class="blue"><em>ghostTree.py</em></span></p>
<p class="programs">   <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br/>   mc = Minecraft.create()<br/><br/>   <span class="red"># Paste the ghostHouse.py program here</span><br/>   <span class="red"># Create a Tree class here</span><br/><br/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue1">growTree</span>(x, y, z):<br/>       <span class="green">""" Creates a tree at the coordinates given """</span><br/>       wood = 17<br/>       leaves = 18<br/><br/>       <span class="red"># Trunk</span><br/>       mc.setBlocks(x, y, z, x, y + 5, z, wood)<br/><br/>       <span class="red"># Leaves</span><br/>       mc.setBlocks(x - 2, y + 6, z - 2, x + 2, y + 6, z + 2, leaves)<br/>       mc.setBlocks(x - 1, y + 7, z - 1, x + 1, y + 7, z + 1, leaves)<br/><br/><span class="red"># Create build() and clear() methods for the Tree class here</span></p>
<p class="examplet"><a id="ch12ex6"></a><em>Listing 12-6: A function to create a tree</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_285"></span>To finish the program, copy and paste the code for the <span class="literal">Building</span> class from <em>ghostHouse.py</em> into the new file. Then create a new class called <span class="literal">Tree</span> that inherits from the <span class="literal">Building</span> class. Inside the <span class="literal">Tree</span> class, add a <span class="literal">build()</span> method and a <span class="literal">clear()</span> method to override the methods from the <span class="literal">Building</span> class and build a tree instead of a house. Make sure you include the <span class="literal">self</span> argument in front of the attributes in the final <span class="literal">growTree()</span> method <span class="ent">➊</span>.</p>
<p class="indent">After you’ve created the program, make a <span class="literal">Tree</span> object called <span class="literal">ghostTree</span>. Call the <span class="literal">build()</span> method to make the tree appear, wait a bit, and then make it vanish using <span class="literal">clear()</span>.</p>
<p class="indent"><a href="ch12.xhtml#ch12fig7">Figure 12-7</a> shows the result of my program.</p>
<div class="image"><img alt="image" src="../images/f12-07.jpg"/></div>
<p class="figcap"><a id="ch12fig7"></a><em>Figure 12-7: That’s a spooky tree!</em></p>
<div class="sidebar">
<p class="sidebart" id="ch12sb05"><span epub:type="pagebreak" id="page_286"></span><strong>BONUS OBJECTIVE: GHOST FOREST</strong></p>
<p class="noindent">Modify the code in <em>ghostTree.py</em> to build a ghost forest. What kinds of treasures do you think you could find in a ghost forest?</p>
</div>
<h3 class="h3" id="ch12lev1sec09"><strong><span class="blue1">What You Learned</span></strong></h3>
<p class="noindent">You just learned the basics of one of the most important concepts in programming today: object-oriented programming! You learned how to write a class and create objects, and you learned how to use inheritance to customize classes and object behavior. You’ll be able to apply this very useful skill not only in Minecraft but also in any kind of programming adventure that you choose to go on to next!</p>
</body>
</html>