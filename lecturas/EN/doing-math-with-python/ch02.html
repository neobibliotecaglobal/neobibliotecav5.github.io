<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>Chapter 2: Visualizing Data with Graphs</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><h2 class="h2" id="ch02"><a id="page_27"></a><strong><span class="big">2</span></strong><br/><strong>Visualizing Data with Graphs</strong></h2>
<div class="image1"><img src="images/common-01.jpg" alt="image" /></div>
<p class="noindent">In this chapter, you’ll learn a powerful way to present numerical data: by drawing graphs with Python. We’ll start by discussing the number line and the Cartesian plane. Next, we’ll learn about the powerful plotting library <em>matplotlib</em> and how we can use it to create graphs. We’ll then explore how to make graphs that present data clearly and intuitively. Finally, we’ll use graphs to explore Newton’s law of universal gravitation and projectile motion. Let’s get started!</p>
<h3 class="h3" id="ch02lev1sec01"><a id="page_28"></a><strong>Understanding the Cartesian Coordinate Plane</strong></h3>
<p class="noindent">Consider a <em>number line</em>, like the one shown in <a href="ch02.html#ch2fig1">Figure 2-1</a>. Integers from –3 to 3 are marked on the line, but between any of these two numbers (say, 1 and 2) lie all possible numbers in between: 1.1, 1.2, 1.3, and so on.</p>
<div class="image"><img src="images/f02-01.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig1"></a><em>Figure 2-1: A number line</em></p>
<p class="indent">The number line makes certain properties visually intuitive. For example, all numbers on the right side of 0 are positive, and those on the left side are negative. When a number <em>a</em> lies on the right side of another number <em>b</em>, <em>a</em> is always greater than <em>b</em> and <em>b</em> is always less than <em>a</em>.</p>
<p class="indent">The arrows at the ends of the number line indicate that the line extends infinitely, and any point on this line corresponds to some real number, however large it may be. A single number is sufficient to describe a point on the number line.</p>
<p class="indent">Now consider two number lines arranged as shown in <a href="ch02.html#ch2fig2">Figure 2-2</a>. The number lines intersect at right angles to each other and cross at the 0 point of each line. This forms a <em>Cartesian coordinate plane</em>, or an <em>x</em>-<em>y</em> plane, with the horizontal number line called the <em>x</em>-axis and the vertical line called the <em>y</em>-axis.</p>
<div class="image"><img src="images/f02-02.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig2"></a><em>Figure 2-2: The Cartesian coordinate plane</em></p>
<p class="indent">As with the number line, we can have infinitely many points on the plane. We describe a point with a pair of numbers instead of one number. For example, we describe the point <em>A</em> in the figure with two numbers, <em>x</em> and <em>y</em>, usually written as (<em>x</em>, <em>y</em>) and referred to as the <em>coordinates</em> of the point. <a id="page_29"></a>As shown in <a href="ch02.html#ch2fig2">Figure 2-2</a>, <em>x</em> is the distance of the point from the origin along the <em>x</em>-axis, and <em>y</em> is the distance along the <em>y</em>-axis. The point where the two axes intersect is called the <em>origin</em> and has the coordinates (0, 0).</p>
<p class="indent">The Cartesian coordinate plane allows us to visualize the relationship between two sets of numbers. Here, I use the term <em>set</em> loosely to mean a collection of numbers. (We’ll learn about mathematical sets and how to work with them in Python in <a href="ch05.html#ch05">Chapter 5</a>.) No matter what the two sets of numbers represent—temperature, baseball scores, or class test scores—all you need are the numbers themselves. Then, you can plot them—either on graph paper or on your computer with a program written in Python. For the rest of this book, I’ll use the term <em>plot</em> as a verb to describe the act of plotting two sets of numbers and the term <em>graph</em> to describe the result—a line, curve, or simply a set of points on the Cartesian plane.</p>
<h3 class="h3" id="ch02lev1sec02"><strong>Working with Lists and Tuples</strong></h3>
<p class="noindent">As we make graphs with Python, we’ll work with <em>lists</em> and <em>tuples</em>. In Python, these are two different ways to store groups of values. Tuples and lists are very similar for the most part, with one major difference: after you create a list, it’s possible to add values to it and to change the order of the values. The values in a tuple, on the other hand, are immediately fixed and can’t be changed. We’ll use lists to store <em>x</em>- and <em>y</em>-coordinates for the points we want to plot. Tuples will come up in “<a href="ch02.html#ch02lev2sec05">Customizing Graphs</a>” on <a href="ch02.html#page_41">page 41</a> when we learn to customize the range of our graphs. First, let’s go over some features of lists.</p>
<p class="indent">You can create a list by entering values, separated by commas, between square brackets. The following statement creates a list and uses the label <span class="literal">simplelist</span> to refer to it:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">simplelist = [1, 2, 3]</span></p>
<p class="indent">Now you can refer to the individual numbers—1, 2, and 3—using the label and the position of the number in the list, which is called the <em>index</em>. So <span class="literal">simplelist[0]</span> refers to the first number, <span class="literal">simplelist[1]</span> refers to the second number, and <span class="literal">simplelist[2]</span> refers to the third number:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">simplelist[0]</span><br/>1<br/>&gt;&gt;&gt; <span class="codestrong">simplelist[1]</span><br/>2<br/>&gt;&gt;&gt; <span class="codestrong">simplelist[2]</span><br/>3</p>
<p class="indent">Notice that the first item of the list is at index 0, the second item is at index 1, and so on—that is, the positions in the list start counting from 0, not 1.</p>
<p class="indent"><a id="page_30"></a>Lists can store strings, too:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">stringlist = ['a string','b string','c string']</span><br/>&gt;&gt;&gt; <span class="codestrong">stringlist[0]</span><br/>'a string'<br/>&gt;&gt;&gt; <span class="codestrong">stringlist[1]</span><br/>'b string'<br/>&gt;&gt;&gt; <span class="codestrong">stringlist[2]</span><br/>'c string'</p>
<p class="indent">One advantage of creating a list is that you don’t have to create a separate label for each value; you just create a label for the list and use the index position to refer to each item. Also, you can add to the list whenever you need to store new values, so a list is the best choice for storing data if you don’t know beforehand how many numbers or strings you may need to store.</p>
<p class="indent">An <em>empty list</em> is just that—a list with no items or elements—and it can be created like this:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">emptylist = []</span></p>
<p class="indent">Empty lists are mainly useful when you don’t know any of the items that will be in your list beforehand but plan to fill in values during the execution of a program. In that case, you can create an empty list and then use the <span class="literal">append()</span> method to add items later:</p>
<p class="programs"><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">emptylist</span><br/>   []<br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong">emptylist.append(1)</span><br/>   &gt;&gt;&gt; <span class="codestrong">emptylist</span><br/>   [1]<br/><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong">emptylist.append(2)</span><br/>   &gt;&gt;&gt; <span class="codestrong">emptylist</span><br/><span class="ent">➍</span> [1, 2]</p>
<p class="indent">At <span class="ent">➊</span>, <span class="literal">emptylist</span> starts off empty. Next, we append the number 1 to the list at <span class="ent">➋</span> and then append 2 at <span class="ent">➌</span>. By line <span class="ent">➍</span>, the list is now [1, 2]. Note that when you use <span class="literal">.append()</span>, the value gets added to the end of the list. This is just one way of adding values to a list. There are others, but we won’t need them for this chapter.</p>
<p class="indent">Creating a tuple is similar to creating a list, but instead of square brackets, you use parentheses:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">simpletuple = (1, 2, 3)</span></p>
<p class="indent">You can refer to an individual number in <span class="literal">simpletuple</span> using the corresponding index in brackets, just as with lists:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">simpletuple[0]</span><br/>1<br/><a id="page_31"></a><br/>&gt;&gt;&gt; <span class="codestrong">simpletuple[1]</span><br/>2<br/>&gt;&gt;&gt; <span class="codestrong">simpletuple[2]</span><br/>3</p>
<p class="indent">You can also use <em>negative indices</em> with both lists and tuples. For example, <span class="literal">simplelist[-1]</span> and <span class="literal">simpletuple[-1]</span> would refer to the last element of the list or the tuple, <span class="literal">simplelist[-2]</span> and <span class="literal">simpletuple[-2]</span> would refer to the second-to-last element, and so on.</p>
<p class="indent">Tuples, like lists, can have strings as values, and you can create an <em>empty tuple</em> with no elements as <span class="literal">emptytuple=()</span>. However, there’s no <span class="literal">append()</span> method to add a new value to an existing tuple, so you can’t add values to an empty tuple. Once you create a tuple, the contents of the tuple can’t be changed.</p>
<h4 class="h4" id="ch02lev2sec01"><strong><em>Iterating over a List or Tuple</em></strong></h4>
<p class="noindent">We can go over a list or tuple using a <span class="literal">for</span> loop as follows:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">l = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">for item in l:</span><br/>        <span class="codestrong">print(item)</span></p>
<p class="indent">This will print the items in the list:</p>
<p class="programs">1<br/>2<br/>3</p>
<p class="indent">The items in a tuple can be retrieved in the same way.</p>
<p class="indent">Sometimes you might need to know the position or the index of an item in a list or tuple. You can use the <span class="literal">enumerate()</span> function to iterate over all the items of a list and return the index of an item as well as the item itself. We use the labels <span class="literal">index</span> and <span class="literal">item</span> to refer to them:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">l = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">for index, item in enumerate(l):</span><br/>        <span class="codestrong">print(index, item)</span></p>
<p class="indent">This will produce the following output:</p>
<p class="programs">0 1<br/>1 2<br/>2 3</p>
<p class="indent">This also works for tuples.</p>
<h3 class="h3" id="ch02lev1sec03"><a id="page_32"></a><strong>Creating Graphs with Matplotlib</strong></h3>
<p class="noindent">We’ll be using matplotlib to make graphs with Python. Matplotlib is a Python <em>package</em>, which means that it’s a collection of modules with related functionality. In this case, the modules are useful for plotting numbers and making graphs. Matplotlib doesn’t come built in with Python’s standard library, so you’ll have to install it. The installation instructions are covered in <a href="app01.html#app01">Appendix A</a>. Once you have it installed, start a Python shell. As explained in the installation instructions, you can either continue using IDLE shell or use Python’s built-in shell.</p>
<p class="indent">Now we’re ready to create our first graph. We’ll start with a simple graph with just three points: (1, 2), (2, 4), and (3, 6). To create this graph, we’ll first make two lists of numbers—one storing the values of the <em>x</em>-coordinates of these points and another storing the <em>y</em>-coordinates. The following two statements do exactly that, creating the two lists <span class="literal">x_numbers</span> and <span class="literal">y_numbers</span>:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">x_numbers = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">y_numbers = [2, 4, 6]</span></p>
<p class="indent">From here, we can create the plot:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from pylab import plot, show</span><br/>&gt;&gt;&gt; <span class="codestrong">plot(x_numbers, y_numbers)</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f83ac60df10&gt;]</p>
<p class="indent">In the first line, we import the <span class="literal">plot()</span> and <span class="literal">show()</span> functions from the <span class="literal">pylab</span> module, which is part of the matplotlib package. Next, we call the <span class="literal">plot()</span> function in the second line. The first argument to the <span class="literal">plot()</span> function is the list of numbers we want to plot on the <em>x</em>-axis, and the second argument is the corresponding list of numbers we want to plot on the <em>y</em>-axis. The <span class="literal">plot()</span> function returns an object—or more precisely, a list containing an object. This object contains the information about the graph that we asked Python to create. At this stage, you can add more information, such as a title, to the graph, or you can just display the graph as it is. For now we’ll just display the graph.</p>
<p class="indent">The <span class="literal">plot()</span> function only creates the graph. To actually display it, we have to call the <span class="literal">show()</span> function:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">show()</span></p>
<p class="indent">You should see the graph in a matplotlib window as shown in <a href="ch02.html#ch2fig3">Figure 2-3</a>. (The display window may look different depending on your operating system, but the graph should be the same.)</p>
<div class="image"><a id="page_33"></a><img src="images/f02-03.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig3"></a><em>Figure 2-3: A graph showing a line passing through the points (1, 2), (2, 4), and (3, 6)</em></p>
<p class="indent">Notice that instead of starting from the origin (0, 0), the <em>x</em>-axis starts from the number 1 and the <em>y</em>-axis starts from the number 2. These are the lowest numbers from each of the two lists. Also, you can see increments marked on each of the axes (such as 2.5, 3.0, 3.5, etc., on the <em>y</em>-axis). In “<a href="ch02.html#ch02lev2sec05">Customizing Graphs</a>” on <a href="ch02.html#page_41">page 41</a>, we’ll learn how to control those aspects of the graph, along with how to add axes labels and a graph title.</p>
<p class="indent">You’ll notice in the interactive shell that you can’t enter any further statements until you close the matplotlib window. Close the graph window so that you can continue programming.</p>
<h4 class="h4" id="ch02lev2sec02"><strong><em>Marking Points on Your Graph</em></strong></h4>
<p class="noindent">If you want the graph to mark the points that you supplied for plotting, you can use an additional keyword argument while calling the <span class="literal">plot()</span> function:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">plot(x_numbers, y_numbers, marker='o')</span></p>
<p class="indent"><a id="page_34"></a>By entering <span class="literal">marker='o'</span>, we tell Python to mark each point from our lists with a small dot that looks like an <em>o</em>. Once you enter <span class="literal">show()</span> again, you’ll see that each point is marked with a dot (see <a href="ch02.html#ch2fig4">Figure 2-4</a>).</p>
<div class="image"><img src="images/f02-04.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig4"></a><em>Figure 2-4: A graph showing a line passing through the points (1, 2), (2, 4), and (3, 6) with the points marked by a dot</em></p>
<p class="indent">The marker at (2, 4) is easily visible, while the others are hidden in the very corners of the graph. You can choose from several <span class="literal">marker</span> options, including <span class="literal">'o'</span>, <span class="literal">'*'</span>, <span class="literal">'x'</span>, and <span class="literal">'+'</span>. Using <span class="literal">marker=</span> includes a line connecting the points (this is the default). You can also make a graph that marks only the points that you specified, without any line connecting them, by omitting <span class="literal">marker=</span>:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">plot(x_numbers, y_numbers, 'o')</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f2549bc0bd0&gt;]</p>
<p class="indent">Here, <span class="literal">'o'</span> indicates that each point should be marked with a dot, but there should be no line connecting the points. Call the function <span class="literal">show()</span> to display the graph, which should look like the one shown in <a href="ch02.html#ch2fig5">Figure 2-5</a>.</p>
<div class="image"><a id="page_35"></a><img src="images/f02-05.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig5"></a><em>Figure 2-5: A graph showing the points (1, 2), (2, 4), and (3, 6)</em></p>
<p class="indent">As you can see, only the points are now shown on the graph, with no line connecting them. As in the previous graph, the first and the last points are barely visible, but we’ll soon see how to change that.</p>
<h4 class="h4" id="ch02lev2sec03"><strong><em>Graphing the Average Annual Temperature in New York City</em></strong></h4>
<p class="noindent">Let’s take a look at a slightly larger set of data so we can explore more features of matplotlib. The average annual temperatures for New York City— measured at Central Park, specifically—during the years 2000 to 2012 are as follows: 53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, and 57.3 degrees Fahrenheit. Right now, that just looks like a random jumble of numbers, but we can plot this set of temperatures on a graph to make the rise and fall in the average temperature from year to year much clearer:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]</span><br/>&gt;&gt;&gt; <span class="codestrong">plot(nyc_temp, marker='o')</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f2549d52f90&gt;]</p>
<p class="indent"><a id="page_36"></a>We store the average temperatures in a list, <span class="literal">nyc_temp</span>. Then, we call the function <span class="literal">plot()</span> passing only this list (and the marker string). When you use <span class="literal">plot()</span> on a single list, those numbers are automatically plotted on the <em>y</em>-axis. The corresponding values on the <em>x</em>-axis are filled in as the positions of each value in the list. That is, the first temperature value, 53.9, gets a corresponding <em>x</em>-axis value of 0 because it’s in position 0 of the list (remember, the list position starts counting from 0, not 1). As a result, the numbers plotted on the <em>x</em>-axis are the integers from 0 to 12, which we can think of as corresponding to the 13 years for which we have temperature data.</p>
<p class="indent">Enter <span class="literal">show()</span> to display the graph, which is shown in <a href="ch02.html#ch2fig6">Figure 2-6</a>. The graph shows that the average temperature has risen and fallen from year to year. If you glance at the numbers we plotted, they really aren’t very far apart from each other. However, the graph makes the variations seem rather dramatic. So, what’s going on? The reason is that matplotlib chooses the range of the <em>y</em>-axis so that it’s just enough to enclose the data supplied for plotting. So in this graph, the <em>y</em>-axis starts at 53.0 and its highest value is 57.5. This makes even small differences look magnified because the range of the <em>y</em>-axis is so small. We’ll learn how to control the range of each axis in “<a href="ch02.html#ch02lev2sec05">Customizing Graphs</a>” on <a href="ch02.html#page_41">page 41</a>.</p>
<div class="image"><img src="images/f02-06.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig6"></a><em>Figure 2-6: A graph showing the average annual temperature of New York City during the years 2000–2012</em></p>
<p class="indent"><a id="page_37"></a>You can also see that numbers on the <em>y</em>-axis are floating point numbers (because that’s what we asked to be plotted) and those on the <em>x</em>-axis are integers. Matplotlib can handle either.</p>
<p class="indent">Plotting the temperature without showing the corresponding years is a quick and easy way to visualize the variations between the years. If you were planning to present this graph to someone, however, you’d want to make it clearer by showing which year each temperature corresponds to. We can easily do this by creating another list with the years in it and then calling the <span class="literal">plot()</span> function:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]</span><br/>&gt;&gt;&gt; <span class="codestrong">years = range(2000, 2013)</span><br/>&gt;&gt;&gt; <span class="codestrong">plot(years, nyc_temp, marker='o')</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f2549a616d0&gt;]<br/>&gt;&gt;&gt; <span class="codestrong">show()</span></p>
<p class="indent">We use the <span class="literal">range()</span> function we learned about in <a href="ch01.html#ch01">Chapter 1</a> to specify the years 2000 to 2012. Now you’ll see the years displayed on the <em>x</em>-axis (see <a href="ch02.html#ch2fig7">Figure 2-7</a>).</p>
<div class="image"><img src="images/f02-07.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig7"></a><em>Figure 2-7: A graph showing the average annual temperature of New York City, displaying the years on the</em> x-<em>axis</em></p>
<h4 class="h4" id="ch02lev2sec04"><a id="page_38"></a><strong><em>Comparing the Monthly Temperature Trends of New York City</em></strong></h4>
<p class="noindent">While still looking at New York City, let’s see how the average monthly temperature has varied over the years. This will give us a chance to understand how to plot multiple lines on a single graph. We’ll choose three years: 2000, 2006, and 2012. For each of these years, we’ll plot the average temperature for all 12 months.</p>
<p class="indent">First, we need to create three lists to store the temperature (in Fahrenheit). Each list will consist of 12 numbers corresponding to the average temperature from January to December each year:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">nyc_temp_2000 = [31.3, 37.3, 47.2, 51.0, 63.5, 71.3, 72.3, 72.7, 66.0, 57.0, 45.3, 31.1]</span><br/>&gt;&gt;&gt; <span class="codestrong">nyc_temp_2006 = [40.9, 35.7, 43.1, 55.7, 63.1, 71.0, 77.9, 75.8, 66.6, 56.2, 51.9, 43.6]</span><br/>&gt;&gt;&gt; <span class="codestrong">nyc_temp_2012 = [37.3, 40.9, 50.9, 54.8, 65.1, 71.0, 78.8, 76.7, 68.8, 58.0, 43.9, 41.5]</span></p>
<p class="indent">The first list corresponds to the year 2000, and the next two lists correspond to the years 2006 and 2012, respectively. We could plot the three sets of data on three different graphs, but that wouldn’t make it very easy to see how each year compares to the others. Try doing it!</p>
<p class="indent">The clearest way to compare all of these temperatures is to plot all three data sets on a <em>single</em> graph, like this:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">months = range(1, 13)</span><br/>&gt;&gt;&gt; <span class="codestrong">plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f2549c1f0d0&gt;, &lt;matplotlib.lines.Line2D<br/>object at 0x7f2549a61150&gt;, &lt;matplotlib.lines.Line2D object at 0x7f2549c1b550&gt;]</p>
<p class="indent">First, we create a list (<span class="literal">months</span>) where we store the numbers 1, 2, 3, and so on up to 12 using the <span class="literal">range()</span> function. Next, we call the <span class="literal">plot()</span> function with three pairs of lists. Each pair consists of a list of months to be plotted on the <em>x</em>-axis and a list of average monthly temperatures (for 2000, 2006, and 2012, respectively) to be plotted on the <em>y</em>-axis. So far, we’ve used <span class="literal">plot()</span> on only one pair of lists at a time, but you can actually enter multiple pairs of lists into the <span class="literal">plot()</span> function. With each list separated by a comma, the <span class="literal">plot()</span> function will automatically plot a different line for each pair.</p>
<p class="indent">The <span class="literal">plot()</span> function returns a list of three objects instead of one. Matplotlib considers the three curves as distinct from each other, and it knows to draw them on top of each other when you call <span class="literal">show()</span>. Let’s call <span class="literal">show()</span> to display the graph, as shown in <a href="ch02.html#ch2fig8">Figure 2-8</a>.</p>
<div class="image"><a id="page_39"></a><img src="images/f02-08.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig8"></a><em>Figure 2-8: A graph showing the average monthly temperature of New York City during the years 2000, 2006, and 2012</em></p>
<p class="indent">Now we have three plots all on one graph. Python automatically chooses a different color for each line to indicate that the lines have been plotted from different data sets.</p>
<p class="indent">Instead of calling the plot function with all three pairs at once, we could also call the plot function three separate times, once for each pair:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">plot(months, nyc_temp_2000)</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f1e51351810&gt;]<br/>&gt;&gt;&gt; <span class="codestrong">plot(months, nyc_temp_2006)</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f1e5ae8e390&gt;]<br/>&gt;&gt;&gt; <span class="codestrong">plot(months, nyc_temp_2012)</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f1e5136ccd0&gt;]<br/>&gt;&gt;&gt; <span class="codestrong">show()</span></p>
<p class="indent">Matplotlib keeps track of what plots haven’t been displayed yet. So as long as we wait to call <span class="literal">show()</span> until after we call <span class="literal">plot()</span> all three times, the plots will all get displayed on the same graph.</p>
<p class="indent"><a id="page_40"></a>We have a problem, however, because we don’t have any clue as to which color corresponds to which year. To fix this, we can use the function <span class="literal">legend()</span>, which lets us add a legend to the graph. A <em>legend</em> is a small display box that identifies what different parts of the graph mean. Here, we’ll use a legend to indicate which year each colored line stands for. To add the legend, first call the <span class="literal">plot()</span> function as earlier:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f2549d6c410&gt;, &lt;matplotlib.lines.Line2D<br/>object at 0x7f2549d6c9d0&gt;, &lt;matplotlib.lines.Line2D object at 0x7f2549a86850&gt;]</p>
<p class="indent">Then, import the <span class="literal">legend()</span> function from the <span class="literal">pylab</span> module and call it as follows:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from pylab import legend</span><br/>&gt;&gt;&gt; <span class="codestrong">legend([2000, 2006, 2012])</span><br/>&lt;matplotlib.legend.Legend object at 0x7f2549d79410&gt;</p>
<p class="indent">We call the <span class="literal">legend()</span> function with a list of the labels we want to use to identify each plot on the graph. These labels are entered in this order to match the order of the pairs of lists that were entered in the <span class="literal">plot()</span> function. That is, <span class="literal">2000</span> will be the label for the plot of the first pair we entered in the <span class="literal">plot()</span> function; <span class="literal">2006</span>, for the second pair; and <span class="literal">2012</span>, for the third. You can also specify a second argument to the function that will specify the position of the legend. By default, it’s always positioned at the top right of the graph. However, you can specify a particular position, such as <span class="literal">'lower center'</span>, <span class="literal">'center left'</span>, and <span class="literal">'upper left'</span>. Or you can set the position to <span class="literal">'best'</span>, and the legend will be positioned so as not to interfere with the graph.</p>
<p class="indent">Finally, we call <span class="literal">show()</span> to display the graph:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">show()</span></p>
<p class="indent">As you can see in the graph (see <a href="ch02.html#ch2fig9">Figure 2-9</a>), there’s now a legend box in the top-right corner. It tells us which line represents the average monthly temperature for the year 2000, which line represents the year 2006, and which line represents the year 2012.</p>
<p class="indent">Looking at the graph, you can conclude two interesting facts: the highest temperature for all three years was in and around July (corresponding to 7 on the <em>x</em>-axis), and it has been increasing from 2000 with a more dramatic rise between 2000 and 2006. Having all three lines plotted together in one graph makes it a lot easier to see these kinds of relationships. It’s certainly clearer than just looking at a few long lists of numbers or even looking at three lines plotted on three separate graphs.</p>
<div class="image"><a id="page_41"></a><img src="images/f02-09.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig9"></a><em>Figure 2-9: A graph showing the average monthly temperature of New York City, with a legend to show the year each color corresponds to</em></p>
<h4 class="h4" id="ch02lev2sec05"><strong><em>Customizing Graphs</em></strong></h4>
<p class="noindent">We already learned about one way to customize a graph—by adding a legend. Now, we’ll learn about other ways to customize a graph and to make it clearer by adding labels to the <em>x</em>- and <em>y</em>-axes, adding a title to the graph, and controlling the range and steps of the axes.</p>
<h5 class="h5" id="ch02lev3sec01"><strong>Adding a Title and Labels</strong></h5>
<p class="noindent">We can add a title to our graph using the <span class="literal">title()</span> function and add labels for the <em>x</em>- and <em>y</em>-axes using the <span class="literal">xlabel()</span> and <span class="literal">ylabel()</span> functions. Let’s re-create the last plot and add all this additional information:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from pylab import plot, show, title, xlabel, ylabel, legend</span><br/>&gt;&gt;&gt; <span class="codestrong">plot(months, nyc_temp_2000, months, nyc_temp_2006, months, nyc_temp_2012)</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f2549a9e210&gt;, &lt;matplotlib.lines.Line2D<br/>object at 0x7f2549a4be90&gt;, &lt;matplotlib.lines.Line2D object at 0x7f2549a82090&gt;]<br/>&gt;&gt;&gt; <span class="codestrong">title('Average monthly temperature in NYC')</span><br/>&lt;matplotlib.text.Text object at 0x7f25499f7150&gt;<br/>&gt;&gt;&gt; <span class="codestrong">xlabel('Month')</span><br/>&lt;matplotlib.text.Text object at 0x7f2549d79210&gt;<br/>&gt;&gt;&gt; <span class="codestrong">ylabel('Temperature')</span><br/>&lt;matplotlib.text.Text object at 0x7f2549b8b2d0&gt;<br/><a id="page_42"></a><br/>&gt;&gt;&gt; <span class="codestrong">legend([2000, 2006, 2012])</span><br/>&lt;matplotlib.legend.Legend object at 0x7f2549a82910&gt;</p>
<p class="indent">All three functions—<span class="literal">title()</span>, <span class="literal">xlabel()</span>, and <span class="literal">ylabel()</span>—are called with the corresponding text that we want to appear on the graph entered as strings. Calling the <span class="literal">show()</span> function will display the graph with all this newly added information (see <a href="ch02.html#ch2fig10">Figure 2-10</a>).</p>
<div class="image"><img src="images/f02-10.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig10"></a><em>Figure 2-10: Axes labels and a title have been added to the graph.</em></p>
<p class="indent">With the three new pieces of information added, the graph is easier to understand.</p>
<h5 class="h5" id="ch02lev3sec02"><strong>Customizing the Axes</strong></h5>
<p class="noindent">So far, we’ve allowed the numbers on both axes to be automatically determined by Python based on the data supplied to the <span class="literal">plot()</span> function. This may be fine for most cases, but sometimes this automatic range isn’t the clearest way to present the data, as we saw in the graph where we plotted the average annual temperature of New York City (see <a href="ch02.html#ch2fig7">Figure 2-7</a>). There, even small changes in the temperature seemed large because the automatically chosen <em>y</em>-axis range was very narrow. We can adjust the range of the axes using the <span class="literal">axis()</span> function. This function can be used both to retrieve the current range and to set a new range for the axes.</p>
<p class="indent">Consider, once again, the average annual temperature of New York City during the years 2000 to 2012 and create a plot as we did earlier.</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">nyc_temp = [53.9, 56.3, 56.4, 53.4, 54.5, 55.8, 56.8, 55.0, 55.3, 54.0, 56.7, 56.4, 57.3]</span><br/>&gt;&gt;&gt; <span class="codestrong">plot(nyc_temp, marker='o')</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7f3ae5b767d0&gt;]</p>
<p class="indent"><a id="page_43"></a>Now, import the <span class="literal">axis()</span> function and call it:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from pylab import axis</span><br/>&gt;&gt;&gt; <span class="codestrong">axis()</span><br/>(0.0, 12.0, 53.0, 57.5)</p>
<p class="indent">The function returned a tuple with four numbers corresponding to the range for the <em>x</em>-axis (0.0, 12.0) and the <em>y</em>-axis (53.0, 57.5). These are the same range values from the graph that we made earlier. Now, let’s change the <em>y</em>-axis to start from 0 instead of 53.0:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">axis(ymin=0)</span><br/>(0.0, 12.0, 0, 57.5)</p>
<p class="indent">Calling the <span class="literal">axis()</span> function with the new starting value for the <em>y</em>-axis (specified by <span class="literal">ymin=0</span>) changes the range, and the returned tuple confirms it. If you display the graph by calling the <span class="literal">show()</span> function, the <em>y</em>-axis starts at 0, and the differences between the values of the consecutive years look less drastic (see <a href="ch02.html#ch2fig11">Figure 2-11</a>).</p>
<div class="image"><img src="images/f02-11.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig11"></a><em>Figure 2-11: A graph showing the average annual temperature of New York City during the years 2000–2012. The</em> y-<em>axis has been customized to start from 0.</em></p>
<p class="indent"><a id="page_44"></a>Similarly, you can use <span class="literal">xmin</span>, <span class="literal">xmax</span>, and <span class="literal">ymax</span> to set the minimum and maximum values for the <em>x</em>-axis and the maximum value for the <em>y</em>-axis, respectively. If you’re changing all four values, you may find it easier to call the <span class="literal">axis()</span> function with all four range values entered as a list, such as <span class="literal">axis([0, 10, 0, 20])</span>. This would set the range of the <em>x</em>-axis to (0, 10) and that of the <em>y</em>-axis to (0, 20).</p>
<h5 class="h5" id="ch02lev3sec03"><strong>Plotting Using pyplot</strong></h5>
<p class="noindent">The <span class="literal">pylab</span> module is useful for creating plots in an interactive shell, such as the IDLE shell, as we’ve been doing so far. However, when using matplotlib outside of the IDLE shell—for example, as part of a larger program—the <span class="literal">pyplot</span> module is more efficient. Don’t worry—all the methods that you learned about when using <span class="literal">pylab</span> will work the same way with <span class="literal">pyplot</span>.</p>
<p class="indent">The following program recreates the first plot in this chapter using the <span class="literal">pyplot</span> module:</p>
<p class="programs">   '''<br/>   Simple plot using pyplot<br/>   '''<br/><br/><span class="ent">➊</span> import matplotlib.pyplot<br/><br/><span class="ent">➋</span> def create_graph():<br/>       x_numbers = [1, 2, 3]<br/>       y_numbers = [2, 4, 6]<br/><br/>       matplotlib.pyplot.plot(x_numbers, y_numbers)<br/>       matplotlib.pyplot.show()<br/><br/>   if __name__ == '__main__':<br/>       create_graph()</p>
<p class="indent">First, we import the <span class="literal">pyplot</span> module using the statement import matplotlib .pyplot <span class="ent">➊</span>. This means that we’re importing the entire <span class="literal">pyplot</span> module from the matplotlib package. To refer to any function or class definition defined in this module, you’ll have to use the syntax <span class="literal">matplotlib.pyplot.<span class="codeitalic">item</span></span>, where <span class="literal"><span class="codeitalic">item</span></span> is the function or class you want to use.</p>
<p class="indent">This is different from importing a single function or class at a time, which is what we’ve been doing so far. For example, in the first chapter we imported the <span class="literal">Fraction</span> class as <span class="literal">from fractions import Fraction</span>. Importing an entire module is useful when you’re going to use a number of functions from that module. Instead of importing them individually, you can just import the whole module at once and refer to different functions when you need them.</p>
<p class="indent">In the <span class="literal">create_graph()</span> function at <span class="ent">➋</span>, we create the two lists of numbers that we want to plot on the graph and then pass the two lists to the <span class="literal">plot()</span> function, the same way we did before with <span class="literal">pylab</span>. This time, however, we call the function as <span class="literal">matplotlib.pyplot.plot()</span>, which means that we’re calling the <span class="literal">plot()</span> function defined in the <span class="literal">pyplot</span> module of the matplotlib package. Then, we call the <span class="literal">show()</span> function to display the graph. The only difference <a id="page_45"></a>between the way you plot the numbers here compared to what we did earlier is the mechanism of calling the functions.</p>
<p class="indent">To save us some typing, we can import the <span class="literal">pyplot</span> module by entering <span class="literal">import matplotlib.pyplot as plt</span>. Then, we can refer to <span class="literal">pyplot</span> with the label <span class="literal">plt</span> in our programs, instead of having to always type <span class="literal">matplotlib.pyplot</span>:</p>
<p class="programs">'''<br/>Simple plot using pyplot<br/>'''<br/>import matplotlib.pyplot as plt<br/><br/>def create_graph():<br/>    x_numbers = [1, 2, 3]<br/>    y_numbers = [2, 4, 6]<br/>    plt.plot(x_numbers, y_numbers)<br/>    plt.show()<br/><br/>if __name__ == '__main__':<br/>    create_graph()</p>
<p class="indent">Now, we can call the functions by prefixing them with the shortened <span class="literal">plt</span> instead of <span class="literal">matplotlib.pyplot</span>.</p>
<p class="indent">Going ahead, for the rest of this chapter and this book, we’ll use <span class="literal">pylab</span> in the interactive shell and <span class="literal">pyplot</span> otherwise.</p>
<h4 class="h4" id="ch02lev2sec06"><strong><em>Saving the Plots</em></strong></h4>
<p class="noindent">If you need to save your graphs, you can do so using the <span class="literal">savefig()</span> function. This function saves the graph as an image file, which you can use in reports or presentations. You can choose among several image formats, including PNG, PDF, and SVG.</p>
<p class="indent">Here’s an example:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from pylab import plot, savefig</span><br/>&gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">y = [2, 4, 6]</span><br/>&gt;&gt;&gt; <span class="codestrong">plot(x, y)</span><br/>&gt;&gt;&gt; <span class="codestrong">savefig('mygraph.png')</span></p>
<p class="indent">This program will save the graph to an image file, <em>mygraph.png</em>, in your current directory. On Microsoft Windows, this is usually <em>C:\Python33</em> (where you installed Python). On Linux, the current directory is usually your home directory <em>(/home/&lt;username&gt;</em>), where <em>&lt;username&gt;</em> is the user you’re logged in as. On a Mac, IDLE saves files to <em>~/Documents</em> by default. If you wanted to save it in a different directory, specify the complete pathname. For example, to save the image under <em>C:\</em> on Windows as <em>mygraph.png</em>, you’d call the <span class="literal">savefig()</span> function as follows:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">savefig('C:\mygraph.png')</span></p>
<p class="indent"><a id="page_46"></a>If you open the image in an image-viewing program, you’ll see the same graph you’d see by calling the <span class="literal">show()</span> function. (You’ll notice that the image file contains only the graph—not the entire window that pops up with the <span class="literal">show()</span> function). To specify a different image format, simply name the file with the appropriate extension. For example, <span class="literal">mygraph.svg</span> will create an SVG image file.</p>
<p class="indent">Another way to save a figure is to use the Save button in the window that pops up when you call <span class="literal">show()</span>.</p>
<h3 class="h3" id="ch02lev1sec04"><strong>Plotting with Formulas</strong></h3>
<p class="noindent">Until now, we’ve been plotting points on our graphs based on observed scientific measurements. In those graphs, we already had all our values for <em>x</em> and <em>y</em> laid out. For example, recorded temperatures and dates were already available to us at the time we wanted to create the New York City graph, showing how the temperature varied over months or years. In this section, we’re going to create graphs from mathematical formulas.</p>
<h4 class="h4" id="ch02lev2sec07"><strong><em>Newton’s Law of Universal Gravitation</em></strong></h4>
<p class="noindent">According to Newton’s law of universal gravitation, a body of mass <em>m</em><sub>1</sub> attracts another body of mass <em>m</em><sub>2</sub> with an amount of force <em>F</em> according to the formula</p>
<div class="image2"><img src="images/e0046-01.jpg" alt="image" /></div>
<p class="noindent">where <em>r</em> is the distance between the two bodies and <em>G</em> is the gravitational constant. We want to see what happens to the force as the distance between the two bodies increases.</p>
<p class="indent">Let’s take the masses of two bodies: the mass of the first body (<em>m</em><sub>1</sub>) is 0.5 kg, and the mass of the second body (<em>m</em><sub>2</sub>) is 1.5 kg. The value of the gravitational constant is 6.674 × 10<sup>–11</sup> N m<sup>2</sup> kg<sup>–2</sup>. Now we’re ready to calculate the gravitational force between these two bodies at 19 different distances: 100 m, 150 m, 200 m, 250 m, 300 m, and so on up through 1000 m. The following program performs these calculations and also draws the graph:</p>
<p class="programs">   '''<br/>   The relationship between gravitational force and<br/>   distance between two bodies<br/>   '''<br/><br/>   import matplotlib.pyplot as plt<br/><br/>   # Draw the graph<br/>   def draw_graph(x, y):<br/>       plt.plot(x, y, marker='o')<br/>       plt.xlabel('Distance in meters')<br/><a id="page_47"></a><br/>       plt.ylabel('Gravitational force in newtons')<br/>       plt.title('Gravitational force and distance')<br/>       plt.show()<br/><br/>   def generate_F_r():<br/>       # Generate values for r<br/><span class="ent">➊</span>     r = range(100, 1001, 50)<br/>       # Empty list to store the calculated values of F<br/>       F = []<br/><br/>       # Constant, G<br/>       G = 6.674*(10**-11)<br/>       # Two masses<br/>       m1 = 0.5<br/>       m2 = 1.5<br/><br/>       # Calculate force and add it to the list, F<br/><span class="ent">➋</span>     for dist in r:<br/>           force = G*(m1*m2)/(dist**2)<br/>           F.append(force)<br/><br/>       # Call the draw_graph function<br/><span class="ent">➌</span>     draw_graph(r, F)<br/><br/>   if __name__=='__main__':<br/>       generate_F_r()</p>
<p class="indent">The <span class="literal">generate_F_r()</span> function does most of the work in the program above. At <span class="ent">➊</span>, we use the <span class="literal">range()</span> function to create a list labeled <span class="literal">r</span> with different values for distance, using a step value of 50. The final value is specified as 1001 because we want 1000 to be included as well. We then create an empty list (<span class="literal">F</span>), where we’ll store the corresponding gravitational force at each of these distances. Next, we create labels referring to the gravitational constant (<span class="literal">G</span>) and the two masses (<span class="literal">m1</span> and <span class="literal">m2</span>). Using a <span class="literal">for</span> loop <span class="ent">➋</span>, we then calculate the force at each of the values in the list of distances (<span class="literal">r</span>). We use a label (<span class="literal">force</span>) to refer to the force calculated and to append it to the list (<span class="literal">F</span>). Finally, we call the function <span class="literal">draw_graph()</span> at <span class="ent">➌</span> with the list of distances and the list of the calculated forces. The <em>x</em>-axis of the graph displays the force, and the <em>y</em>-axis displays the distance. The graph is shown in <a href="ch02.html#ch2fig12">Figure 2-12</a>.</p>
<p class="indent">As the distance (<span class="literal">r</span>) increases, the gravitational force decreases. With this kind of relationship, we say that the gravitational force is <em>inversely proportional</em> to the distance between the two bodies. Also, note that when the value of one of the two variables changes, the other variable won’t necessarily change by the same proportion. We refer to this as a <em>nonlinear relationship</em>. As a result, we end up with a curved line on the graph instead of a straight one.</p>
<div class="image"><a id="page_48"></a><img src="images/f02-12.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig12"></a><em>Figure 2-12: Visualization of the relationship between the gravitational force and the squared distance</em></p>
<h4 class="h4" id="ch02lev2sec08"><strong><em>Projectile Motion</em></strong></h4>
<p class="noindent">Now, let’s graph something you’ll be familiar with from everyday life. If you throw a ball across a field, it follows a trajectory like the one shown in <a href="ch02.html#ch2fig13">Figure 2-13</a>.</p>
<div class="image"><img src="images/f02-13.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig13"></a><em>Figure 2-13: Motion of a ball that’s thrown at point</em> A<em>—at an angle (</em>θ<em>) with a velocity (</em><small>U</small><em>)—and that hits the ground at point</em> B</p>
<p class="indent"><a id="page_49"></a>In the figure, the ball is thrown from point <em>A</em> and lands at point <em>B</em>. This type of motion is referred to as <em>projectile</em> motion. Our aim here is to use the equations of projectile motion to graph the trajectory of a body, showing the position of the ball starting from the point it’s thrown until it hits the ground again.</p>
<p class="indent">When you throw the ball, it has an initial velocity and the direction of that velocity creates a certain angle with the ground. Let’s call the initial velocity <em>u</em> and the angle that it makes with the ground <em>θ</em> (theta), as shown in <a href="ch02.html#ch2fig13">Figure 2-13</a>. The ball has two velocity components: one along the <em>x</em> direction, calculated by <em>u<sub>x</sub></em> = <em>u</em> cos<em>θ</em>, and the other along the <em>y</em> direction, where <em>u<sub>y</sub></em> = <em>u</em> sin<em>θ</em>.</p>
<p class="indentb">As the ball moves, its velocity changes, and we will represent that changed velocity using <em>v</em>: the horizontal component is <em>v<sub>x</sub></em> and the vertical component is <em>v<sub>y</sub></em>. For simplicity, assume the horizontal component (<em>v<sub>x</sub></em>) doesn’t change during the motion of the body, whereas the vertical component (<em>v<sub>y</sub></em>) decreases because of the force of gravity according to the equation <em>v<sub>y</sub></em> = <em>u<sub>y</sub> – gt</em>. In this equation, <em>g</em> is the gravitational acceleration and <em>t</em> is the time at which the velocity is measured. Because <em>u<sub>y</sub></em> = <em>u</em> sin<em>θ</em>, we can substitute to get</p>
<p class="center"><em>v<sub>y</sub></em> = <em>u</em> sin<em>θ</em> – <em>gt</em>.</p>
<p class="indentt">Because the horizontal component of the velocity remains constant, the horizontal distance traveled (<em>S<sub>x</sub></em>) is given by <em>S<sub>x</sub></em> = <em>u</em>(cos<em>θ</em>)<em>t</em>. The vertical component of the velocity changes, though, and the vertical distance traveled is given by the formula</p>
<div class="image2"><img src="images/e0049-01.jpg" alt="image" /></div>
<p class="indent">In other words, <em>S<sub>x</sub></em> and <em>S<sub>y</sub></em> give us the <em>x</em>- and <em>y</em>-coordinates of the ball at any given point in time during its flight. We’ll use these equations when we write a program to draw the trajectory. As we use these equations, time (<em>t</em>) will be expressed in seconds, the velocity will be expressed in m/s, the angle of projection (<em>θ</em>) will be expressed in degrees, and the gravitational acceleration (<em>g</em>) will be expressed in m/s<sup>2</sup>.</p>
<p class="indent">Before we write our program, however, we’ll need to find out how long the ball will be in flight before it hits the ground so that we know when our program should stop plotting the trajectory of the ball. To do so, we’ll first find how long the ball takes to reach its highest point. The ball reaches its highest point when the vertical component of the velocity (<em>v<sub>y</sub></em>) is 0, which is when <em>v<sub>y</sub></em> = <em>u</em> sin <em>θ</em> – <em>gt</em> = 0. So we’re looking for the value <em>t</em> using the formula</p>
<div class="image2"><img src="images/e0049-02.jpg" alt="image" /></div>
<p class="indent"><a id="page_50"></a>We’ll call this time <span class="literal">t_peak</span>. After it reaches its highest point, the ball will hit the ground after being airborne for another <span class="literal">t_peak</span> seconds, so the total time of flight (<span class="literal">t_flight</span>) of the ball is</p>
<div class="image2"><img src="images/e0050-01.jpg" alt="image" /></div>
<p class="indent">Let’s take a ball that’s thrown with an initial velocity (<em>u</em>) of 5 m/s at an angle (<em>θ</em>) of 45 degrees. To calculate the total time of flight, we substitute <em>u</em> = 5, <em>θ</em> = 45, and <em>g</em> = 9.8 into the equation we saw above:</p>
<div class="image2"><img src="images/e0050-02.jpg" alt="image" /></div>
<p class="indent">In this case, the time of flight for the ball turns out to be 0.72154 seconds (rounded to five decimal places). The ball will be in air for this period of time, so to draw the trajectory, we’ll calculate its <em>x</em>- and <em>y</em>-coordinates at regular intervals during this time period. How often should we calculate the coordinates? Ideally, as frequently as possible. In this chapter, we’ll calculate the coordinates every 0.001 seconds.</p>
<h5 class="h5" id="ch02lev3sec04"><strong>Generating Equally Spaced Floating Point Numbers</strong></h5>
<p class="noindent">We’ve used the <span class="literal">range()</span> function to generate equally spaced integers— that is, if we wanted a list of integers between 1 and 10 with each integer separated by 1, we would use range(1, 10). If we wanted a different step value, we could specify that to the range function as the third argument. Unfortunately, there’s no such built-in function for floating point numbers. So, for example, there’s no function that would allow us to create a list of the numbers from 0 to 0.72 with two consecutive numbers separated by 0.001. We can use a <span class="literal">while</span> loop as follows to create our own function for this:</p>
<p class="programs">   '''<br/>   Generate equally spaced floating point<br/>   numbers between two given values<br/>   '''<br/><br/>   def frange(start, final, increment):<br/><br/>       numbers = []<br/><span class="ent">➊</span>     while start &lt; final:<br/><span class="ent">➋</span>         numbers.append(start)<br/>           start = start + increment<br/><br/>       return numbers</p>
<p class="indent"><a id="page_51"></a>We’ve defined a function <span class="literal">frange()</span> (“floating point” range) that receives three parameters: <span class="literal">start</span> and <span class="literal">final</span> refer to the starting and the final points of the range of numbers, and <span class="literal">increment</span> refers to the difference between two consecutive numbers. We initialize a <span class="literal">while</span> loop at <span class="ent">➊</span>, which continues execution as long as the number referred to by <span class="literal">start</span> is less than the value for <span class="literal">final</span>. We store the number pointed to by <span class="literal">start</span> in the list <span class="literal">numbers</span> <span class="ent">➋</span> and then add the value we entered as an <span class="literal">increment</span> during every iteration of the loop. Finally, we return the list <span class="literal">numbers</span>.</p>
<p class="indent">We’ll use this function to generate equally spaced time instants in the trajectory-drawing program described next.</p>
<h5 class="h5" id="ch02lev3sec05"><strong>Drawing the Trajectory</strong></h5>
<p class="noindent">The following program draws the trajectory of a ball thrown with a certain velocity and angle—both of which are supplied as input to the program:</p>
<p class="programs">   '''<br/>   Draw the trajectory of a body in projectile motion<br/>   '''<br/><br/>   from matplotlib import pyplot as plt<br/>   import math<br/><br/>   def draw_graph(x, y):<br/>       plt.plot(x, y)<br/>       plt.xlabel('x-coordinate')<br/>       plt.ylabel('y-coordinate')<br/>       plt.title('Projectile motion of a ball')<br/><br/>   def frange(start, final, interval):<br/><br/>       numbers = []<br/>       while start &lt; final:<br/>           numbers.append(start)<br/>           start = start + interval<br/><br/>       return numbers<br/><br/>   def draw_trajectory(u, theta):<br/><br/><span class="ent">➊</span>     theta = math.radians(theta)<br/>       g = 9.8<br/><br/>       # Time of flight<br/><span class="ent">➋</span>     t_flight = 2*u*math.sin(theta)/g<br/>       # Find time intervals<br/>       intervals = frange(0, t_flight, 0.001)<br/><a id="page_52"></a><br/>       # List of x and y coordinates<br/>       x = []<br/>       y = []<br/><span class="ent">➌</span>     for t in intervals:<br/>           x.append(u*math.cos(theta)*t)<br/>           y.append(u*math.sin(theta)*t - 0.5*g*t*t)<br/><br/>       draw_graph(x, y)<br/><br/>   if __name__ == '__main__':<br/><span class="ent">➍</span>     try:<br/>           u = float(input('Enter the initial velocity (m/s): '))<br/>           theta = float(input('Enter the angle of projection (degrees): '))<br/>       except ValueError:<br/>           print('You entered an invalid input')<br/>       else:<br/>           draw_trajectory(u, theta)<br/>           plt.show()</p>
<p class="indent">In this program, we use the functions <span class="literal">radians()</span>, <span class="literal">cos()</span>, and <span class="literal">sin()</span> defined in the standard library’s <span class="literal">math</span> module, so we import that module at the beginning. The <span class="literal">draw_trajectory()</span> function accepts two arguments, <span class="literal">u</span> and <span class="literal">theta</span>, corresponding to the velocity and the angle at which the ball is thrown. The <span class="literal">math</span> module’s sine and the cosine functions expect the angle to be supplied in radians, so at <span class="ent">➊</span>, we convert the angle (<span class="literal">theta</span>) from degrees to radians using the <span class="literal">math.radians()</span> function. Next, we create a label (<span class="literal">g</span>) to refer to the value of acceleration due to gravity, 9.8 m/s<sup>2</sup>. At <span class="ent">➋</span>, we calculate the time of flight and then call the <span class="literal">frange()</span> function with the values for <span class="literal">start</span>, <span class="literal">final</span>, and <span class="literal">increment</span> set to 0, <span class="literal">t_flight</span>, and 0.001, respectively. We then calculate the <em>x</em>- and <em>y</em>-coordinates for the trajectory at each of the time instants and store them in two separate lists, <span class="literal">x</span> and <span class="literal">y</span> <span class="ent">➌</span>. To calculate these coordinates, we use the formulas for the distances <em>S<sub>x</sub></em> and <em>S<sub>y</sub></em> that we discussed earlier.</p>
<p class="indent">Finally, we call the <span class="literal">draw_graph()</span> function with the <em>x</em>- and <em>y</em>-coordinates to draw the trajectory. Note that the <span class="literal">draw_graph()</span> function doesn’t call the <span class="literal">show()</span> function (we’ll see why in the next program). We use a <span class="literal">try...except</span> block <span class="ent">➍</span> to report an error message in case the user enters an invalid input. Valid input for this program is any integer or floating point number. When you run the program, it asks for these values as input and then draws the trajectory (see <a href="ch02.html#ch2fig14">Figure 2-14</a>):</p>
<p class="programs">Enter the initial velocity (m/s): <span class="codestrong">25</span><br/>Enter the angle of projection (degrees): <span class="codestrong">60</span></p>
<div class="image"><a id="page_53"></a><img src="images/f02-14.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig14"></a><em>Figure 2-14: The trajectory of a ball when thrown with a velocity of 25 m/s at an angle of 60 degrees</em></p>
<h5 class="h5" id="ch02lev3sec06"><strong>Comparing the Trajectory at Different Initial Velocities</strong></h5>
<p class="noindent">The previous program allows you to perform interesting experiments. For example, what will the trajectory look like for three balls thrown at different velocities but with the same initial angle? To graph three trajectories at once, we can replace the <span class="literal">main</span> code block from our previous program with the following:</p>
<p class="programs">   if __name__ == '__main__':<br/><br/>       # List of three different initial velocities<br/><span class="ent">➊</span>     u_list = [20, 40, 60]<br/>       theta = 45<br/>       for u in u_list:<br/>           draw_trajectory(u, theta)<br/><br/>       # Add a legend and show the graph<br/><span class="ent">➋</span>     plt.legend(['20', '40', '60'])<br/>       plt.show()</p>
<p class="indent"><a id="page_54"></a>Here, instead of asking the program’s user to enter the velocity and the angle of projection, we create a list (<span class="literal">u_list</span>) with the velocities 20, 40, and 60 at <span class="ent">➊</span> and set the angle of projection as 45 degrees (using the label <span class="literal">theta</span>). We then call the <span class="literal">draw_trajectory()</span> function with each of the three values in <span class="literal">u_list</span> using the same value for <span class="literal">theta</span>, which calculates the list of <em>x</em>- and <em>y</em>-coordinates and calls the <span class="literal">draw_graph()</span> function. When we call the <span class="literal">show()</span> function, all three plots are displayed on the same graph. Because we now have a graph with multiple plots, we add a legend to the graph at <span class="ent">➋</span> before calling <span class="literal">show()</span> to display the velocity for each line. When you run the above program, you’ll see the graph shown in <a href="ch02.html#ch2fig15">Figure 2-15</a>.</p>
<div class="image"><img src="images/f02-15.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig15"></a><em>Figure 2-15: The trajectory of a ball thrown at a 60-degree angle, with a velocity of 20, 40, and 60 m/s</em></p>
<h3 class="h3" id="ch02lev1sec05"><strong>What You Learned</strong></h3>
<p class="noindent">In this chapter, you learned the basics of creating graphs with matplotlib. You saw how to plot a single set of values, how to create multiple plots on the same graph, and how to label various parts of a graph to make it more informative. You used graphs to analyze the temperature variation of a city, study Newton’s law of universal gravitation, and study the projectile motion of a body. In the next chapter, you’ll use Python to start exploring statistics, and you’ll see how drawing a graph can help make the relationships among sets of numbers easier to understand.</p>
<h3 class="h3" id="ch02lev1sec06"><a id="page_55"></a><strong><span class="bordera">Programming Challenges</span></strong></h3>
<p class="noindent">Here are a few challenges that build on what you’ve learned in this chapter. You can find sample solutions at <em><a href="http://www.nostarch.com/doingmathwithpython/">http://www.nostarch.com/doingmathwithpython/</a></em>.</p>
<h4 class="h4" id="ch02lev2sec09"><strong><em>#1: How Does the Temperature Vary During the Day?</em></strong></h4>
<p class="noindent">If you enter a search term like “New York weather” in Google’s search engine, you’ll see, among other things, a graph showing the temperature at different times of the present day. Your task here is to re-create such a graph.</p>
<p class="indent">Using a city of your choice, find the temperature at different points of the day. Use the data to create two lists in your program and to create a graph with the time of day on the <em>x</em>-axis and the corresponding temperature on the <em>y</em>-axis. The graph should tell you how the temperature varies with the time of day. Try a different city and see how the two cities compare by plotting both lines on the same graph.</p>
<p class="indent">The time of day may be indicated by strings such as <span class="literal">'10:11 AM'</span> or <span class="literal">'09:21 PM'</span>.</p>
<h4 class="h4" id="ch02lev2sec10"><strong><em>#2: Exploring a Quadratic Function Visually</em></strong></h4>
<p class="noindent">In <a href="ch01.html#ch01">Chapter 1</a>, you learned how to find the roots of a quadratic equation, such as <em>x</em><sup>2</sup> + 2<em>x</em> + 1 = 0. We can turn this equation into a function by writing it as <em>y</em> = <em>x</em><sup>2</sup> + 2<em>x</em> + 1. For any value of <em>x</em>, the quadratic function produces <em>some</em> value for <em>y</em>. For example, when <em>x</em> = 1, <em>y</em> = 4. Here’s a program that calculates the value of <em>y</em> for six different values of <em>x</em>:</p>
<p class="programs">   '''<br/>   Quadratic function calculator<br/>   '''<br/><br/>   # Assume values of x<br/><span class="ent">➊</span> x_values = [-1, 1, 2, 3, 4, 5]<br/><span class="ent">➋</span> for x in x_values:<br/>       # Calculate the value of the quadratic function<br/>       y = x**2 + 2*x + 1<br/>       print('x={0} y={1}'.format(x, y))</p>
<p class="indent">At <span class="ent">➊</span>, we create a list with six different values for <span class="literal">x</span>. The <span class="literal">for</span> loop starting at <span class="ent">➋</span> calculates the value of the function above for each of these values and uses the label <span class="literal">y</span> to refer to the list of results. Next, we print the value of <span class="literal">x</span> and the corresponding value of <span class="literal">y</span>. When you run the program, you should see the following output:</p>
<p class="programs">x=-1 y=0<br/>x=1 y=4<br/>x=2 y=9<br/><a id="page_56"></a><br/>x=3 y=16<br/>x=4 y=25<br/>x=5 y=36</p>
<p class="indent">Notice that the first line of the output is a root of the quadratic equation because it’s a value for <span class="literal">x</span> that makes the function equal to 0.</p>
<p class="indent">Your programming challenge is to enhance this program to create a graph of the function. Try using at least 10 values for <span class="literal">x</span> instead of the 6 above. Calculate the corresponding <span class="literal">y</span> values using the function and then create a graph using these two sets of values.</p>
<p class="indent">Once you’ve created the graph, spend some time analyzing how the value of <em>y</em> varies with respect to <em>x</em>. Is the variation linear or nonlinear?</p>
<h4 class="h4" id="ch02lev2sec11"><strong><em>#3: Enhanced Projectile Trajectory Comparison Program</em></strong></h4>
<p class="noindent">Your challenge here is to enhance the trajectory comparison program in a few ways. First, your program should print the time of flight, maximum horizontal distance, and maximum vertical distance traveled for each of the velocity and angle of projection combinations.</p>
<p class="indent">The other enhancement is to make the program work with any number of initial velocity and angle of projection values, supplied by the user. For example, here’s how the program should ask the user for the inputs:</p>
<p class="programs">How many trajectories? <span class="codestrong">3</span><br/>Enter the initial velocity for trajectory 1 (m/s): <span class="codestrong">45</span><br/>Enter the angle of projection for trajectory 1 (degrees): <span class="codestrong">45</span><br/>Enter the initial velocity for trajectory 2 (m/s): <span class="codestrong">60</span><br/>Enter the angle of projection for trajectory 2 (degrees): <span class="codestrong">45</span><br/>Enter the initial velocity for trajectory(m/s) 3: <span class="codestrong">45</span><br/>Enter the angle of projection for trajectory(degrees) 3: <span class="codestrong">90</span></p>
<p class="indent">Your program should also ensure that erroneous input is properly handled using a <span class="literal">try...except</span> block, just as in the original program.</p>
<h4 class="h4" id="ch02lev2sec12"><strong><em>#4: Visualizing Your Expenses</em></strong></h4>
<p class="noindent">I always find myself asking at the end of the month, “Where did all that money go?” I’m sure this isn’t a problem I alone face.</p>
<p class="indent">For this challenge, you’ll write a program that creates a bar chart for easy comparison of weekly expenditures. The program should first ask for the number of categories for the expenditures and the weekly total expenditure in each category, and then it should create the bar chart showing these expenditures.</p>
<p class="indent">Here’s a sample run of how the program should work:</p>
<p class="programs">Enter the number of categories: <span class="codestrong">4</span><br/>Enter category: <span class="codestrong">Food</span><br/>Expenditure: <span class="codestrong">70</span><br/><a id="page_57"></a><br/>Enter category: <span class="codestrong">Transportation</span><br/>Expenditure: <span class="codestrong">35</span><br/>Enter category: <span class="codestrong">Entertainment</span><br/>Expenditure: <span class="codestrong">30</span><br/>Enter category: <span class="codestrong">Phone/Internet</span><br/>Expenditure: <span class="codestrong">30</span></p>
<p class="indent"><a href="ch02.html#ch2fig16">Figure 2-16</a> shows the bar chart that will be created to compare the expenditures. If you save the bar chart for every week, at the end of the month, you’ll be able to see how the expenditures varied between the weeks for different categories.</p>
<div class="image"><img src="images/f02-16.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig16"></a><em>Figure 2-16: A bar chart showing the expenditures per category during the week</em></p>
<p class="indent">We haven’t discussed creating a bar chart using matplotlib, so let’s try an example.</p>
<p class="indent">A bar chart can be created using matplotlib’s <span class="literal">barh()</span> function, which is also defined in the <span class="literal">pyplot</span> module. <a href="ch02.html#ch2fig17">Figure 2-17</a> shows a bar chart that illustrates the number of steps I walked during the past week. The days of the week—Sunday, Monday, Tuesday, and so forth—are referred to as the <em>labels</em>. Each horizontal bar starts from the <em>y</em>-axis, and we have to specify the <em>y</em>-coordinate of the <em>center</em> of this position for each of the bars. The length of each bar corresponds to the number of steps specified.</p>
<div class="image"><a id="page_58"></a><img src="images/f02-17.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig17"></a><em>Figure 2-17: A bar chart showing the number of steps walked during a week</em></p>
<p class="indent">The following program creates the bar chart:</p>
<p class="programs">   '''<br/>   Example of drawing a horizontal bar chart<br/>   '''<br/>   import matplotlib.pyplot as plt<br/>   def create_bar_chart(data, labels):<br/>       # Number of bars<br/>       num_bars = len(data)<br/>       # This list is the point on the y-axis where each<br/>       # Bar is centered. Here it will be [1, 2, 3...]<br/><span class="ent">➊</span>     positions = range(1, num_bars+1)<br/><span class="ent">➋</span>     plt.barh(positions, data, align='center')<br/>       # Set the label of each bar<br/>       plt.yticks(positions, labels)<br/>       plt.xlabel('Steps')<br/>       plt.ylabel('Day')<br/>       plt.title('Number of steps walked')<br/>       # Turns on the grid which may assist in visual estimation<br/>       plt.grid(<br/>       plt.show()<br/><br/>   if __name__ == '__main__':<br/>       # Number of steps I walked during the past week<br/>       steps = [6534, 7000, 8900, 10786, 3467, 11045, 5095]<br/>       # Corresponding days<br/>       labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']<br/>       create_bar_chart(steps, labels)</p>
<p class="indent"><a id="page_59"></a>The <span class="literal">create_bar_chart()</span> function accepts two parameters—<span class="literal">data</span>, which is a list of numbers we want to represent using the bars and labels, and the corresponding <span class="literal">labels</span> list. The center of each bar has to be specified, and I’ve arbitrarily chosen the centers as 1, 2, 3, 4, and so on using the help of the <span class="literal">range()</span> function at <span class="ent">➊</span>.</p>
<p class="indent">We then call the <span class="literal">barh()</span> function, passing <span class="literal">positions</span> and <span class="literal">data</span> as the first two arguments and then the keyword argument, <span class="literal">align='center'</span>, at <span class="ent">➋</span>. The keyword argument specifies that the bars are centered at the positions on the <em>y</em>-axis specified by the list. We then set the labels for each bar, the axis labels, and the title using the <span class="literal">yticks()</span> function. We also call the <span class="literal">grid()</span> function to turn on the grid, which may be useful for a visual estimation of the number of steps. Finally, we call the <span class="literal">show()</span> function.</p>
<h4 class="h4" id="ch02lev2sec13"><strong><em>#5: Exploring the Relationship Between the Fibonacci Sequence and the Golden Ratio</em></strong></h4>
<p class="noindent">The Fibonacci sequence (1, 1, 2, 3, 5, ...) is the series of numbers where the <em>i</em>th number in the series is the sum of the two previous numbers—that is, the numbers in the positions (<em>i</em> – 2) and (<em>i</em> – 1). The successive numbers in this series display an interesting relationship. As you increase the number of terms in the series, the ratios of consecutive pairs of numbers are nearly equal to each other. This value approaches a special number referred to as the <em>golden ratio</em>. Numerically, the golden ratio is the number 1.618033988 ..., and it’s been the subject of extensive study in music, architecture, and nature. For this challenge, write a program that will plot on a graph the ratio between consecutive Fibonacci numbers for, say, 100 numbers, which will demonstrate that the values approach the golden ratio.</p>
<p class="indent">You may find the following function, which returns a list of the first <em>n</em> Fibonacci numbers, useful in implementing your solution:</p>
<p class="programs">def fibo(n):<br/>    if n == 1:<br/>        return [1]<br/>    if n == 2:<br/>        return [1, 1]<br/>    # n &gt; 2<br/>    a = 1<br/>    b = 1<br/>    # First two members of the series<br/>    series = [a, b]<br/>    for i in range(n):<br/>        c = a + b<br/>        series.append(c)<br/>        a = b<br/>        b = c<br/><br/>    return series</p>
<p class="indent"><a id="page_60"></a>The output of your solution should be a graph, as shown in <a href="ch02.html#ch2fig18">Figure 2-18</a>.</p>
<div class="image"><img src="images/f02-18.jpg" alt="image" /></div>
<p class="figuret"><a id="ch2fig18"></a><em>Figure 2-18: The ratio between the consecutive Fibonacci numbers approaches the golden ratio.</em></p>
</div>
</body>
</html>