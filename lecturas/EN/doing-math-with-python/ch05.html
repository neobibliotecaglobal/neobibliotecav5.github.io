<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>Chapter 5: Playing with Sets and Probability</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><h2 class="h2" id="ch05"><a id="page_121"></a><strong><span class="big">5</span></strong><br/><strong>Playing with Sets and Probability</strong></h2>
<div class="image1"><img src="images/common-01.jpg" alt="image" /></div>
<p class="noindent">In this chapter, we’ll start by learning how we can make our programs understand and manipulate sets of numbers. We’ll then see how sets can help us understand basic concepts in probability. Finally, we’ll learn about generating random numbers to simulate random events. Let’s get started!</p>
<h3 class="h3" id="ch05lev1sec01"><strong>What’s a Set?</strong></h3>
<p class="noindent">A <em>set</em> is a collection of distinct objects, often called <em>elements</em> or <em>members</em>. Two characteristics of a set make it different from just any collection of objects. A set is “well defined,” meaning the question “Is a particular object in this collection?” always has a clear yes or no answer, usually based on a rule or some given criteria. The second characteristic is that no two members of a set are the same. A set can contain anything—numbers, people, things, words, and so on.</p>
<p class="indent"><a id="page_122"></a>Let’s walk through some basic properties of sets as we learn how to work with sets in Python using SymPy.</p>
<h4 class="h4" id="ch05lev2sec01"><strong><em>Set Construction</em></strong></h4>
<p class="noindent">In mathematical notation, you represent a set by writing the set members enclosed in curly brackets. For example, {2, 4, 6} represents a set with 2, 4, and 6 as its members. To create a set in Python, we can use the <span class="literal">FiniteSet</span> class from the <span class="literal">sympy</span> package, as follows:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(2, 4, 6)</span><br/>&gt;&gt;&gt; <span class="codestrong">s</span><br/>{2, 4, 6}</p>
<p class="indent">Here, we first import the <span class="literal">FiniteSet</span> class from SymPy and then create an object of this class by passing in the set members as arguments. We assign the label <span class="literal">s</span> to the set we just created.</p>
<p class="indent">We can store different types of numbers—including integers, floating point numbers, and fractions—in the same set:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">from fractions import Fraction</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 1.5, Fraction(1, 5))</span><br/>&gt;&gt;&gt; <span class="codestrong">s</span><br/>{1/5, 1, 1.5}</p>
<p class="indent">The <em>cardinality</em> of a set is the number of members in the set, which you can find by using the <span class="literal">len()</span> function:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 1.5, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">len(s)</span><br/>3</p>
<h5 class="h5" id="ch05lev3sec01"><strong>Checking Whether a Number Is in a Set</strong></h5>
<p class="noindent">To check whether a number is a member of an existing set, use the <span class="literal">in</span> operator. This operator asks Python, “Is this number in this set?” It returns <span class="literal">True</span> if the number belongs to the set and <span class="literal">False</span> if it doesn’t. If, for example, we wanted to check whether 4 was in the previous set, we’d do the following:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">4 in s</span><br/>False</p>
<p class="indent">Because 4 is not present in the set, the operator returns <span class="literal">False</span>.</p>
<h5 class="h5" id="ch05lev3sec02"><a id="page_123"></a><strong>Creating an Empty Set</strong></h5>
<p class="noindent">If you want to make an <em>empty set</em>, which is a set that doesn’t have any elements or members, create a <span class="literal">FiniteSet</span> object without passing any arguments. The result is an <span class="literal">EmptySet</span> object:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet()</span><br/>&gt;&gt;&gt; <span class="codestrong">s</span><br/>EmptySet()</p>
<h5 class="h5" id="ch05lev3sec03"><strong>Creating Sets from Lists or Tuples</strong></h5>
<p class="noindent">You can also create a set by passing in a list or a tuple of set members as an argument to <span class="literal">FiniteSet</span>:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">members = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(*members)</span><br/>&gt;&gt;&gt; <span class="codestrong">s</span><br/>{1, 2, 3}</p>
<p class="indent">Here, instead of passing in the set members directly to <span class="literal">FiniteSet</span>, we first stored them in a list, which we called <span class="literal">members</span>. Then, we passed the list to <span class="literal">FiniteSet</span> using this special Python syntax, which basically translates to creating a <span class="literal">FiniteSet</span> object that passes the list members as separate arguments and not as a list. That is, this approach to creating a <span class="literal">FiniteSet</span> object is equivalent to <span class="literal">FiniteSet(1, 2, 3)</span>. We will make use of this syntax when the set members are computed at runtime.</p>
<h5 class="h5" id="ch05lev3sec04"><strong>Set Repetition and Order</strong></h5>
<p class="noindent">Sets in Python (like mathematical sets) ignore any repeats of a member, and they don’t keep track of the order of set members. For example, if you create a set from a list that has multiple instances of a number, the number is added to the set only once, and the other instances are discarded:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">members = [1, 2, 3, 2]</span><br/>&gt;&gt;&gt; <span class="codestrong">FiniteSet(*members)</span><br/>{1, 2, 3}</p>
<p class="indent">Here, even though we passed in a list that had two instances of the number 2, the number 2 appears only once in the set created from that list.</p>
<p class="indent">In Python lists and tuples, each element is stored in a particular order, but the same is not always true for sets. For example, we can print out each member of a set by iterating through it as follows:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">for member in s:</span><br/>        <span class="codestrong">print(member)</span><br/><a id="page_124"></a><br/>2<br/>1<br/>3</p>
<p class="indent">When you run this code, the elements could be printed in any possible order. This is because of how sets are stored by Python—it keeps track of what members are in the set, but it doesn’t keep track of any particular order for those members.</p>
<p class="indent">Let’s see another example. Two sets are <em>equal</em> when they have the same elements. In Python, you can use the equality operator, <span class="literal">==</span>, to check whether two sets are equal:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(3, 4, 5)</span><br/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(5, 4, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">s == t</span><br/>True</p>
<p class="indent">Although the members of these two sets appear in different orders, the sets are still equal.</p>
<h4 class="h4" id="ch05lev2sec02"><strong><em>Subsets, Supersets, and Power Sets</em></strong></h4>
<p class="noindent">A set, <em>s</em>, is a <em>subset</em> of another set, <em>t</em>, if all the members of <em>s</em> are also members of <em>t</em>. For example, the set {1} is a subset of the set {1, 2}. You can check whether a set is a subset of another set using the <span class="literal">is_subset()</span> method:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1)</span><br/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(1,2)</span><br/>&gt;&gt;&gt; <span class="codestrong">s.is_subset(t)</span><br/>True<br/>&gt;&gt;&gt; <span class="codestrong">t.is_subset(s)</span><br/>False</p>
<p class="indent">Note that an empty set is a subset of every set. Also, any set is a subset of itself, as you can see in the following:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">s.is_subset(s)</span><br/>True<br/>&gt;&gt;&gt; <span class="codestrong">t.is_subset(t)</span><br/>True</p>
<p class="indent">Similarly, a set, <em>t</em>, is said to be a <em>superset</em> of another set, <em>s</em>, if <em>t</em> contains all of the members contained in <em>s</em>. You can check whether one set is a superset of another using the <span class="literal">is_superset()</span> method:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">s.is_superset(t)</span><br/>False<br/>&gt;&gt;&gt; <span class="codestrong">t.is_superset(s)</span><br/>True</p>
<p class="indent"><a id="page_125"></a>The <em>power set</em> of a set, <em>s</em>, is the set of all possible subsets of <em>s</em>. Any set, <em>s</em>, has precisely 2<sup>|<em>s</em>|</sup> subsets, where |<em>s</em>| is the cardinality of the set. For example, the set {1, 2, 3} has a cardinality of 3, so it has 2<sup>3</sup> or 8 subsets: {} (the empty set), {1}, {2}, {3}, {1, 2}, {2, 3}, {1, 3}, and {1, 2, 3}.</p>
<p class="indent">The set of all these subsets form the power set, and we can find the power set using the <span class="literal">powerset()</span> method:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">ps = s.powerset()</span><br/>&gt;&gt;&gt; <span class="codestrong">ps</span><br/>{{1}, {1, 2}, {1, 3}, {1, 2, 3}, {2}, {2, 3}, {3}, EmptySet()}</p>
<p class="indent">As the power set is a set itself, you can find its cardinality using the <span class="literal">len()</span> function:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">len(ps)</span><br/>8</p>
<p class="indent">The cardinality of the power set is 2<sup>|<em>s</em>|</sup>, which is 2<sup>3</sup> = 8.</p>
<p class="indent">Based on our definition of a subset, any two sets with the exact same members would be subsets as well as supersets of each other. By contrast, a set, <em>s</em>, is a <em>proper subset</em> of <em>t</em> only if all the members of <em>s</em> are also in <em>t</em> and <em>t</em> has at least one member that is not in <em>s</em>. So if <em>s</em> = {1, 2, 3}, it’s only a proper subset of <em>t</em> if <em>t</em> contains 1, 2, and 3 plus at least one more member. This would also mean that <em>t</em> is a <em>proper superset</em> of <em>s</em>. You can use the <span class="literal">is_proper_subset()</span> method and the <span class="literal">is_proper_superset()</span> method to check for these relationships:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(1, 2, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">s.is_proper_subset(t)</span><br/>False<br/>&gt;&gt;&gt; <span class="codestrong">t.is_proper_superset(s)</span><br/>False</p>
<p class="indent">Now, if we re-create the set <span class="literal">t</span> to include another member, <span class="literal">s</span> will be considered a proper subset of <span class="literal">t</span> and <span class="literal">t</span> a proper superset of <span class="literal">s</span>:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(1, 2, 3, 4)</span><br/>&gt;&gt;&gt; <span class="codestrong">s.is_proper_subset(t)</span><br/>True<br/>&gt;&gt;&gt; <span class="codestrong">t.is_proper_superset(s)</span><br/>True</p>
<div class="sidebar">
<p class="sidebart"><a id="page_126"></a><strong>COMMON NUMBER SETS</strong></p>
<p class="noindent">In the first chapter, we learned that there are different kinds of numbers— integers, floating point numbers, fractions, and complex numbers. All these numbers form different sets of numbers, which have special names.</p>
<p class="indent">All positive and negative whole numbers form the set of <em>integers</em>. All positive integers form the set of <em>natural numbers</em> (sometimes 0 is included in this set of numbers even though it’s not positive, but sometimes not). This means the set of natural numbers is a proper subset of the set of integers.</p>
<p class="indent">The set of <em>rational numbers</em> includes any number that can be expressed as a fraction, which includes all integers, plus any number with a decimal ending that terminates or repeats (including numbers like 1/4 or 0.25, and 1/3 or 0.33333 ...). By contrast, nonrepeating, nonterminating decimal numbers are known as <em>irrational numbers</em>. The square root of 2 and <em>π</em> are both examples of irrational numbers because they go on forever without repeating.</p>
<p class="indent">If you put together all the rational and irrational numbers, you get the set of <em>real numbers</em>. But even larger than that is the set of <em>complex numbers</em>, which includes all real numbers and all numbers with an imaginary component.</p>
<p class="indent">All of these sets of numbers are infinite sets because they have infinite members. In contrast, the sets we’ve discussed in this chapter have a finite number of members, which is why the SymPy class we’re using is called <span class="literal">FiniteSet</span>.</p>
</div>
<h4 class="h4" id="ch05lev2sec03"><strong><em>Set Operations</em></strong></h4>
<p class="noindent">Set operations such as union, intersection, and the Cartesian product allow you to combine sets in certain methodical ways. These set operations are extremely useful in real-world problem-solving situations when we have to consider multiple sets together. Later in this chapter, we’ll see how to use these operations to apply a formula to multiple sets of data and calculate the probabilities of random events.</p>
<h5 class="h5" id="ch05lev3sec05"><strong>Union and Intersection</strong></h5>
<p class="noindent">The <em>union</em> of two sets is a set that contains all of the <em>distinct</em> members of the two sets. In set theory, we use the symbol ∪ to refer to the union operation. For example, {1, 2} ∪ {2, 3} will result in a new set, {1, 2, 3}. In SymPy, the union of these two sets can be created using the <span class="literal">union()</span> method:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(2, 4, 6)</span><br/>&gt;&gt;&gt; <span class="codestrong">s.union(t)</span><br/>{1, 2, 3, 4, 6}</p>
<p class="indent"><a id="page_127"></a>We find the union of <span class="literal">s</span> and <span class="literal">t</span> by applying the <span class="literal">union</span> method to <span class="literal">s</span> and passing in <span class="literal">t</span> as an argument. The result is a third set with all the distinct members of the two sets. In other words, each member of this third set is a member of one or both of the first two sets.</p>
<p class="indent">The <em>intersection</em> of two sets creates a new set from the elements common to both sets. For example, the intersection of the sets {1, 2} and {2, 3} will result in a new set with the only common element, {2}. Mathematically, this operation is written as {1, 2} ∩ {2, 3}.</p>
<p class="indent">In SymPy, use the <span class="literal">intersect()</span> method to find the intersection:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2)</span><br/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(2, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">s.intersect(t)</span><br/>{2}</p>
<p class="indent">Whereas the union operation finds members that are in one set <em>or</em> another, the intersection operation finds elements that are present in both. Both of these operations can also be applied to more than two sets. For example, here’s how you’d find the union of three sets:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3)</span><br/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(2, 4, 6)</span><br/>&gt;&gt;&gt; <span class="codestrong">u = FiniteSet(3, 5, 7)</span><br/>&gt;&gt;&gt; <span class="codestrong">s.union(t).union(u)</span><br/>{1, 2, 3, 4, 5, 6, 7}</p>
<p class="indent">Similarly, here’s how you’d find the intersection of three sets:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">s.intersect(t).intersect(u)</span><br/>EmptySet()</p>
<p class="indent">The intersection of the sets <span class="literal">s</span>, <span class="literal">t</span>, and <span class="literal">u</span> turns out to be an empty set because there are no elements that all three sets share.</p>
<h5 class="h5" id="ch05lev3sec06"><strong>Cartesian Product</strong></h5>
<p class="noindent">The <em>Cartesian product</em> of two sets creates a set that consists of all possible pairs made by taking an element from each set. For example, the Cartesian product of the sets {1, 2} and {3, 4} is {(1, 3), (1, 4), (2, 3), (2, 4)}. In SymPy, you can find the Cartesian product of two sets by simply using the multiplication operator:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2)</span><br/>&gt;&gt;&gt; <span class="codestrong">t = FiniteSet(3, 4)</span><br/>&gt;&gt;&gt; <span class="codestrong">p = s*t</span><br/>&gt;&gt;&gt; <span class="codestrong">p</span><br/>{1, 2} x {3, 4}</p>
<p class="indent"><a id="page_128"></a>This takes the Cartesian product of the sets <span class="literal">s</span> and <span class="literal">t</span> and stores it as <span class="literal">p</span>. To actually see each pair in that Cartesian product, we can iterate through and print them out as follows:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">for elem in p:</span><br/>        <span class="codestrong">print(elem)</span><br/>(1, 3)<br/>(1, 4)<br/>(2, 3)<br/>(2, 4)</p>
<p class="indent">Each element of the product is a tuple consisting of a member from the first set and a member from the second set.</p>
<p class="indent">The cardinality of the Cartesian product is the product of the cardinality of the individual sets. We can demonstrate this in Python:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">len(p) == len(s)*len(t)</span><br/>True</p>
<p class="indent">If we apply the exponential operator (<span class="literal">**</span>) to a set, we get the Cartesian product of that set times itself the specified number of times.</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2)</span><br/>&gt;&gt;&gt; <span class="codestrong">p = s**3</span><br/>&gt;&gt;&gt; <span class="codestrong">p</span><br/>{1, 2} x {1, 2} x {1, 2}</p>
<p class="indent">Here, for example, we raised the set <span class="literal">s</span> to the power of 3. Because we’re taking the Cartesian product of three sets, this gives us a set of all possible triplets that contain a member of each set:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">for elem in p:</span><br/>        <span class="codestrong">print(elem)</span><br/>(1, 1, 1)<br/>(1, 1, 2)<br/>(1, 2, 1)<br/>(1, 2, 2)<br/>(2, 1, 1)<br/>(2, 1, 2)<br/>(2, 2, 1)<br/>(2, 2, 2)</p>
<p class="indent">Finding the Cartesian product of sets is useful for finding all possible combinations of the set members, which we’ll explore next.</p>
<h5 class="h5" id="ch05lev3sec07"><a id="page_129"></a><strong>Applying a Formula to Multiple Sets of Variables</strong></h5>
<p class="noindent">Consider a simple pendulum of length <em>L</em>. The <em>time period</em>, <em>T</em>, of this pendulum—that is, the amount of time it takes for the pendulum to complete one full swing—is given by the formula</p>
<div class="image2"><img src="images/e0129-01.jpg" alt="image" /></div>
<p class="indent">Here, <em>π</em> is the mathematical constant, <em>pi</em>, and <em>g</em> is the local gravitational acceleration, which is around 9.8 m/s<sup>2</sup> on Earth. Because <em>π</em> and <em>g</em> are constants, the length, <em>L</em>, is the only variable on the right side of the equation that doesn’t have a constant value.</p>
<p class="indent">If you wanted to see how the time period of a simple pendulum varies with its length, you’d assume different values for the length and measure the corresponding time period at each of these values using the formula. A typical high school experiment is to compare the time period you get using the preceding formula, which is the theoretical result, to the one you measure in the laboratory, which is the experimental result. For example, let’s choose five different values: 15, 18, 21, 22.5, and 25 (all expressed in centimeters). With Python, we can write a quick program that’ll speed through the calculations for the theoretical results:</p>
<p class="programs">   from sympy import FiniteSet, pi<br/><span class="ent">➊</span> def time_period(length):<br/>       g = 9.8<br/>       T = 2*pi*(length/g)**0.5<br/>       return T<br/><br/>   if __name__ == '__main__':<br/><span class="ent">➋</span>     L = FiniteSet(15, 18, 21, 22.5, 25)<br/>       for l in L:<br/><span class="ent">➌</span>         t = time_period(l/100)<br/>           print('Length: {0} cm Time Period: {1:.3f} s'. format(float(l), float(t)))</p>
<p class="indent">We first define the function <span class="literal">time_period</span> at <span class="ent">➊</span>. This function applies the formula shown earlier to a given length, which is passed in as <span class="literal">length</span>. Then, our program defines a set of lengths at <span class="ent">➋</span> and applies the <span class="literal">time_period</span> function to each value at <span class="ent">➌</span>. Notice that when we pass in the length values to <span class="literal">time_period</span>, we divide them by 100. This operation converts the lengths from centimeters to meters so that they match the unit of gravitational acceleration, which is expressed in units of meters/second<sup>2</sup>. Finally, we print the calculated time period. When you run the program, you’ll see the following output:</p>
<p class="programs">Length: 15.0 cm Time Period: 0.777 s<br/>Length: 18.0 cm Time Period: 0.852 s<br/>Length: 21.0 cm Time Period: 0.920 s<br/>Length: 22.5 cm Time Period: 0.952 s<br/>Length: 25.0 cm Time Period: 1.004 s</p>
<h5 class="h5" id="ch05lev3sec08"><a id="page_130"></a><strong>Different Gravity, Different Results</strong></h5>
<p class="noindent">Now, imagine we conducted this experiment in three different places— my current location, Brisbane, Australia; the North Pole; and the equator. The force of gravity varies slightly depending on the latitude of your location: it’s a bit lower (approximately 9.78 m/s<sup>2</sup>) at the equator and higher (9.83 m/s<sup>2</sup>) at the North Pole. This means we can treat the force of gravity as a variable in our formula, rather than a constant, and calculate results for three different values of gravitational acceleration: {9.8, 9.78, 9.83}.</p>
<p class="indent">If we want to calculate the period of a pendulum for each of our five lengths at each of these three locations, a systematic way to work out all of these combinations of the values is to take the Cartesian product, as shown in the following program:</p>
<p class="programs">   from sympy import FiniteSet, pi<br/><br/>   def time_period(length, g):<br/><br/>       T = 2*pi*(length/g)**0.5<br/>       return T<br/><br/>   if __name__ == '__main__':<br/><br/>       L = FiniteSet(15, 18, 21, 22.5, 25)<br/>       g_values = FiniteSet(9.8, 9.78, 9.83)<br/><span class="ent">➊</span>     print('{0:^15}{1:^15}{2:^15}'.format('Length(cm)', 'Gravity(m/s^2)', 'Time Period(s)'))<br/><span class="ent">➋</span>     for elem in L*g_values:<br/><span class="ent">➌</span>         l = elem[0]<br/><span class="ent">➍</span>         g = elem[1]<br/>           t = time_period(l/100, g)<br/><br/><span class="ent">➎</span>         print('{0:^15}{1:^15}{2:^15.3f}'.format(float(l), float(g), float(t)))</p>
<p class="indent">At <span class="ent">➋</span>, we take the Cartesian product of our two sets of variables, <span class="literal">L</span> and <span class="literal">g_values</span>, and we iterate through each resulting combination of values to calculate the time period. Each combination is represented as a tuple, and for each tuple, we extract the first value, the length, at <span class="ent">➌</span> and the second value, the gravity, at <span class="ent">➍</span>. Then, just as before, we call the <span class="literal">time_period()</span> function with these two labels as parameters, and we print the values of length (<span class="literal">l</span>), gravity (<span class="literal">g</span>), and the corresponding time period (<span class="literal">T</span>).</p>
<p class="indent">The output is presented in a table to make it easy to follow. The table is formatted by the <span class="literal">print</span> statements at <span class="ent">➊</span> and <span class="ent">➎</span>. The format string <span class="literal">{0:^15} {1:^15}{2:^15.3f}</span> creates three fields, each 15 spaces wide, and the <span class="literal">^</span> symbol centers each entry in each field. In the last field of the <span class="literal">print</span> statement at <span class="ent">➎</span>, <span class="literal">'.3f'</span> limits the number of digits after the decimal point to three.</p>
<p class="indent">When you run the program, you’ll see the following output:</p>
<p class="programs">Length(cm)   Gravity(m/s^2)   Time Period(s)<br/>    15.0           9.78             0.778<br/>    15.0            9.8             0.777<br/>    15.0           9.83             0.776<br/><a id="page_131"></a><br/>    18.0           9.78             0.852<br/>    18.0            9.8             0.852<br/>    18.0           9.83             0.850<br/>    21.0           9.78             0.921<br/>    21.0            9.8             0.920<br/>    21.0           9.83             0.918<br/>    22.5           9.78             0.953<br/>    22.5            9.8             0.952<br/>    22.5           9.83             0.951<br/>    25.0           9.78             1.005<br/>    25.0            9.8             1.004<br/>    25.0           9.83             1.002</p>
<p class="indent">This experiment presents a simple scenario where you need all possible combinations of the elements of multiple sets (or a group of numbers). In this type of situation, the Cartesian product is exactly what you need.</p>
<h3 class="h3" id="ch05lev1sec02"><strong>Probability</strong></h3>
<p class="noindentb">Sets allow us to reason about the basic concepts of probability. We’ll begin with a few definitions:</p>
<p class="itemlist"><strong>Experiment</strong> The <em>experiment</em> is simply the test we want to perform. We perform the test because we’re interested in the probability of each possible outcome. Rolling a die, flipping a coin, and pulling a card from a deck of cards are all examples of experiments. A single run of an experiment is referred to as a <em>trial</em>.</p>
<p class="itemlist"><strong>Sample space</strong> All possible outcomes of an experiment form a set known as the <em>sample space</em>, which we’ll usually call <em>S</em> in our formulas. For example, when a six-sided die is rolled once, the sample space is {1, 2, 3, 4, 5, 6}.</p>
<p class="itemlist"><strong>Event</strong> An <em>event</em> is a set of outcomes that we want to calculate the probability of and that form a <em>subset</em> of the sample space. For example, we might want to know the probability of a particular outcome, like rolling a 3, or the probability of a set of multiple outcomes, such as rolling an even number (either 2, 4, or 6). We’ll use the letter <em>E</em> in our formulas to stand for an event.</p>
<p class="indentt">If there’s a <em>uniform distribution</em>—that is, if each outcome in the sample space is equally likely to occur—then the probability of an event, <em>P</em>(<em>E</em>), occurring is calculated using the following formula (I’ll talk about nonuniform distributions a bit later in this chapter):</p>
<div class="image2"><img src="images/e0131-01.jpg" alt="image" /></div>
<p class="indent">Here, <em>n</em>(<em>E</em>) and <em>n</em>(<em>S</em>) are the cardinality of the sets <em>E</em>, the event, and <em>S</em>, the sample space, respectively. The value of <em>P</em>(<em>E</em>) ranges from 0 to 1, with higher values indicating a higher chance of the event happening.</p>
<p class="indent"><a id="page_132"></a>We can apply this formula to a die roll to calculate the probability of a particular roll—say, 3:</p>
<div class="image2"><img src="images/e0132-01.jpg" alt="image" /></div>
<p class="indent">This confirms what was obvious all along: the probability of a particular die roll is 1/6. You could easily do this calculation in your head, but we can use this formula to write the following function in Python that calculates the probability of any event, <span class="literal">event</span>, in any sample space, <span class="literal">space</span>:</p>
<p class="programs">def probability(space, event):<br/>    return len(event)/len(space)</p>
<p class="indent">In this function, the two arguments <span class="literal">space</span> and <span class="literal">event</span>—the sample space and event—need not be sets created using <span class="literal">FiniteSet</span>. They can also be lists or, for that matter, any other Python object that supports the <span class="literal">len()</span> function.</p>
<p class="indent">Using this function, let’s write a program to find the probability of a prime number appearing when a 20-sided die is rolled:</p>
<p class="programs">     def probability(space, event):<br/>         return len(event)/len(space)<br/><br/><span class="ent">➊</span>   def check_prime(number):<br/>         if number != 1:<br/>             for factor in range(2, number):<br/>                 if number % factor == 0:<br/>                     return False<br/>         else:<br/>             return False<br/>         return True<br/><br/>     if __name__ == '__main__':<br/><span class="ent">➋</span>       space = FiniteSet(*range(1, 21))<br/>         primes = []<br/>         for num in s:<br/><span class="ent">➌</span>           if check_prime(num):<br/>                 primes.append(num)<br/><span class="ent">➍</span>           event= FiniteSet(*primes)<br/>         p = probability(space, event)<br/><br/>         print('Sample space: {0}'.format(space))<br/>         print('Event: {0}'.format(event))<br/>         print('Probability of rolling a prime: {0:.5f}'.format(p))</p>
<p class="indent"><a id="page_133"></a>We first create a set representing the sample space, <span class="literal">space</span>, using the <span class="literal">range()</span> function at <span class="ent">➋</span>. To create the event set, we need to find the prime numbers from the sample space, so we define a function, <span class="literal">check_prime()</span>, at <span class="ent">➊</span>. This function takes an integer and checks to see whether it’s divisible (with no remainder) by any number between 2 and itself. If so, it returns <span class="literal">False</span>. Because a prime number is only divisible by 1 and itself, this function returns <span class="literal">True</span> if an integer is prime and <span class="literal">False</span> otherwise.</p>
<p class="indent">We call this function for each of the numbers in the sample space at <span class="ent">➌</span> and add the prime numbers to a list, <span class="literal">primes</span>. Then, we create our event set, <span class="literal">event</span>, from this list at <span class="ent">➍</span>. Finally, we call the <span class="literal">probability()</span> function we created earlier. We get the following output when we run the program:</p>
<p class="programs">Sample space: {1, 2, 3, ..., 18, 19, 20}<br/>Event: {2, 3, 5, 7, 11, 13, 17, 19}<br/>Probability of rolling a prime: 0.40000</p>
<p class="indent">Here, <em>n</em>(<em>E</em>) = 8 and <em>n</em>(<em>S</em>) = 20, so the probability, <em>P</em>, is 0.4.</p>
<p class="indent">In our 20-sided die program, we really didn’t need to create the sets; instead, we could have called the <span class="literal">probability()</span> function with the sample space and events as lists:</p>
<p class="programs">if __name__ == '__main__':<br/>    space = range(1, 21)<br/>    primes = []<br/>    for num in space:<br/>        if check_prime(num):<br/>            primes.append(num)<br/>    p = probability(space, primes)</p>
<p class="indent">The <span class="literal">probability()</span> function works equally well in this case.</p>
<h4 class="h4" id="ch05lev2sec04"><strong><em>Probability of Event A or Event B</em></strong></h4>
<p class="noindentb">Let’s say we’re interested in two possible events, and we want to find the probability of <em>either</em> one of them happening. For example, going back to a simple die roll, let’s consider the following two events:</p>
<p class="itemlist">A = The number is a prime number.</p>
<p class="itemlist">B = The number is odd.</p>
<p class="indentt">As it was earlier, the sample space, <em>S</em>, is {1, 2, 3, 4, 5, 6}. Event A can be represented as the subset {2, 3, 5}, the set of prime numbers in the sample space, and event B can be represented as {1, 3, 5}, the odd numbers in the sample space. To calculate the probability of either set of outcomes, we can find the probability of the <em>union</em> of the two sets. In our notation, we could say:</p>
<div class="image2"><img src="images/e0133-01.jpg" alt="image" /></div>
<p class="indent"><a id="page_134"></a>Now let’s perform this calculation in Python:</p>
<p class="programs">   &gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>   &gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3, 4, 5, 6)</span><br/>   &gt;&gt;&gt; <span class="codestrong">a = FiniteSet(2, 3, 5)</span><br/>   &gt;&gt;&gt; <span class="codestrong">b = FiniteSet(1, 3, 5)</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">e = a.union(b)</span><br/>   &gt;&gt;&gt; <span class="codestrong">len(e)/len(s)</span><br/>   0.6666666666666666</p>
<p class="indent">We first create a set, <span class="literal">s</span>, representing the sample space, followed by the two sets <span class="literal">a</span> and <span class="literal">b</span>. Then, at <span class="ent">➊</span>, we use the <span class="literal">union()</span> method to find the event set, <span class="literal">e</span>. Finally, we calculate the probability of the union of the two sets using the earlier formula.</p>
<h4 class="h4" id="ch05lev2sec05"><strong><em>Probability of Event A and Event B</em></strong></h4>
<p class="noindentb">Say you have two events in mind and you want to calculate the chances of <em>both</em> of them happening—for example, the chances that a die roll is both prime and odd. To determine this, you calculate the probability of the intersection of the two event sets:</p>
<p class="center"><em>E</em> = <em>A</em> ∩ <em>B</em> = {2, 3, 5} ∩ {1, 3, 5} = {3, 5}</p>
<p class="indentt">We can calculate the probability of both A and B happening by using the <span class="literal">intersect()</span> method, which is similar to what we did in the previous case:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">from sympy import FiniteSet</span><br/>&gt;&gt;&gt; <span class="codestrong">s = FiniteSet(1, 2, 3, 4, 5, 6)</span><br/>&gt;&gt;&gt; <span class="codestrong">a = FiniteSet(2, 3, 5)</span><br/>&gt;&gt;&gt; <span class="codestrong">b = FiniteSet(1, 3, 5)</span><br/>&gt;&gt;&gt; <span class="codestrong">e = a.intersect(b)</span><br/>&gt;&gt;&gt; <span class="codestrong">len(e)/len(s)</span><br/>0.3333333333333333</p>
<h4 class="h4" id="ch05lev2sec06"><strong><em>Generating Random Numbers</em></strong></h4>
<p class="noindent">Probability concepts allow us to reason about and calculate the chance of an event happening. To actually simulate such events—like a simple dice game—using computer programs, we need a way to generate random numbers.</p>
<h5 class="h5" id="ch05lev3sec09"><strong>Simulating a Die Roll</strong></h5>
<p class="noindent">To simulate a six-sided die roll, we need a way to generate a random integer between 1 and 6. The <span class="literal">random</span> module in Python’s standard library provides us with various functions to generate random numbers. Two functions that we’ll use in this chapter are the <span class="literal">randint()</span> function, which generates a random integer in a given range, and the <span class="literal">random()</span> function, <a id="page_135"></a>which generates a floating point number between 0 and 1. Let’s see a quick example of how the <span class="literal">randint()</span> function works:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">import random</span><br/>&gt;&gt;&gt; <span class="codestrong">random.randint(1, 6)</span><br/>4</p>
<p class="indent">The <span class="literal">randint()</span> function takes two integers as arguments and returns a random integer that falls between these two numbers (both inclusive). In this example, we passed in the range <span class="literal">(1, 6)</span>, and it returned the number 4, but if we call it again, we’ll very likely get a different number:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">random.randint(1, 6)</span><br/>6</p>
<p class="indent">Calling the <span class="literal">randint()</span> function allows us to simulate the roll of our virtual die. Every time we call this function, we’re going to get a number between 1 and 6, just as we would if we were rolling a six-sided die. Note that <span class="literal">randint()</span> expects you to supply the lower number first, so <span class="literal">randint(6, 1)</span> isn’t valid.</p>
<h5 class="h5" id="ch05lev3sec10"><strong>Can You Roll That Score?</strong></h5>
<p class="noindent">Our next program will simulate a simple die-rolling game, where we keep rolling the six-sided die until we’ve rolled a total of 20:</p>
<p class="programs">   '''<br/>   Roll a die until the total score is 20<br/>   '''<br/><br/>   import matplotlib.pyplot as plt<br/>   import random<br/><br/>   target_score = 20<br/><br/>   def roll():<br/>       return random.randint(1, 6)<br/><br/>   if __name__ == '__main__':<br/>       score = 0<br/>       num_rolls = 0<br/><span class="ent">➊</span>     while score &lt; target_score:<br/>           die_roll = roll()<br/>           num_rolls += 1<br/>           print('Rolled: {0}'.format(die_roll))<br/>           score += die_roll<br/><br/>       print('Score of {0} reached in {1} rolls'.format(score, num_rolls))</p>
<p class="indent"><a id="page_136"></a>First, we define the same <span class="literal">roll()</span> function we created earlier. Then, we use a <span class="literal">while</span> loop at <span class="ent">➊</span> to call this function, keep track of the number of rolls, print the current roll, and add up the total score. The loop repeats until the score reaches 20, and then the program prints the total score and number of rolls.</p>
<p class="indent">Here’s a sample run:</p>
<p class="programs">Rolled: 6<br/>Rolled: 2<br/>Rolled: 5<br/>Rolled: 1<br/>Rolled: 3<br/>Rolled: 4<br/>Score of 21 reached in 6 rolls</p>
<p class="indent">If you run the program several times, you’ll notice that the number of rolls it takes to reach 20 varies.</p>
<h5 class="h5" id="ch05lev3sec11"><strong>Is the Target Score Possible?</strong></h5>
<p class="noindent">Our next program is similar, but it’ll tell us whether a certain target score is reachable within a maximum number of rolls:</p>
<p class="programs">   from sympy import FiniteSet<br/>   import random<br/><br/>   def find_prob(target_score, max_rolls):<br/><br/>       die_sides = FiniteSet(1, 2, 3, 4, 5, 6)<br/>       # Sample space<br/><span class="ent">➊</span>     s = die_sides**max_rolls<br/>       # Find the event set<br/>       if max_rolls &gt; 1:<br/>           success_rolls = []<br/><span class="ent">➋</span>         for elem in s:<br/>               if sum(elem) &gt;= target_score:<br/>                   success_rolls.append(elem)<br/>       else:<br/>           if target_score &gt; 6:<br/><span class="ent">➌</span>             success_rolls = []<br/>           else:<br/>               success_rolls = []<br/>               for roll in die_sides:<br/><span class="ent">➍</span>                 if roll &gt;= target_score:<br/>                       success_rolls.append(roll)<br/><span class="ent">➎</span>     e = FiniteSet(*success_rolls)<br/>       # Calculate the probability of reaching target score<br/>       return len(e)/len(s)<br/><br/>   if __name__ == '__main__':<br/><br/>       target_score = int(input('Enter the target score: '))<br/>       max_rolls = int(input('Enter the maximum number of rolls allowed: '))<br/><a id="page_137"></a><br/>       p = find_prob(target_score, max_rolls)<br/>       print('Probability: {0:.5f}'.format(p))</p>
<p class="indent">When you run this program, it asks for the target score and the maximum number of allowed rolls as input, and then it prints out the probability of achieving that.</p>
<p class="indent">Here are two sample executions:</p>
<p class="programs">Enter the target score: 25<br/>Enter the maximum number of rolls allowed: 4<br/>Probability: 0.00000<br/><br/>Enter the target score: 25<br/>Enter the maximum number of rolls allowed: 5<br/>Probability: 0.03241</p>
<p class="indent">Let’s understand the workings of the <span class="literal">find_prob()</span> function, which performs the probability calculation. The sample space here is the Cartesian product, <span class="literal">die_sides</span><sup><span class="literal">max_rolls</span></sup> <span class="ent">➊</span>, where <span class="literal">die_sides</span> is the set {1, 2, 3, 4, 5, 6}, representing the numbers on a six-sided die, and <span class="literal">max_rolls</span> is the maximum number of die rolls allowed.</p>
<p class="indent">The event set is all the sets in the sample space that help us reach this target score. There are two cases here: when the number of turns left is greater than 1 and when we’re in the last turn. For the first case, at <span class="ent">➋</span>, we iterate over each of the tuples in the Cartesian product and add the ones that add up to or exceed <span class="literal">target_score</span> in the <span class="literal">success_rolls</span> list. The second case is special: our sample space is just the set {1, 2, 3, 4, 5, 6}, and we have only one throw of the die left. If the value of the target score is greater than 6, it isn’t possible to achieve it, and we set <span class="literal">success_rolls</span> to be an empty list at <span class="ent">➌</span>. If however, the <span class="literal">target_score</span> is less than or equal to 6, we iterate over each possible roll and add the ones that are greater than or equal to the value of <span class="literal">target_score</span> at <span class="ent">➍</span>.</p>
<p class="indent">At <span class="ent">➎</span>, we calculate the event set, <span class="literal">e</span>, from the <span class="literal">success_rolls</span> list that we constructed earlier and then return the probability of reaching the target score.</p>
<h4 class="h4" id="ch05lev2sec07"><strong><em>Nonuniform Random Numbers</em></strong></h4>
<p class="noindent">Our discussions of probability have so far assumed that each of the outcomes in the sample space is equally likely. The <span class="literal">random.randint()</span> function, for example, returns an integer in the specified range assuming that each integer is <em>equally likely</em>. We refer to such probability as <em>uniform probability</em> and to random numbers generated by the <span class="literal">randint()</span> function as <em>uniform random numbers</em>. Let’s say, however, that we want to simulate a biased coin toss—a loaded coin for which heads is twice as likely to occur as tails. We’d then need a way to generate <em>nonuniform</em> random numbers.</p>
<p class="indent">Before we write the program to do so, we’ll review the idea behind it.</p>
<p class="indent">Consider a number line with a length of 1 and with two equally divided intervals, as shown in <a href="ch05.html#ch5fig1">Figure 5-1</a>.</p>
<div class="image"><a id="page_138"></a><img src="images/f05-01.jpg" alt="image" /></div>
<p class="figuret"><a id="ch5fig1"></a><em>Figure 5-1: A number line with a length of 1 divided into two equal intervals corresponding to the probability of heads or tails on a coin toss</em></p>
<p class="indent">We’ll refer to this line as the <em>probability number line</em>, with each division representing an equally possible outcome—for example, heads or tails upon a fair coin toss. Now, in <a href="ch05.html#ch5fig2">Figure 5-2</a>, consider a different version of this number line.</p>
<div class="image"><img src="images/f05-02.jpg" alt="image" /></div>
<p class="figuret"><a id="ch5fig2"></a><em>Figure 5-2: A number line with a length of 1 divided into two unequal intervals corresponding to the probability of heads or tails on a biased coin toss</em></p>
<p class="indent">Here, the division corresponding to heads is 2/3 of the total length and the division corresponding to tails is 1/3. This represents the situation of a coin that’s likely to turn up heads in 2/3 of tosses and tails only in 1/3 of tosses. The following Python function will simulate such a coin toss, considering this unequal probability of heads or tails appearing:</p>
<p class="programs">   import random<br/><br/>   def toss():<br/>       # 0 -&gt; Heads, 1-&gt; Tails<br/><span class="ent">➊</span>     if random.random() &lt; 2/3:<br/>           return 0<br/>       else:<br/>           return 1</p>
<p class="indent">We assume that the function returns 0 to indicate heads and 1 to indicate tails, and then we generate a random number between 0 and 1 at <span class="ent">➊</span> using the <span class="literal">random.random()</span> function. If the generated number is less than 2/3—the probability of flipping heads with our biased coin—the program returns 0; otherwise it returns 1 (tails).</p>
<p class="indent">We’ll now see how we can extrapolate the preceding function to simulate a nonuniform event with multiple possible outcomes. Let’s consider a fictional ATM that dispenses a $5, $10, $20, or $50 bill when its button is pressed. The different denominations have varying probabilities of being dispensed, as shown in <a href="ch05.html#ch5fig3">Figure 5-3</a>.</p>
<div class="image"><img src="images/f05-03.jpg" alt="image" /></div>
<p class="figuret"><a id="ch5fig3"></a><em>Figure 5-3: A number line with a length of 1 divided into four intervals of different lengths corresponding to the probability of dispensing bills of different denominations</em></p>
<p class="indent"><a id="page_139"></a>Here, the probability of a $5 bill or $10 bill being dispensed is 1/6, and the probability of a $20 bill or $50 bill being dispensed is 1/3.</p>
<p class="indent">We create a list to store the rolling sum of the probabilities, and then we generate a random number between 0 and 1. We start from the left end of the list that stores the sum and return the first index of this list for which the corresponding sum is lesser than or equal to the random number generated. The <span class="literal">get_index()</span> function implements this idea:</p>
<p class="programs">   '''<br/>   Simulate a fictional ATM that dispenses dollar bills<br/>   of various denominations with varying probability<br/>   '''<br/><br/>   import random<br/><br/>   def get_index(probability):<br/>       c_probability = 0<br/><span class="ent">➊</span>     sum_probability = []<br/>       for p in probability:<br/>           c_probability += p<br/>           sum_probability.append(c_probability)<br/><span class="ent">➋</span>     r = random.random()<br/>       for index, sp in enumerate(sum_probability):<br/><span class="ent">➌</span>         if r &lt;= sp:<br/>               return index<br/><span class="ent">➍</span>     return len(probability)-1<br/><br/>   def dispense():<br/><br/>       dollar_bills = [5, 10, 20, 50]<br/>       probability = [1/6, 1/6, 1/3, 2/3]<br/>       bill_index = get_index(probability)<br/>       return dollar_bills[bill_index]</p>
<p class="indent">We call the <span class="literal">get_index()</span> function with a list containing the probability that the event in the corresponding position is expected to occur. We then, at <span class="ent">➊</span>, construct the list <span class="literal">sum_probability</span>, where the <span class="literal">i</span>th element is the sum of the first <span class="literal">i</span> elements in the list <span class="literal">probability</span>. That is, the first element in <span class="literal">sum_probability</span> is equal to the first element in <span class="literal">probability</span>, the second element is equal to the sum of the first two elements in <span class="literal">probability</span>, and so on. At <span class="ent">➋</span>, a random number between 0 and 1 is generated using the label <span class="literal">r</span>. Next, at <span class="ent">➌</span>, we traverse through <span class="literal">sum_probability</span> and return the index of the first element that exceeds <span class="literal">r</span>.</p>
<p class="indent">The last line of the function, at <span class="ent">➍</span>, takes care of a special case best illustrated through an example. Consider a list of three events with percentages of occurrence each expressed as 0.33. In this case, the list <span class="literal">sum_probability</span> would look like <span class="literal">[0.33, 0.66, 0.99]</span>. Now, consider that the random number generated, <span class="literal">r</span>, is <span class="literal">0.99314</span>. For this value of <span class="literal">r</span>, we want the last element in the list of events to be chosen. You may argue that this isn’t exactly right because the last event has a higher than 33 percent chance of being <a id="page_140"></a>selected. As per the condition at <span class="ent">➌</span>, there’s no element in <span class="literal">sum_probability</span> that’s greater than <span class="literal">r</span>; hence, the function wouldn’t return any index at all. The statement at <span class="ent">➍</span> takes care of this and returns the last index.</p>
<p class="indent">If you call the <span class="literal">dispense()</span> function to simulate a large number of dollar bills disbursed by the ATM, you’ll see that the ratio of the number of times each bill appears closely obeys the probability specified. We’ll find this technique useful when creating <em>fractals</em> in the next chapter.</p>
<h3 class="h3" id="ch05lev1sec03"><strong>What You Learned</strong></h3>
<p class="noindent">In this chapter, you started by learning how to represent a set in Python. Then, we discussed the various set concepts and you learned about the union, the intersection, and the Cartesian product of sets. You applied some of the set concepts to explore the basics of probability and, finally, learned how to simulate uniform and nonuniform random events in your programs.</p>
<h3 class="h3" id="ch05lev1sec04"><strong><span class="bordera">Programming Challenges</span></strong></h3>
<p class="noindent">Next, you have a few programming challenges to solve that’ll give you the opportunity to apply what you’ve learned in this chapter.</p>
<h4 class="h4" id="ch05lev2sec08"><strong><em>#1: Using Venn Diagrams to Visualize Relationships Between Sets</em></strong></h4>
<p class="noindent">A <em>Venn diagram</em> is an easy way to see the relationship between sets graphically. It tells us how many elements are common between the two sets, how many elements are only in one set, and how many elements are in neither set. Consider a set, <em>A</em>, that represents the set of positive odd numbers less than 20—that is, <em>A</em> = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}—and consider another set, <em>B</em>, that represents the set of prime numbers less than 20—that is, <em>B</em> = {2, 3, 5, 7, 11, 13, 17, 19}. We can draw Venn diagrams with Python using the <span class="literal">matplotlib_venn</span> package (see <a href="app01.html#app01">Appendix A</a> for installation instructions for this package). Once you’ve installed it, you can draw the Venn diagram as follows:</p>
<p class="programs">'''<br/>Draw a Venn diagram for two sets<br/>'''<br/><br/>from matplotlib_venn import venn2<br/>import matplotlib.pyplot as plt<br/>from sympy import FiniteSet<br/><br/>def draw_venn(sets):<br/><br/>    venn2(subsets=sets)<br/>    plt.show()<br/><br/>if __name__ == '__main__':<br/><br/>    s1 = FiniteSet(1, 3, 5, 7, 9, 11, 13, 15, 17, 19)<br/>    s2 = FiniteSet(2, 3, 5, 7, 11, 13, 17, 19)<br/><br/>    draw_venn([s1, s2])</p>
<p class="indent"><a id="page_141"></a>Once we import all the required modules and functions (the <span class="literal">venn2()</span> function, <span class="literal">matplotlib.pyplot</span>, and the <span class="literal">FiniteSet</span> class), all we have to do is create the two sets and then call the <span class="literal">venn2()</span> function, using the <span class="literal">subsets</span> key-word argument to specify the sets as a tuple.</p>
<p class="indent"><a href="ch05.html#ch5fig4">Figure 5-4</a> shows the Venn diagram created by the preceding program. The sets <em>A</em> and <em>B</em> share seven common elements, so 7 is written in the common area. Each of the sets also has unique elements, so the number of unique elements—3 and 1, respectively—is written in the individual areas. The labels below the two sets are shown as <em>A</em> and <em>B</em>. You can specify your own labels using the <span class="literal">set_labels</span> keyword argument:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">venn2(subsets=(a,b), set_labels=('S', 'T'))</span></p>
<p class="indent">This would change the set labels to <span class="literal">S</span> and <span class="literal">T</span>.</p>
<div class="image"><img src="images/f05-04.jpg" alt="image" /></div>
<p class="figuret"><a id="ch5fig4"></a><em>Figure 5-4: Venn diagram showing the relationship between two sets</em>, A <em>and</em> B</p>
<p class="indent"><a id="page_142"></a>For your challenge, imagine you’ve created an online questionnaire asking your classmates the following question: <em>Do you play football, another sport, or no sports?</em> Once you have the results, create a CSV file, <em>sports.csv</em>, as follows:</p>
<p class="programs">StudentID,Football,Others<br/>1,1,0<br/>2,1,1<br/>3,0,1<br/>--<span class="codeitalic">snip</span>--</p>
<p class="indent">Create 20 such rows for the 20 students in your class. The first column is the student ID (the survey isn’t anonymous), the second column has a 1 if the student has marked “football” as the sport they love to play, and the third column has a 1 if the student plays any other sport or none at all. Write a program to create a Venn diagram to depict the summarized results of the survey, as shown in <a href="ch05.html#ch5fig5">Figure 5-5</a>.</p>
<div class="image"><img src="images/f05-05.jpg" alt="image" /></div>
<p class="figuret"><a id="ch5fig5"></a><em>Figure 5-5: A Venn diagram showing the number of students who love to play football and the number who love to play other sports</em></p>
<p class="indent"><a id="page_143"></a>Depending on the data in the <em>sports.csv</em> file you created, the numbers in each set will vary. The following function reads a CSV file and returns two lists corresponding to the IDs of those students who play football and other sports:</p>
<p class="programs">def read_csv(filename):<br/>    football = []<br/>    others = []<br/>    with open(filename) as f:<br/>        reader = csv.reader(f)<br/>        next(reader)<br/>        for row in reader:<br/>            if row[1] == '1':<br/>                football.append(row[0])<br/>            if row[2] == '1':<br/>                others.append(row[0])<br/><br/>    return football, others</p>
<h4 class="h4" id="ch05lev2sec09"><strong><em>#2: Law of Large Numbers</em></strong></h4>
<p class="noindent">We’ve referred to a die roll and coin toss as two examples of random events that we can simulate using random numbers. We’ve used the term <em>event</em> to refer to a certain number showing up on a die roll or to heads or tails showing up on a coin toss, with each event having an associated probability value. In probability, a <em>random variable</em>—usually denoted by <em>X</em>—describes an event. For example, <em>X</em> = 1 describes the event of 1 appearing upon a die roll, and <em>P</em>(<em>X</em> = 1) describes the associated probability. There are two kinds of random variables: (1) <em>discrete</em> random variables, which take only integral values and are the only kind of random variables we see in this chapter, and (2) <em>continuous</em> random variables, which—as the name suggests—can take any real value.</p>
<p class="indentb">The <em>expectation</em>, <em>E</em>, of a discrete random variable is the equivalent of the average or mean that we learned about in <a href="ch03.html#ch03">Chapter 3</a>. The expectation can be calculated as follows:</p>
<p class="center"><em>E</em> = <em>x</em><sub>1</sub><em>P</em>(<em>x</em><sub>1</sub>) + <em>x</em><sub>2</sub><em>P</em>(<em>x</em><sub>2</sub>) + <em>x</em><sub>3</sub><em>P</em>(<em>x</em><sub>3</sub>) + ... + <em>x<sub>n</sub>P</em>(<em>x<sub>n</sub></em>)</p>
<p class="indentt">Thus, for a six-sided die, the <em>expected value</em> of a die roll can be calculated like this:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">e = 1*(1/6) + 2*(1/6) + 3*(1/6) + 4*(1/6) + 5*(1/6) + 6*(1/6)</span><br/>&gt;&gt;&gt; <span class="codestrong">e</span><br/>3.5</p>
<p class="indent"><a id="page_144"></a>According to the <em>law of large numbers</em>, the average value of results over multiple trials approaches the expected value as the number of trials increases. Your challenge in this task is to verify this law when rolling a six-sided die for the following number of trials: 100, 1000, 10000, 100000, and 500000. Here’s an expected sample run of your complete program:</p>
<p class="programs">Expected value: 3.5<br/>Trials: 100 Trial average 3.39<br/>Trials: 1000 Trial average 3.576<br/>Trials: 10000 Trial average 3.5054<br/>Trials: 100000 Trial average 3.50201<br/>Trials: 500000 Trial average 3.495568</p>
<h4 class="h4" id="ch05lev2sec10"><strong><em>#3: How Many Tosses Before You Run Out of Money?</em></strong></h4>
<p class="noindent">Let’s consider a simple game played with a fair coin toss. A player wins $1 for heads and loses $1.50 for tails. The game is over when the player’s balance reaches $0. Given a certain starting amount specified by the user as input, your challenge is to write a program that simulates this game. Assume there’s an unlimited cash reserve with the computer—your opponent here. Here’s a possible game play session:</p>
<p class="programs">Enter your starting amount: 10<br/>Tails! Current amount: 8.5<br/>Tails! Current amount: 7.0<br/>Tails! Current amount: 5.5<br/>Tails! Current amount: 4.0<br/>Tails! Current amount: 2.5<br/>Heads! Current amount: 3.5<br/>Tails! Current amount: 2.0<br/>Tails! Current amount: 0.5<br/>Tails! Current amount: -1.0<br/>Game over :( Current amount: -1.0. Coin tosses: 9</p>
<h4 class="h4" id="ch05lev2sec11"><strong><em>#4: Shuffling a Deck of Cards</em></strong></h4>
<p class="noindent">Consider a standard deck of 52 playing cards. Your challenge here is to write a program to simulate the shuffling of this deck. To keep the implementation simple, I suggest you use the integers 1, 2, 3, ..., 52 to represent the deck. Every time you run the program, it should output a shuffled deck—in this case, a shuffled list of integers.</p>
<p class="indent">Here’s a possible output of your program:</p>
<p class="programs">[3, 9, 21, 50, 32, 4, 20, 52, 7, 13, 41, 25, 49, 36, 23, 45, 1, 22, 40, 19, 2,<br/>35, 28, 30, 39, 44, 29, 38, 48, 16, 15, 18, 46, 31, 14, 33, 10, 6, 24, 5, 43,<br/>47, 11, 34, 37, 27, 8, 17, 51, 12, 42, 26]</p>
<p class="indent"><a id="page_145"></a>The <span class="literal">random</span> module in Python’s standard library has a function, <span class="literal">shuffle()</span>, for this exact operation:</p>
<p class="programs">   &gt;&gt;&gt; <span class="codestrong">import random</span><br/>   &gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3, 4]</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">random.shuffle(x)</span><br/>   &gt;&gt;&gt; <span class="codestrong">x</span><br/>   [4, 2, 1, 3]</p>
<p class="indent">Create a list, <span class="literal">x</span>, consisting of the numbers [1, 2, 3, 4]. Then, call the <span class="literal">shuffle()</span> function <span class="ent">➊</span>, passing this list as an argument. You’ll see that the numbers in <span class="literal">x</span> have been shuffled. Note that the list is shuffled “in place.” That is, the original order is lost.</p>
<p class="indent">But what if you wanted to use this program in a card game? There, it’s not enough to simply output the shuffled list of integers. You’ll also need a way to map back the integers to the specific suit and rank of each card. One way you might do this is to create a Python class to represent a single card:</p>
<p class="programs">class Card:<br/>    def __init__(self, suit, rank):<br/>        self.suit = suit<br/>        self.rank = rank</p>
<p class="indent">To represent the ace of clubs, create a card object, <span class="literal">card1 = Card('clubs', 'ace')</span>. Then, do the same for all the other cards. Next, create a list consisting of each of the card objects and shuffle this list. The result will be a shuffled deck of cards where you also know the suit and rank of each card. Output of the program should look something like this:</p>
<p class="programs">10 of spades<br/>6 of clubs<br/>jack of spades<br/>9 of spades</p>
<h4 class="h4" id="ch05lev2sec12"><strong><em>#5: Estimating the Area of a Circle</em></strong></h4>
<p class="noindent">Consider a dartboard with a circle of radius <em>r</em> inscribed in a square with side 2<em>r</em>. Now let’s say you start throwing a large number of darts at it. Some of these will hit the board within the circle—let’s say, <em>N</em>—and others outside it—let’s say, <em>M</em>. If we consider the fraction of darts that land inside the circle,</p>
<div class="image2"><img src="images/e0145-01.jpg" alt="image" /></div>
<p class="noindent">then the value of <em>f</em> × <em>A</em>, where <em>A</em> is the area of the square, would roughly be equal to the area of the circle (see <a href="ch05.html#ch5fig6">Figure 5-6</a>). The darts are represented by the small circular dots in the figure. We shall refer to the value of <em>f</em> × <em>A</em> as the estimated area. The actual area is, of course, <em>πr</em><sup>2</sup>.</p>
<div class="image"><a id="page_146"></a><img src="images/f05-06.jpg" alt="image" /></div>
<p class="figuret"><a id="ch5fig6"></a><em>Figure 5-6: A circle of radius</em> r <em>inscribed in a square board with side 2</em>r<em>. The dots represent darts randomly thrown at the board.</em></p>
<p class="indent">As part of this challenge, write a program that will find the estimated area of a circle, given any radius, using this approach. The program should print the estimated area of the circle for three different values of the number of darts: 10<sup>3</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. That’s a lot of darts! You’ll see that increasing the number of darts brings the estimated area close to the actual area. Here’s a sample output of the completed solution:</p>
<p class="programs">Radius: 2<br/>Area: 12.566370614359172, Estimated (1000 darts): 12.576<br/>Area: 12.566370614359172, Estimated (100000 darts): 12.58176<br/>Area: 12.566370614359172, Estimated (1000000 darts): 12.560128</p>
<p class="indent">The dart throw can be simulated by a call to the <span class="literal">random.uniform(a, b)</span> function, which will return a random number between <em>a</em> and <em>b</em>. In this case, use the values <em>a</em> = 0, <em>b</em> = 2<em>r</em> (the side of the square).</p>
<h5 class="h5" id="ch05lev3sec12"><a id="page_147"></a><strong>Estimating the Value of Pi</strong></h5>
<p class="noindent">Consider <a href="ch05.html#ch5fig6">Figure 5-6</a> once again. The area of the square is 4<em>r</em><sup>2</sup>, and the area of the inscribed circle is <em>πr</em><sup>2</sup>. If we divide the area of the circle by the area of the square, we get <em>π</em>/4. The fraction <em>f</em> that we calculated earlier,</p>
<div class="image2"><img src="images/e0147-01.jpg" alt="image" /></div>
<p class="noindent">is thus an approximation of <em>π</em>/4, which in turn means that the value of</p>
<div class="image2"><img src="images/e0147-02.jpg" alt="image" /></div>
<p class="noindent">should be close to the value of <em>π</em>. Your next challenge is to write a program that will estimate the value of <em>π</em> assuming any value for the radius. As you increase the number of darts, the estimated value of <em>π</em> should get close to the known value of the constant.<a id="page_148"></a></p>
</div>
</body>
</html>