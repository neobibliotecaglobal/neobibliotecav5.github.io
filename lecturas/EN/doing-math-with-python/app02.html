<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>Appendix B: Overview of Python Topics</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><h2 class="h2" id="app02"><a id="page_221"></a><strong><span class="big">B</span></strong><br/><strong>Overview of Python Topics</strong></h2>
<div class="image1"><img src="images/common-01.jpg" alt="image" /></div>
<p class="noindent">The aim of this appendix is twofold: to provide a quick refresher on some Python topics that weren’t thoroughly introduced in the chapters and to introduce topics that will help you write better Python programs.</p>
<h3 class="h3" id="app02lev1sec01"><strong>if __name__ == '__main__'</strong></h3>
<p class="noindent">Throughout the book, we’ve used the following block of code, where <span class="literal">func()</span> is a function we’ve defined in the program:</p>
<p class="programs">if __name__ == '__main__':<br/>    # Do something<br/>    func()</p>
<p class="indent">This block of code ensures that the statements within the block are executed only when the program is run on its own.</p>
<p class="indent"><a id="page_222"></a>When a program runs, the special variable <span class="literal">__name__</span> is set to <span class="literal">__main__</span> automatically, so the <span class="literal">if</span> condition evaluates to <span class="literal">True</span> and the function <span class="literal">func()</span> is called. However, <span class="literal">__name__</span> is set differently when you import the program into another program (see “<a href="app02.html#app02lev1sec07">Reusing Code</a>” on <a href="app02.html#page_235">page 235</a>).</p>
<p class="indent">Here’s a quick demonstration. Consider the following program, which we’ll call <em>factorial.py</em>:</p>
<p class="programs">   # Find the factorial of a number<br/>   def fact(n):<br/>       p = 1<br/>       for i in range(1, n+1):<br/>           p = p*i<br/>       return p<br/><br/><span class="ent">➊</span> print(__name__)<br/><br/>   if __name__ == '__main__':<br/>       n = int(input('Enter an integer to find the factorial of: '))<br/>       f = fact(n)<br/>       print('Factorial of {0}: {1}'.format(n, f))</p>
<p class="indent">The program defines a function, <span class="literal">fact()</span>, that calculates the factorial of the integer passed to it. When you run it, it prints <span class="literal">__main__</span>, which corresponds to the <span class="literal">print</span> statement at <span class="ent">➊</span>, because <span class="literal">__name__</span> is automatically set to <span class="literal">__main__</span>. Then, it asks an integer to be entered, calculates the factorial, and prints it:</p>
<p class="programs">__main__<br/>Enter an integer to find the factorial of: 5<br/>Factorial of 5: 120</p>
<p class="indent">Now, say you need to calculate the factorial in another program. Instead of writing the function again, you decide to reuse this function by importing it:</p>
<p class="programs">from factorial import fact<br/>if __name__ == '__main__':<br/>    print('Factorial of 5: {0}'.format(fact(5)))</p>
<p class="indent">Note that both the programs must be in the same directory. When you run this program, you’ll get the following output:</p>
<p class="programs">factorial<br/>Factorial of 5: 120</p>
<p class="indent">When your program is imported by another program, the value of the variable <span class="literal">__main__</span> is set to that program’s filename, without the extension. In this case, the value of <span class="literal">__name__</span> is <span class="literal">factorial</span> instead of <span class="literal">__main__</span>. Because the condition <span class="literal">__name__ == '__main__'</span> now evaluates to <span class="literal">False</span>, the program doesn’t ask for the user’s input anymore. Remove the condition to see for yourself what happens!</p>
<p class="indent"><a id="page_223"></a>To summarize, it’s good practice to use <span class="literal">if __name__ == '__main__'</span> in your programs so that the statements you want executed when your program is run as a standalone are also <em>not</em> executed when your program is imported into another program.</p>
<h3 class="h3" id="app02lev1sec02"><strong>List Comprehensions</strong></h3>
<p class="noindent">Let’s say we have a list of integers and we want to create a new list containing the squares of the elements of the original list. Here’s one way that we could do this that’s already familiar to you:</p>
<p class="programs">   &gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3, 4]</span><br/>   &gt;&gt;&gt; <span class="codestrong">x_square = []</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">for n in x:</span><br/><span class="ent">➋</span>         <span class="codestrong">x_square.append(n**2)</span><br/>   &gt;&gt;&gt; <span class="codestrong">x_square</span><br/>   [1, 4, 9, 16]</p>
<p class="indent">Here, we used a code pattern that we’ve used in various programs throughout the book. We create an empty list, <span class="literal">x_square</span>, and then successively append to it as we calculate the square. We can do this in a more efficient way using <em>list comprehensions</em>:</p>
<p class="programs"><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong">x_square = [n**2 for n in x]</span><br/>   &gt;&gt;&gt; <span class="codestrong">x_square</span><br/>   [1, 4, 9, 16]</p>
<p class="indent">The statement at <span class="ent">➌</span> is referred to as a <em>list comprehension</em> in Python. It consists of an expression—here, <span class="literal">n**2</span>—followed by a <span class="literal">for</span> loop, <span class="literal">for n in x</span>. Note that it basically allows us to combine the two statements at <span class="ent">➊</span> and <span class="ent">➋</span> into one to create a new list in one statement.</p>
<p class="indent">As another example, consider one of the programs we wrote in “<a href="ch02.html#ch02lev3sec05">Drawing the Trajectory</a>” on <a href="ch02.html#page_51">page 51</a> to draw the trajectory of a body in projectile motion. In these programs, we have the following block of code to calculate the <em>x</em>- and <em>y</em>-coordinates of the body at each time instant:</p>
<p class="programs"># Find time intervals<br/>intervals = frange(0, t_flight, 0.001)<br/># List of x and y coordinates<br/>x = []<br/>y = []<br/>for t in intervals:<br/>    x.append(u*math.cos(theta)*t)<br/>    y.append(u*math.sin(theta)*t - 0.5*g*t*t)</p>
<p class="indent">Using list comprehension, you can rewrite the block of code as follows:</p>
<p class="programs"># Find time intervals<br/>intervals = frange(0, t_flight, 0.001)<br/># List of x and y coordinates<br/><a id="page_224"></a><br/>x = [u*math.cos(theta)*t for t in intervals]<br/>y = [u*math.sin(theta)*t - 0.5*g*t*t for t in intervals]</p>
<p class="indent">The code is more compact now, as you didn’t have to create the empty lists, write a <span class="literal">for</span> loop, and append to the lists. List comprehension lets you do this in a single statement.</p>
<p class="indent">You can also add conditionals to a list comprehension in order to selectively choose which list items are evaluated in the expression. Consider, once again, the first example:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3, 4]</span><br/>&gt;&gt;&gt; <span class="codestrong">x_square = [n**2 for n in x if n%2 == 0]</span><br/>&gt;&gt;&gt; <span class="codestrong">x_square</span><br/>[4, 16]</p>
<p class="indent">In this list comprehension, we use the <span class="literal">if</span> condition to explicitly tell Python to evaluate the expression <span class="literal">n**2</span> only on the even list items of <span class="literal">x</span>.</p>
<h3 class="h3" id="app02lev1sec03"><strong>Dictionary Data Structure</strong></h3>
<p class="noindent">We first used a Python dictionary in <a href="ch04.html#ch04">Chapter 4</a> while implementing the <span class="literal">subs()</span> method in SymPy. Let’s explore Python dictionaries in more detail. Consider a simple dictionary:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span></p>
<p class="indent">This code creates a dictionary with two keys—<span class="literal">'key1'</span> and <span class="literal">'key2'</span>—with values <span class="literal">5</span> and <span class="literal">20</span>, respectively. Only strings, numbers, and tuples can be keys in a Python dictionary. These data types are referred to as <em>immutable</em> data types—once created, they can’t be changed—so a list can’t be a key because we can add and remove elements from a list.</p>
<p class="indent">We already know that to retrieve the value corresponding to <span class="literal">'key1'</span> in the dictionary, we need to specify it as <span class="literal">d['key1']</span>. This is one of the most common use cases of a dictionary. A related use case is checking whether the dictionary contains a certain key, <span class="literal">'x'</span>. We can check that as follows:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span><br/>&gt;&gt;&gt; <span class="codestrong">'x' in d</span><br/>False</p>
<p class="indent">Once we create a dictionary, we can add a new key-value pair to it, similar to how we can append elements to a list. Here’s an example:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span><br/>&gt;&gt;&gt; <span class="codestrong">if 'x' in d:</span><br/>        <span class="codestrong">print(d['x'])</span><br/><span class="codestrong">else:</span><br/>        <span class="codestrong">d['x'] = 1</span><br/><a id="page_225"></a><br/>&gt;&gt;&gt; <span class="codestrong">d</span><br/>{'key1': 5, 'x': 1, 'key2': 20}</p>
<p class="indent">This code snippet checks whether the key <span class="literal">'x'</span> already exists in the dictionary, <span class="literal">d</span>. If it does, it prints the value corresponding to it; otherwise, it adds the key to the dictionary with <span class="literal">1</span> as the corresponding value. Similar to Python’s behavior with sets, Python can’t guarantee a particular order of the key-value pairs in a dictionary. The key-value pairs can be in any order, irrespective of the order of insertion.</p>
<p class="indent">Besides specifying the key as an index to the dictionary, we can also use the <span class="literal">get()</span> method to retrieve the value corresponding to the key:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">d.get('x')</span><br/>1</p>
<p class="indent">If you specify a nonexistent key to the <span class="literal">get()</span> method, <span class="literal">None</span> is returned. On the other hand, if you do so while using the index style of retrieving, you’ll get an error.</p>
<p class="indent">The <span class="literal">get()</span> method also lets you set a default value for nonexistent keys:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">d.get('y', 0)</span><br/>0</p>
<p class="indent">There’s no key <span class="literal">'y'</span> in the dictionary <span class="literal">d</span>, so <span class="literal">0</span> is returned. If there is a key, however, the value is returned instead:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">d['y'] = 1</span><br/>&gt;&gt;&gt; <span class="codestrong">d.get('y', 0)</span><br/>1</p>
<p class="indent">The <span class="literal">keys()</span> and <span class="literal">values()</span> methods each return a list-like data structure of all the keys and values, respectively, in a dictionary:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">d.keys()</span><br/>dict_keys(['key1', 'x', 'key2', 'y'])<br/>&gt;&gt;&gt; <span class="codestrong">d.values()</span><br/>dict_values([5, 1, 20, 1])</p>
<p class="indent">To iterate over the key and value pairs in a dictionary, use the <span class="literal">items()</span> method:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">d.items()</span><br/>dict_items([('key1', 5), ('x', 1), ('key2', 20), ('y', 1)])</p>
<p class="indent">This method returns a <em>view</em> of tuples, and each tuple is a key-value pair. We can use the following code snippet to print them nicely:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">for k, v in d.items():</span><br/>        <span class="codestrong">print(k, v)</span><br/><a id="page_226"></a><br/>key1 5<br/>x 1<br/>key2 20<br/>y 1</p>
<p class="indent">Views are more memory efficient than lists, and they don’t let you add or remove items.</p>
<h3 class="h3" id="app02lev1sec04"><strong>Multiple Return Values</strong></h3>
<p class="noindent">In the programs we’ve written so far, most of the functions return a single value, but functions sometimes return multiple values. We saw an example of such a function in “<a href="ch03.html#ch03lev1sec04">Measuring the Dispersion</a>” on <a href="ch03.html#page_71">page 71</a>, where in the program to find the range, we returned three numbers from the <span class="literal">find_range()</span> function. Here’s another example of the approach we took there:</p>
<p class="programs">import math<br/>def components(u, theta):<br/>    x = u*math.cos(theta)<br/>    y = u*math.sin(theta)<br/>    return x, y</p>
<p class="indent">The <span class="literal">components()</span> function accepts a velocity, <span class="literal">u</span>, and an angle, <span class="literal">theta</span>, in radians as parameters, and it calculates the <span class="literal">x</span> and <span class="literal">y</span> components and returns them. To return the calculated components, we simply list the corresponding Python labels in the return statement separated by a comma. This creates and returns a tuple consisting of the items <span class="literal">x</span> and <span class="literal">y</span>. In the calling code, we receive the multiple values:</p>
<p class="programs">if __name__ == '__main__':<br/>    theta = math.radians(45)<br/>    x, y = components(theta)</p>
<p class="indent">Because the <span class="literal">components()</span> function returns a tuple, we can retrieve the returned values using tuple indices:</p>
<p class="programs">c = components(theta)<br/>x = c[0]<br/>y = c[1]</p>
<p class="indent">This has advantages because we don’t have to know all the different values being returned. For one, you don’t have to write <span class="literal">x,y,z = myfunc1()</span> when the function returns three values or <span class="literal">a,x,y,z = myfunc1()</span> when the function returns four values, and so on.</p>
<p class="indent">In either of the preceding cases, the code calling the <span class="literal">components()</span> function must know which of the return values correspond to which component of the velocity, as there’s no way to know that from the values themselves.</p>
<p class="indent"><a id="page_227"></a>A user-friendly approach is to return a dictionary object instead, as we saw in the case of SymPy’s <span class="literal">solve()</span> function when used with the <span class="literal">dict=True</span> keyword argument. Here’s how we can rewrite the preceding components function to return a dictionary:</p>
<p class="programs">import math<br/><br/>def components(theta):<br/>    x = math.cos(theta)<br/>    y = math.sin(theta)<br/><br/>    return {'x': x, 'y': y}</p>
<p class="indent">Here, we return a dictionary with the keys <span class="literal">'x'</span> and <span class="literal">'y'</span> referring to the <span class="literal">x</span> and <span class="literal">y</span> components and their corresponding numerical values. With this new function definition, we don’t need to worry about the order of the returned values. We just use the key <span class="literal">'x'</span> to retrieve the <span class="literal">x</span> component and the key <span class="literal">'y'</span> to retrieve the <span class="literal">y</span> component:</p>
<p class="programs">if __name__ == '__main__':<br/>    theta = math.radians(45)<br/>    c = components(theta)<br/>    y = c['y']<br/>    x = c['x']<br/>    print(x, y)</p>
<p class="indent">This approach eliminates the need to use indices to refer to a specific returned value. The following code rewrites the program to find the range (see “<a href="ch03.html#ch03lev1sec04">Measuring the Dispersion</a>” on <a href="ch03.html#page_71">page 71</a>) so that the results are returned as a dictionary instead of a tuple:</p>
<p class="programs">   '''<br/>   Find the range using a dictionary to return values<br/>   '''<br/>   def find_range(numbers):<br/>       lowest = min(numbers)<br/>       highest = max(numbers)<br/>       # Find the range<br/>       r = highest-lowest<br/>       return {'lowest':lowest, 'highest':highest, 'range':r}<br/><br/>   if __name__ == '__main__':<br/>       donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]<br/>       result = find_range(donations)<br/><span class="ent">➊</span>     print('Lowest: {0} Highest: {1} Range: {2}'.<br/>              format(result['lowest'], result['highest'], result['range']))</p>
<p class="indent">The <span class="literal">find_range()</span> function now returns a dictionary with the keys <span class="literal">lowest</span>, <span class="literal">highest</span>, and <span class="literal">range</span> and with the lowest number, highest number, and the range as their corresponding values. At <span class="ent">➊</span>, we simply use the corresponding key to retrieve the corresponding value.</p>
<p class="indent"><a id="page_228"></a>If we were just interested in the range of a group of numbers and we didn’t care about the lowest and highest numbers, we’d just use <span class="literal">result['range']</span> and not worry about what other values were returned.</p>
<h3 class="h3" id="app02lev1sec05"><strong>Exception Handling</strong></h3>
<p class="noindent">In <a href="ch01.html#ch01">Chapter 1</a>, we learned that trying to convert a string such as <span class="literal">'1.1'</span> to an integer using the <span class="literal">int()</span> function results in a <span class="literal">ValueError</span> exception. But with a <span class="literal">try...except</span> block, we can print a user-friendly error message:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">try:</span><br/>        <span class="codestrong">int('1.1')</span><br/><span class="codestrong">except ValueError:</span><br/>        <span class="codestrong">print('Failed to convert 1.1 to an integer')</span><br/><br/>Failed to convert 1.1 to an integer</p>
<p class="indent">When any statement in the <span class="literal">try</span> block raises an exception, the type of exception raised is matched with the one specified by the <span class="literal">except</span> statement. If there’s a match, the program resumes in the <span class="literal">except</span> block. If the exception doesn’t match, the program execution halts and displays the exception. Here’s an example:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">try:</span><br/>        <span class="codestrong">print(1/0)</span><br/><span class="codestrong">except ValueError:</span><br/>        <span class="codestrong">print('Division unsuccessful')</span><br/><br/>Traceback (most recent call last):<br/>  File "&lt;pyshell#66&gt;", line 2, in &lt;module&gt;<br/>    print(1/0)<br/>ZeroDivisionError: division by zero</p>
<p class="indent">This code block attempts a division by 0, which results in a <span class="literal">ZeroDivisionError</span> exception. Although the division is carried out in a <span class="literal">try...except</span> block, the exception type is incorrectly specified, and the exception isn’t handled correctly. The correct way to handle this exception is to specify <span class="literal">ZeroDivisionError</span> as the exception type.</p>
<h4 class="h4" id="app02lev2sec01"><strong><em>Specifying Multiple Exception Types</em></strong></h4>
<p class="noindent">You can also specify multiple exception types. Consider the function <span class="literal">reciprocal()</span>, which returns the reciprocal of the number passed to it:</p>
<p class="programs">def reciprocal(n):<br/>    try:<br/>        print(1/n)<br/>    except (ZeroDivisionError, TypeError):<br/>        print('You entered an invalid number')</p>
<p class="indent"><a id="page_229"></a>We defined the function <span class="literal">reciprocal()</span>, which prints the reciprocal of the user’s input. We know that if the function is called with 0, it’ll cause a <span class="literal">ZeroDivisionError</span> exception. If you pass a string, however, it’ll cause a <span class="literal">TypeError</span> exception. The function considers both these cases as invalid input and specifies both <span class="literal">ZeroDivisionError</span> and <span class="literal">TypeError</span> in the <span class="literal">except</span> statement as a tuple.</p>
<p class="indent">Let’s try calling the function with a valid input—that is, a nonzero number:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">reciprocal(5)</span><br/>0.2</p>
<p class="indent">Next, we call the function with 0 as the argument:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">reciprocal(0)</span><br/>Enter an integer: <span class="codestrong">0</span><br/>You entered an invalid number</p>
<p class="indent">The <span class="literal">0</span> argument raises the <span class="literal">ZeroDivisionError</span> exception, which is in the tuple of exception types specified to the <span class="literal">except</span> statement, so the code prints an error message.</p>
<p class="indent">Now, let’s enter a string:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">reciprocal('1')</span></p>
<p class="indent">In this case, we entered an invalid number, which raises the <span class="literal">TypeError</span> exception. This exception is also in the tuple of specified exceptions, so the code prints an error message. If you want to give a more specific error message, we can just specify multiple <span class="literal">except</span> statements as follows:</p>
<p class="programs"><span class="codestrong">def reciprocal(n):</span><br/>    <span class="codestrong">try:</span><br/>        <span class="codestrong">print(1/n)</span><br/>    <span class="codestrong">except TypeError:</span><br/>        <span class="codestrong">print('You must specify a number')</span><br/>    <span class="codestrong">except ZeroDivisionError:</span><br/>        <span class="codestrong">print('Division by 0 is invalid')</span><br/><br/>&gt;&gt;&gt; <span class="codestrong">reciprocal(0)</span><br/>Division by 0 is invalid<br/>&gt;&gt;&gt; <span class="codestrong">reciprocal('1')</span><br/>You must specify a number</p>
<p class="indent">In addition to <span class="literal">TypeError</span>, <span class="literal">ValueError</span>, and <span class="literal">ZeroDivisionError</span>, there are a number of other built-in exception types. The Python documentation at <em><a href="https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions">https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions</a></em> lists the builtin exceptions for Python 3.4.</p>
<h4 class="h4" id="app02lev2sec02"><a id="page_230"></a><strong><em>The else Block</em></strong></h4>
<p class="noindent">The <span class="literal">else</span> block is used to specify which statements to execute when there’s no exception. Consider an example from the program we wrote to draw the trajectory of a projectile (see “<a href="ch02.html#ch02lev3sec05">Drawing the Trajectory</a>” on <a href="ch02.html#page_51">page 51</a>):</p>
<p class="programs">   if __name__ == '__main__':<br/>       try:<br/>           u = float(input('Enter the initial velocity (m/s): '))<br/>           theta = float(input('Enter the angle of projection (degrees): '))<br/>       except ValueError:<br/>           print('You entered an invalid input')<br/><span class="ent">➊</span>     else:<br/>           draw_trajectory(u, theta)<br/>           plt.show()</p>
<p class="indentb">If the input for <span class="literal">u</span> or <span class="literal">theta</span> couldn’t be converted to a floating point number, it doesn’t make sense for the program to call the <span class="literal">draw_trajectory()</span> and <span class="literal">plt.show()</span> functions. Instead, we specify these two statements in the <span class="literal">else</span> block at <span class="ent">➊</span>. Using <span class="literal">try...except...else</span> will let you manage different types of errors during runtime and take appropriate action when there is an error or when there is none:</p>
<p class="order">1. If there’s an exception and there’s an <span class="literal">except</span> statement corresponding to the exception type raised, the execution is transferred to the corresponding <span class="literal">except</span> block.</p>
<p class="order">2. If there’s no exception, the execution is transferred to the <span class="literal">else</span> block.</p>
<h3 class="h3" id="app02lev1sec06"><strong>Reading Files in Python</strong></h3>
<p class="noindent">Opening a file is the first step to reading data from it. Let’s start with a quick example. Consider a file that consists of a collection of numbers with one number per line:</p>
<p class="programs">100<br/>60<br/>70<br/>900<br/>100<br/>200<br/>500<br/>500<br/>503<br/>600<br/>1000<br/>1200</p>
<p class="indent"><a id="page_231"></a>We want to write a function that reads the file and returns a list of those numbers:</p>
<p class="programs">   def read_data(path):<br/>       numbers = []<br/><span class="ent">➊</span>     f = open(path)<br/><span class="ent">➋</span>     for line in f:<br/>           numbers.append(float(line))<br/>       f.close()<br/>       return numbers</p>
<p class="indent">First, we define the function <span class="literal">read_data()</span> and create an empty list to store all of the numbers. At <span class="ent">➊</span>, we use the <span class="literal">open()</span> function to open the file whose location has been specified via the argument path. An example of the path would be <em>/home/username/mydata.txt</em> on Linux, <em>C:\mydata.txt</em> on Microsoft Windows, or <em>/Users/Username/mydata.txt</em> on OS X. The <span class="literal">open()</span> function returns a file object, which we use the label <span class="literal">f</span> to refer to. We can go over each line of the file using a <span class="literal">for</span> loop at <span class="ent">➋</span>. Because each line is returned as a string, we convert it into a number and append it to the list <span class="literal">numbers</span>. The loop stops executing once all the lines have been read, and we close the file using the <span class="literal">close()</span> method. Finally, we return the <span class="literal">numbers</span> list.</p>
<p class="indent">This is similar to how we read the numbers from a file in <a href="ch03.html#ch03">Chapter 3</a>, although we didn’t have to close the file explicitly because we used a different approach there. Using the approach we took in <a href="ch03.html#ch03">Chapter 3</a>, we would rewrite the preceding function as follows:</p>
<p class="programs">   def read_data(path):<br/>       numbers = []<br/><span class="ent">➊</span>     with open(path) as f:<br/>           for line in f:<br/>               numbers.append(float(line))<br/><span class="ent">➋</span>     return numbers</p>
<p class="indent">The key statement here is at <span class="ent">➊</span>. It’s similar to writing <span class="literal">f = open(path)</span> but only partially. Besides opening the file and assigning the file object returned by <span class="literal">open()</span> to <span class="literal">f</span>, it also sets up a new <em>context</em> with all the statements in that block—in this case, all the statements before the <span class="literal">return</span> statement. When all the statements in the body have been executed, the file is automatically closed. That is, when the execution reaches the statement at <span class="ent">➋</span>, the file is closed without needing an explicit call to the <span class="literal">close()</span> method. This method also means that if there are any exceptions while working with the file, it’ll still be closed before the program exits. This is the preferred approach to working with files.</p>
<h4 class="h4" id="app02lev2sec03"><a id="page_232"></a><strong><em>Reading All the Lines at Once</em></strong></h4>
<p class="noindent">Instead of reading the lines one by one to build a list, we can use the <span class="literal">readlines()</span> method to read all the lines into a list at once. This results in a more compact function:</p>
<p class="programs">   def read_data(path):<br/>       with open(path) as f:<br/><span class="ent">➊</span>         lines = f.readlines()<br/>       numbers = [float(n) for n in lines]<br/>       return numbers</p>
<p class="indent">We read all the lines of the file into a list using the <span class="literal">readlines()</span> method at <span class="ent">➊</span>. Then, we convert each of the items in the list into a floating point number using the <span class="literal">float()</span> function and list comprehension. Finally, we return the list <span class="literal">numbers</span>.</p>
<h4 class="h4" id="app02lev2sec04"><strong><em>Specifying the Filename as Input</em></strong></h4>
<p class="noindent">The <span class="literal">read_data()</span> function takes the file path as an argument. If your program allows you to specify the filename as an input, this function should work for any file as long as the file contains data we expect to read. Here’s an example:</p>
<p class="programs">if __name__=='__main__':<br/>    data_file = input('Enter the path of the file: ')<br/>    data = read_data(data_file)<br/>    print(data)</p>
<p class="indent">Once you’ve added this code to the end of the <span class="literal">read_data()</span> function and run it, it’ll ask you to input the path to the file. Then, it’ll print the numbers it reads from the file:</p>
<p class="programscustom">Enter the path of the file <span class="codestrong">/home/amit/work/mydata.txt</span><br/>[100.0,60.0,70.0,900.0,100.0,200.0,500.0,500.0,503.0,600.0,1000.0,1200.0]</p>
<h4 class="h4" id="app02lev2sec05"><strong><em>Handling Errors When Reading Files</em></strong></h4>
<p class="noindent">There are a couple of things that can go wrong when reading files: (1) the file can’t be read, or (2) the data in the file isn’t in the expected format. Here’s an example of what happens when a file can’t be read:</p>
<p class="programs">Enter the path of the file: <span class="codestrong">/home/amit/work/mydata2.txt</span><br/>Traceback (most recent call last):<br/>  File "read_file.py", line 11, in &lt;module&gt;<br/>    data = read_data(data_file)<br/>  File "read_file.py", line 4, in read_data<br/>    with open(path) as f:<br/>FileNotFoundError: [Errno 2] No such file or directory: '/home/amit/work/<br/>mydata2.txt'</p>
<p class="indent"><a id="page_233"></a>Because I entered a file path that doesn’t exist, the <span class="literal">FileNotFoundError</span> exception is raised when we try to open the file. We can make the program display a user-friendly error message by modifying our <span class="literal">read_data()</span> function as follows:</p>
<p class="programs">def read_data(path):<br/>    numbers = []<br/>    try:<br/>        with open(path) as f:<br/>            for line in f:<br/>                numbers.append(float(line))<br/>    except FileNotFoundError:<br/>        print('File not found')<br/>    return numbers</p>
<p class="indent">Now, when you specify a nonexistent file path, you’ll get an error message instead:</p>
<p class="programs">Enter the path of the file: <span class="codestrong">/home/amit/work/mydata2.txt</span><br/>File not found</p>
<p class="indent">The second source of errors can be that the data in the file isn’t what your program expects to read. For example, consider a file that has the following:</p>
<p class="programs">10<br/>20<br/>3o<br/>1/5<br/>5.6</p>
<p class="indent">The third line in this file isn’t convertible to a floating point number because it has the letter <span class="literal">o</span> in it instead of the number <span class="literal">0</span>, and the fourth line consists of <span class="literal">1/5</span>, a fraction in string form, which <span class="literal">float()</span> can’t handle.</p>
<p class="indent">If you supply this data file to the earlier program, it’ll produce the following error:</p>
<p class="programs">Enter the path of the file: <span class="codestrong">bad_data.txt</span><br/>Traceback (most recent call last):<br/>  File "read_file.py", line 13, in &lt;module&gt;<br/>    data = read_data(data_file)<br/>  File "read_file.py", line 6, in read_data<br/>    numbers.append(float(line))<br/>ValueError: could not convert string to float: '3o\n'</p>
<p class="indent">The third line in the file is <span class="literal">3o</span>, not the number <span class="literal">30</span>, so when we attempt to convert it into a floating point number, the result is <span class="literal">ValueError</span>. There are two approaches you can take when such data is present in a file. The first <a id="page_234"></a>is to report the error and exit the program. The modified <span class="literal">read_data()</span> function would appear as follows:</p>
<p class="programs">   def read_data(path):<br/>       numbers = []<br/>       try:<br/>           with open(path) as f:<br/>               for line in f:<br/><span class="ent">➊</span>               try:<br/><span class="ent">➋</span>                   n = float(line)<br/>                 except ValueError:<br/>                     print('Bad data: {0}'.format(line))<br/><span class="ent">➌</span>                   break<br/><span class="ent">➍</span>               numbers.append(n)<br/>       except FileNotFoundError:<br/>           print('File not found')<br/>       return numbers</p>
<p class="indent">We insert another <span class="literal">try...except</span> block in the function starting at <span class="ent">➊</span>, and we convert the line into a floating point number at <span class="ent">➋</span>. If the program raises the <span class="literal">ValueError</span> exception, we print an error message with the offending line and exit out of the <span class="literal">for</span> loop using <span class="literal">break</span> at <span class="ent">➌</span>. The program then stops reading the file. The returned list, <span class="literal">numbers</span>, contains all the data that was successfully read before encountering the bad data. If there’s no error, we append the floating point number to the <span class="literal">numbers</span> list at <span class="ent">➍</span>.</p>
<p class="indent">Now when you supply the file <em>bad_data.txt</em> to the program, it’ll read only the first two lines, display the error message, and exit:</p>
<p class="programs">Enter the path of the file: <span class="codestrong">bad_data.txt</span><br/>Bad data: 3o<br/><br/>[10.0, 20.0]</p>
<p class="indent">Returning partial data may not be desirable, so we could just replace the break statement at <span class="ent">➌</span> with <span class="literal">return</span> and no data would be returned.</p>
<p class="indent">The second approach is to ignore the error and continue with the rest of the file. Here’s a modified <span class="literal">read_data()</span> function that does this:</p>
<p class="programs">   def read_data(path):<br/>       numbers = []<br/>       try:<br/>           with open(path) as f:<br/>               for line in f:<br/>                   try:<br/>                       n = float(line)<br/>                   except ValueError:<br/>                       print('Bad data: {0}'.format(line))<br/><span class="ent">➊</span>                     continue<br/>                   numbers.append(n)<br/>       except FileNotFoundError:<br/>           print('File not found')<br/>       return numbers</p>
<p class="indent"><a id="page_235"></a>The only change here is that instead of breaking out of the <span class="literal">for</span> loop, we just continue with the next iteration using the <span class="literal">continue</span> statement at <span class="ent">➊</span>. The output from the program is now as follows:</p>
<p class="programs">Bad data: 3o<br/><br/>Bad data: 1/5<br/><br/>[10.0, 20.0, 5.6]</p>
<p class="indent">The specific application where you’re reading the file will determine which of the above approaches you want to take to handle bad data.</p>
<h3 class="h3" id="app02lev1sec07"><strong>Reusing Code</strong></h3>
<p class="noindent">Throughout this book, we’ve used classes and functions that were either part of the Python standard library or available after installing third-party packages, such as matplotlib and SymPy. Now we’ll look at a quick example of how we can import our own programs into other programs.</p>
<p class="indent">Consider the function <span class="literal">find_corr_x_y()</span> that we wrote in “<a href="ch03.html#ch03lev1sec05">Calculating the Correlation Between Two Data Sets</a>” on <a href="ch03.html#page_75">page 75</a>. We’ll create a separate file, <em>correlation.py</em>, which has only the function definition:</p>
<p class="programs">'''<br/>Function to calculate the linear correlation coefficient<br/>'''<br/><br/>def find_corr_x_y(x,y):<br/>    # Size of each set<br/>    n = len(x)<br/><br/>    # Find the sum of the products<br/>    prod=[]<br/>    for xi,yi in zip(x,y):<br/>        prod.append(xi*yi)<br/><br/>    sum_prod_x_y = sum(prod)<br/>    sum_x = sum(x)<br/>    sum_y = sum(y)<br/>    squared_sum_x = sum_x**2<br/>    squared_sum_y = sum_y**2<br/><br/>    x_square=[]<br/>    for xi in x:<br/>        x_square.append(xi**2)<br/>    x_square_sum = sum(x_square)<br/><br/>    y_square=[]<br/>    for yi in y:<br/>        y_square.append(yi**2)<br/>    y_square_sum = sum(y_square)<br/><br/>    numerator = n*sum_prod_x_y - sum_x*sum_y<br/>    denominator_term1 = n*x_square_sum - squared_sum_x<br/>    denominator_term2 = n*y_square_sum - squared_sum_y<br/>    denominator = (denominator_term1*denominator_term2)**0.5<br/><br/>    correlation = numerator/denominator<br/><br/>    return correlation</p>
<p class="indent"><a id="page_236"></a>Without the <em>.py</em> file extension, a Python file is referred to as a module. This is usually reserved for files that define classes and functions that’ll be used in other programs. The following program imports the <span class="literal">find_corr_x_y()</span> function from the correlation module we just defined:</p>
<p class="programs">from correlation import find_corr_x_y<br/>if __name__ == '__main__':<br/>    high_school_math = [83, 85, 84, 96, 94, 86, 87, 97, 97, 85]<br/>    college_admission = [85, 87, 86, 97, 96, 88, 89, 98, 98, 87]<br/>    corr = find_corr_x_y(high_school_math, college_admission)<br/>    print('Correlation coefficient: {0}'.format(corr))</p>
<p class="indent">This program finds the correlation between the high school math grades and college admission scores of students we considered in <a href="ch03.html#ch3tab3">Table 3-3</a> on <a href="ch03.html#page_80">page 80</a>. We import the <span class="literal">find_corr_x_y()</span> function from the correlation module, create the lists representing the two sets of grades, and call the <span class="literal">find_corr_x_y()</span> function with the two lists as arguments. When you run the program, it’ll print the correlation coefficient. Note that the two files must be in the same directory—this is strictly to keep things simple.</p>
</div>
</body>
</html>