<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
<head>
  <meta charset="UTF-8" />
  <title>Chapter 6: Drawing Geometric Shapes and Fractals</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  <link type="text/css" rel="stylesheet" media="all" href="core.css" />
</head>
<body>
  <div id="sbo-rt-content"><h2 class="h2" id="ch06"><a id="page_149"></a><strong><span class="big">6</span></strong><br/><strong>Drawing Geometric Shapes and Fractals</strong></h2>
<div class="image1"><img src="images/common-01.jpg" alt="image" /></div>
<p class="noindent">In this chapter, we’ll start by learning about patches in matplotlib that allow us to draw geometric shapes, such as circles, triangles, and polygons. We’ll then learn about matplotlib’s animation support and write a program to animate a projectile’s trajectory. In the final section, we’ll learn how to draw <em>fractals</em>—complex geometric shapes created by the repeated applications of simple geometric transformations. Let’s get started!</p>
<h3 class="h3" id="ch06lev1sec01"><a id="page_150"></a><strong>Drawing Geometric Shapes with Matplotlib’s Patches</strong></h3>
<p class="noindent">In matplotlib, <em>patches</em> allow us to draw geometric shapes, each of which we refer to as a <em>patch</em>. You can specify, for example, a circle’s radius and center in order to add the corresponding circle to your plot. This is quite different from how we’ve used matplotlib so far, which has been to supply the <em>x</em>- and <em>y</em>-coordinates of the points to plot. Before we can write a program to make use of the patches feature, however, we’ll need to understand a little bit more about how a matplotlib plot is created. Consider the following program, which plots the points (1, 1), (2, 2), and (3, 3) using matplotlib:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">import matplotlib.pyplot as plt</span><br/>&gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">y = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">plt.plot(x, y)</span><br/>[&lt;matplotlib.lines.Line2D object at 0x7fe822d67a20&gt;]<br/>&gt;&gt;&gt; <span class="codestrong">plt.show()</span></p>
<p class="indent">This program creates a matplotlib window that shows a line passing through the given points. Under the hood, when the <span class="literal">plt.plot()</span> function is called, a <span class="literal">Figure</span> object is created, within which the axes are created, and finally the data is plotted within the axes (see <a href="ch06.html#ch6fig1">Figure 6-1</a>).<a id="fn_03" href="footnote.html#fn03"><sup>1</sup></a></p>
<div class="image"><img src="images/f06-01.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig1"></a><em>Figure 6-1: Architecture of a matplotlib plot</em></p>
<p class="indent"><a id="page_151"></a>The following program re-creates this plot, but we’ll also explicitly create the <span class="literal">Figure</span> object and add axes to it, instead of just calling the <span class="literal">plot()</span> function and relying on it to create those:</p>
<p class="programs">   &gt;&gt;&gt; <span class="codestrong">import matplotlib.pyplot as plt</span><br/>   &gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3]</span><br/>   &gt;&gt;&gt; <span class="codestrong">y = [1, 2, 3]</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">fig = plt.figure()</span><br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong">ax = plt.axes()</span><br/>   &gt;&gt;&gt; <span class="codestrong">plt.plot(x, y)</span><br/>   [&lt;matplotlib.lines.Line2D object at 0x7f9bad1dcc18&gt;]<br/>   &gt;&gt;&gt; <span class="codestrong">plt.show()</span><br/>   &gt;&gt;&gt;</p>
<p class="indent">Here, we create the <span class="literal">Figure</span> object using the <span class="literal">figure()</span> function at <span class="ent">➊</span>, and then we create the axes using the <span class="literal">axes()</span> function at <span class="ent">➋</span>. The <span class="literal">axes()</span> function also adds the axes to the <span class="literal">Figure</span> object. The last two lines are the same as in the earlier program. This time, when we call the <span class="literal">plot()</span> function, it sees that a <span class="literal">Figure</span> object with an <span class="literal">Axes</span> object already exists and directly proceeds to plot the data supplied to it.</p>
<p class="indent">Besides manually creating <span class="literal">Figure</span> and <span class="literal">Axes</span> objects, you can use two different functions in the <span class="literal">pyplot</span> module to get a reference to the current <span class="literal">Figure</span> and <span class="literal">Axes</span> objects. When you call the <span class="literal">gcf()</span> function, it returns a reference to the current <span class="literal">Figure</span>, and when you call the <span class="literal">gca()</span> function, it returns a reference to the current <span class="literal">Axes</span>. An interesting feature of these functions is that each will create the respective object if it doesn’t already exist. How these functions work will become clearer as we make use of them later in this chapter.</p>
<h4 class="h4" id="ch06lev2sec01"><strong><em>Drawing a Circle</em></strong></h4>
<p class="noindent">To draw a circle, you can add the <span class="literal">Circle</span> patch to the current <span class="literal">Axes</span> object, as demonstrated by the following example:</p>
<p class="programs">   '''<br/>   Example of using matplotlib's Circle patch<br/>   '''<br/>   import matplotlib.pyplot as plt<br/><br/>   def create_circle():<br/><span class="ent">➊</span>     circle = plt.Circle((0, 0), radius = 0.5)<br/>       return circle<br/><br/>   def show_shape(patch):<br/><span class="ent">➋</span>     ax = plt.gca()<br/>       ax.add_patch(patch)<br/>       plt.axis('scaled')<br/>       plt.show()<br/><br/>   if __name__ == '__main__':<br/><span class="ent">➌</span>     c = create_circle()<br/>       show_shape(c)</p>
<p class="indent"><a id="page_152"></a>In this program, we’ve separated the creation of the <span class="literal">Circle</span> patch object and the addition of the patch to the figure into two functions: <span class="literal">create_circle()</span> and <span class="literal">show_shape()</span>. In <span class="literal">create_circle()</span>, we make a circle with a center at (0, 0) and a radius of 0.5 by creating a <span class="literal">Circle</span> object with the coordinates of the center (0, 0) passed as a tuple and with the radius of 0.5 passed using the keyword argument of the same name at <span class="ent">➊</span>. The function returns the created <span class="literal">Circle</span> object.</p>
<p class="indent">The <span class="literal">show_shape()</span> function is written such that it will work with any matplotlib patch. It first gets a reference to the current <span class="literal">Axes</span> object using the <span class="literal">gca()</span> function at <span class="ent">➋</span>. Then, it adds the patch passed to it using the <span class="literal">add_patch()</span> function and, finally, calls the <span class="literal">show()</span> function to display the figure. We call the <span class="literal">axis()</span> function here with the <span class="literal">scaled</span> parameter, which basically tells matplotlib to automatically adjust the axis limits. We’ll need to have this statement in all programs that use patches to automatically scale the axes. You can, of course, also specify fixed values for the limits, as we saw in <a href="ch02.html#ch02">Chapter 2</a>.</p>
<p class="indent">At <span class="ent">➌</span>, we call the <span class="literal">create_circle()</span> function using the label <span class="literal">c</span> to refer to the returned <span class="literal">Circle</span> object. Then, we call the <span class="literal">show_shape()</span> function, passing <span class="literal">c</span> as an argument. When you run the program, you’ll see a matplotlib window showing the circle (see <a href="ch06.html#ch6fig2">Figure 6-2</a>).</p>
<div class="image"><img src="images/f06-02.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig2"></a><em>Figure 6-2: A circle with a center of (0, 0) and radius of 0.5</em></p>
<p class="indent"><a id="page_153"></a>The circle doesn’t quite look like a circle here, as you can see. This is due to the automatic aspect ratio, which determines the ratio of the length of the <em>x</em>- and <em>y</em>-axes. If you insert the statement <span class="literal">ax.set_aspect('equal')</span> after <span class="ent">➋</span>, you will see that the circle does indeed look like a circle. The <span class="literal">set_aspect()</span> function is used to set the aspect ratio of the graph; using the <span class="literal">equal</span> argument, we ask matplotlib to set the ratio of the length of the <em>x</em>- and <em>y</em>-axes to 1:1.</p>
<p class="indent">Both the edge color and the face color (fill color) of the patch can be changed using the <span class="literal">ec</span> and <span class="literal">fc</span> keyword arguments. For example, passing <span class="literal">fc='g'</span> and <span class="literal">ec='r'</span> will create a circle with a green face color and red edge color.</p>
<p class="indent">Matplotlib supports a number of other patches, such as <span class="literal">Ellipse</span>, <span class="literal">Polygon</span>, and <span class="literal">Rectangle</span>.</p>
<h4 class="h4" id="ch06lev2sec02"><strong><em>Creating Animated Figures</em></strong></h4>
<p class="noindent">Sometimes we may want to create figures with moving shapes. Matplotlib’s animation support will help us achieve this. At the end of this section, we’ll create an animated version of the projectile trajectory-drawing program.</p>
<p class="indent">First, let’s see a simpler example. We’ll draw a matplotlib figure with a circle that starts off small and grows to a certain radius indefinitely (unless the matplotlib window is closed):</p>
<p class="programs">   '''<br/>   A growing circle<br/>   '''<br/><br/>   from matplotlib import pyplot as plt<br/>   from matplotlib import animation<br/><br/>   def create_circle():<br/>       circle = plt.Circle((0, 0), 0.05)<br/>       return circle<br/><br/>   def update_radius(i, circle):<br/>       circle.radius = i*0.5<br/>       return circle,<br/><br/>   def create_animation():<br/><span class="ent">➊</span>     fig = plt.gcf()<br/>       ax = plt.axes(xlim=(-10, 10), ylim=(-10, 10))<br/>       ax.set_aspect('equal')<br/>       circle = create_circle()<br/><span class="ent">➋</span>     ax.add_patch(circle)<br/><span class="ent">➌</span>     anim = animation.FuncAnimation(<br/>           fig, update_radius, fargs = (circle,), frames=30, interval=50)<br/>       plt.title('Simple Circle Animation')<br/>       plt.show()<br/><br/>   if __name__ == '__main__':<br/>       create_animation()</p>
<p class="indentb"><a id="page_154"></a>We start by importing the <span class="literal">animation</span> module from the matplotlib package. The <span class="literal">create_animation()</span> function carries out the core functionality here. It gets a reference to the current <span class="literal">Figure</span> object using the <span class="literal">gcf()</span> function at <span class="ent">➊</span> and then creates the axes with limits of –10 and 10 for both the <em>x</em>- and <em>y</em>-axes. After that, it creates a <span class="literal">Circle</span> object that represents a circle with a radius of 0.05 and a center at (0, 0) and adds this circle to the current axes at <span class="ent">➋</span>. Then, we create a <span class="literal">FuncAnimation</span> object <span class="ent">➌</span>, which passes the following data about the animation we want to create:</p>
<p class="itemlist"><span class="literal"><span class="codestrong">fig</span></span> This is the current <span class="literal">Figure</span> object.</p>
<p class="itemlist"><span class="literal"><span class="codestrong">update_radius</span></span> This function will be responsible for drawing <em>every</em> frame. It takes two arguments—a frame number that is automatically passed to it when called and the patch object that we want to update every frame. This function also must return the object.</p>
<p class="itemlist"><span class="literal"><span class="codestrong">fargs</span></span> This tuple consists of all the arguments to be passed to the <span class="literal">update_radius()</span> function other than the frame number. If there are no such arguments to pass, this keyword argument need not be specified.</p>
<p class="itemlist"><span class="literal"><span class="codestrong">frames</span></span> This is the number of frames in the animation. Our function <span class="literal">update_radius()</span> is called this many times. Here, we’ve arbitrarily chosen 30 frames.</p>
<p class="itemlist"><span class="literal"><span class="codestrong">interval</span></span> This is the time interval in milliseconds between two frames. If your animation seems too slow, decrease this value; if it seems too fast, increase this value.</p>
<p class="indentt">We then set a title using the <span class="literal">title()</span> function and, finally, show the figure using the <span class="literal">show()</span> function.</p>
<p class="indent">As mentioned earlier, the <span class="literal">update_radius()</span> function is responsible for updating the property of the circle that will change each frame. Here, we set the radius to <span class="literal">i*0.5</span>, where <span class="literal">i</span> is the frame number. As a result, you see a circle that grows every frame for 30 frames—thus, the radius of the largest circle is 15. Because the axes’ limits are set at –10 and 10, this gives the effect of the circle exceeding the figure’s dimensions. When you run the program, you’ll see your first animated figure, as shown in <a href="ch06.html#ch6fig3">Figure 6-3</a>.</p>
<p class="indent">You’ll notice that the animation continues until you close the matplotlib window. This is the default behavior, which you can change by setting the keyword argument to <span class="literal">repeat=False</span> when you create the <span class="literal">FuncAnimation</span> object.</p>
<div class="image"><a id="page_155"></a><img src="images/f06-03.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig3"></a><em>Figure 6-3: Simple circle animation</em></p>
<div class="sidebar">
<p class="sidebart"><strong>FUNCANIMATION OBJECT AND PERSISTENCE</strong></p>
<p class="noindent">You probably noted in the animated circle program that we assigned the created <span class="literal">FuncAnimation</span> object to the label <span class="literal">anim</span> even though we don’t use it again elsewhere. This is because of an issue with matplotlib’s current behavior—it doesn’t store any reference to the <span class="literal">FuncAnimation</span> object, making it subject to garbage collection by Python. This means the animation will not be created. Creating a label referring to the object prevents this from happening.</p>
<p class="indent">For more on this issue, you may want to follow the discussions at <em><a href="https://github.com/matplotlib/matplotlib/issues/1656/">https://github.com/matplotlib/matplotlib/issues/1656/</a></em>.</p>
</div>
<h4 class="h4" id="ch06lev2sec03"><a id="page_156"></a><strong><em>Animating a Projectile’s Trajectory</em></strong></h4>
<p class="noindent">In <a href="ch02.html#ch02">Chapter 2</a>, we drew the trajectory for a ball in projectile motion. Here, we’ll build upon this drawing, making use of matplotlib’s animation support to animate the trajectory so that it will come closer to demonstrating how you’d see a ball travel in real life:</p>
<p class="programs">   '''<br/>   Animate the trajectory of an object in projectile motion<br/>   '''<br/><br/>   from matplotlib import pyplot as plt<br/>   from matplotlib import animation<br/>   import math<br/><br/>   g = 9.8<br/><br/>   def get_intervals(u, theta):<br/><br/>       t_flight = 2*u*math.sin(theta)/g<br/>       intervals = []<br/>       start = 0<br/>       interval = 0.005<br/>       while start &lt; t_flight:<br/>           intervals.append(start)<br/>           start = start + interval<br/>       return intervals<br/><br/>   def update_position(i, circle, intervals, u, theta):<br/><br/>       t = intervals[i]<br/>       x = u*math.cos(theta)*t<br/>       y = u*math.sin(theta)*t - 0.5*g*t*t<br/>       circle.center = x, y<br/>       return circle,<br/><br/>   def create_animation(u, theta):<br/><br/>       intervals = get_intervals(u, theta)<br/><br/>       xmin = 0<br/>       xmax = u*math.cos(theta)*intervals[-1]<br/>       ymin = 0<br/>       t_max = u*math.sin(theta)/g<br/><span class="ent">➊</span>     ymax = u*math.sin(theta)*t_max - 0.5*g*t_max**2<br/>       fig = plt.gcf()<br/><span class="ent">➋</span>     ax = plt.axes(xlim=(xmin, xmax), ylim=(ymin, ymax))<br/><br/>       circle = plt.Circle((xmin, ymin), 1.0)<br/>       ax.add_patch(circle)<br/><a id="page_157"></a><br/><span class="ent">➌</span>     anim = animation.FuncAnimation(fig, update_position,<br/>                           fargs=(circle, intervals, u, theta),<br/>                           frames=len(intervals), interval=1,<br/>                           repeat=False)<br/><br/>       plt.title('Projectile Motion')<br/>       plt.xlabel('X')<br/>       plt.ylabel('Y')<br/>       plt.show()<br/><br/>   if __name__ == '__main__':<br/>       try:<br/>           u = float(input('Enter the initial velocity (m/s): '))<br/>           theta = float(input('Enter the angle of projection (degrees): '))<br/>       except ValueError:<br/>           print('You entered an invalid input')<br/>       else:<br/>           theta = math.radians(theta)<br/>           create_animation(u, theta)</p>
<p class="indent">The <span class="literal">create_animation()</span> function accepts two arguments: <span class="literal">u</span> and <span class="literal">theta</span>. These arguments correspond to the initial velocity and the angle of projection (<em>θ</em>), which were supplied as input to the program. The <span class="literal">get_intervals()</span> function is used to find the time intervals at which to calculate the <em>x</em>- and <em>y</em>-coordinates. This function is implemented by making use of the same logic we used in <a href="ch02.html#ch02">Chapter 2</a>, when we implemented a separate function, <span class="literal">frange()</span>, to help us.</p>
<p class="indent">To set up the axis limits for the animation, we’ll need to find the minimum and maximum values of <em>x</em> and <em>y</em>. The minimum value for each is 0, which is the initial value for each. The maximum value of the <em>x</em>-coordinate is the value of the coordinate at the end of the flight of the ball, which is the last time interval in the list <span class="literal">intervals</span>. The maximum value of the <em>y</em>-coordinate is when the ball is at its highest point—that is, at <span class="ent">➊</span>, where we calculate that point using the formula</p>
<div class="image2"><img src="images/e0157-01.jpg" alt="image" /></div>
<p class="indent">Once we have the values, we create the axes at <span class="ent">➋</span>, passing the appropriate axis limits. In the next two statements, we create a representation of the ball and add it to the figure’s <span class="literal">Axes</span> object by creating a circle of radius <span class="literal">1.0</span> at (<span class="literal">xmin</span>, <span class="literal">ymin</span>)—the minimum coordinates of the <em>x</em>- and <em>y</em>-axes, respectively.</p>
<p class="indentb">We then create the <span class="literal">FuncAnimation</span> object <span class="ent">➌</span>, supplying it with the current figure object and the following arguments:</p>
<p class="itemlist"><span class="literal"><span class="codestrong">update_position</span></span> This function will change the center of the circle in each frame. The idea here is that a new frame is created for every time interval, so we set the number of frames to the size of the time <a id="page_158"></a>intervals (see the description of <span class="literal">frames</span> in this list). We calculate the <em>x</em>-and <em>y</em>-coordinates of the ball at the time instant at the <span class="literal">i</span>th time interval, and we set the center of the circle to these values.</p>
<p class="itemlist"><span class="literal"><span class="codestrong">fargs</span></span> The <span class="literal">update_position()</span> function needs to access the list of time intervals, intervals, initial velocity, and theta, which are specified using this keyword argument.</p>
<p class="itemlist"><span class="literal"><span class="codestrong">frames</span></span> Because we’ll draw one frame per time interval, we set the number of frames to the size of the <span class="literal">intervals</span> list.</p>
<p class="itemlist"><span class="literal"><span class="codestrong">repeat</span></span> As we discussed in the first animation example, animation repeats indefinitely by default. We don’t want that to happen in this case, so we set this keyword to <span class="literal">False</span>.</p>
<p class="indentt">When you run the program, it asks for the initial inputs and then creates the animation, as shown in <a href="ch06.html#ch6fig4">Figure 6-4</a>.</p>
<div class="image"><img src="images/f06-04.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig4"></a><em>Figure 6-4: Animation of the trajectory of a projectile</em></p>
<h3 class="h3" id="ch06lev1sec02"><strong>Drawing Fractals</strong></h3>
<p class="noindent">Fractals are complex geometric patterns or shapes arising out of surprisingly simple mathematical formulas. Compared to geometric shapes, such as circles and rectangles, a fractal seems irregular and without any obvious pattern or description, but if you look closely, you see that patterns emerge and the entire shape is composed of numerous copies of itself. Because fractals involve the repetitive application of the same <em>geometric transformation</em> of points in a plane, computer programs are well-suited to create them. In this chapter, we’ll learn how to draw the Barnsley fern, the Sierpiński triangle, and the Mandelbrot set (the latter two in the challenges)— popular examples of fractals studied in the field. Fractals abound in nature, too—popular examples include coastlines, trees, and snowflakes.</p>
<h4 class="h4" id="ch06lev2sec04"><strong><em>Transformations of Points in a Plane</em></strong></h4>
<p class="noindent">A basic idea in creating fractals is that of the transformation of a point. Given a point, <em>P</em>(<em>x</em>, <em>y</em>), in an <em>x</em>-<em>y</em> plane, an example of a transformation is <em>P</em> (<em>x</em>, <em>y</em>) → <em>Q</em> (<em>x</em> + 1, <em>y</em> + 1), which means that after applying the <a id="page_159"></a>transformation, a new point, <em>Q</em>, which is one unit above and one unit to the right of <em>P</em>, is created. If you then consider <em>Q</em> as the starting point, you’ll get another point, <em>R</em>, that’s one unit above and one unit to the right of <em>Q</em>. Consider the starting point, <em>P</em>, to be (1, 1). <a href="ch06.html#ch6fig5">Figure 6-5</a> shows what the points would look like.</p>
<div class="image"><img src="images/f06-05.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig5"></a><em>Figure 6-5: The points</em> Q <em>and</em> R <em>have been obtained by applying a transformation to the point</em> P <em>for two iterations.</em></p>
<p class="indentb">This transformation is, thus, a rule describing how a point moves around in the <em>x</em>-<em>y</em> plane, starting from an initial position and moving to a different point at each iteration. We can think of a transformation as the point’s <em>trajectory</em> in the plane. Now, consider that instead of one transformation rule, there are two such rules and one of these transformations is picked at <em>random</em> at every step. Let’s consider these rules:</p>
<p class="equation">Rule 1: <em>P</em> 1 (<em>x</em>, <em>y</em>) → <em>P</em> 2 (<em>x</em> + 1, <em>y</em> – 1)</p>
<p class="equation">Rule 2: <em>P</em> 1 (<em>x</em>, <em>y</em>) → <em>P</em> 2 (<em>x</em> + 1, <em>y</em> + 1)</p>
<p class="indenttb"><a id="page_160"></a>Consider <em>P</em>1(1, 1) to be the starting point. If we carry out four iterations, we could have the following sequence of points:</p>
<p class="equation"><em>P</em> 1 (1, 1) → <em>P</em> 2 (2, 0) (Rule 1)</p>
<p class="equation"><em>P</em> 2 (2, 0) → <em>P</em> 3 (3, 1) (Rule 2)</p>
<p class="equation"><em>P</em> 3 (3, 1) → <em>P</em> 4 (4, 2) (Rule 2)</p>
<p class="equation"><em>P</em> 4 (4, 2) → <em>P</em> 5 (5, 1) (Rule 1)</p>
<p class="equation">... and so on.</p>
<p class="indentt">The transformation rule is picked at random, with each rule having an equal probability of being selected. No matter which one is picked, the points will advance toward the right because we increase the <em>x</em>-coordinate in both cases. As the points go to the right, they move either up or down, thus creating a zigzag path. The following program charts out the path of a point when subjected to one of these transformations for a specified number of iterations:</p>
<p class="programs">   '''<br/>   Example of selecting a transformation from two equally probable<br/>   transformations<br/>   '''<br/>   import matplotlib.pyplot as plt<br/>   import random<br/><br/>   def transformation_1(p):<br/>       x = p[0]<br/>       y = p[1]<br/>       return x + 1, y - 1<br/><br/>   def transformation_2(p):<br/>       x = p[0]<br/>       y = p[1]<br/>       return x + 1, y + 1<br/><br/>   def transform(p):<br/><span class="ent">➊</span>     # List of transformation functions<br/>       transformations = [transformation_1, transformation_2]<br/>       # Pick a random transformation function and call it<br/><span class="ent">➋</span>     t = random.choice(transformations)<br/><span class="ent">➌</span>     x, y = t(p)<br/>       return x, y<br/><br/>   def build_trajectory(p, n):<br/>       x = [p[0]]<br/>       y = [p[1]]<br/>       for i in range(n):<br/>           p = transform(p)<br/>           x.append(p[0])<br/>           y.append(p[1])<br/><a id="page_161"></a><br/>           return x, y<br/><br/>   if __name__ == '__main__':<br/>       # Initial point<br/>       p = (1, 1)<br/>       n = int(input('Enter the number of iterations: '))<br/><span class="ent">➍</span>     x, y = build_trajectory(p, n)<br/>       # Plot<br/><span class="ent">➎</span>     plt.plot(x, y)<br/>       plt.xlabel('X')<br/>       plt.ylabel('Y')<br/>       plt.show()</p>
<p class="indent">We define two functions, <span class="literal">transformation_1()</span> and <span class="literal">transformation_2()</span>, corresponding to the two preceding transformations. In the <span class="literal">transform()</span> function, we create a list with these two function names at <span class="ent">➊</span> and use the <span class="literal">random.choice()</span> function to pick one of the transformations from the list at <span class="ent">➋</span>. Now that we’ve picked the transformation to apply, we call it with the point, <em>P</em>, and store the coordinates of the transformed point in the labels <span class="literal">x</span>, <span class="literal">y</span> <span class="ent">➌</span> and return them.</p>
<div class="sidebar">
<p class="sidebart"><strong>SELECTING A RANDOM ELEMENT FROM A LIST</strong></p>
<p class="noindent">The <span class="literal">random.choice()</span> function we saw in our first fractal program can be used to select a random element from a list. Each element has an <em>equal</em> chance of being returned. Here’s an example:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">import random</span><br/>&gt;&gt;&gt; <span class="codestrong">l = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">random.choice(l)</span><br/>3<br/>&gt;&gt;&gt; <span class="codestrong">random.choice(l)</span><br/>1<br/>&gt;&gt;&gt; <span class="codestrong">random.choice(l)</span><br/>1<br/>&gt;&gt;&gt; <span class="codestrong">random.choice(l)</span><br/>3<br/>&gt;&gt;&gt; <span class="codestrong">random.choice(l)</span><br/>3<br/>&gt;&gt;&gt; <span class="codestrong">random.choice(l)</span><br/>2</p>
<p class="indent">The function also works with tuples and strings. In the latter case, it returns a random character from the string.</p>
</div>
<p class="indent"><a id="page_162"></a>When you run the program, it asks you for the number of iterations, <span class="literal">n</span>—that is, the number of times the transformation would be applied. Then, it calls the <span class="literal">build_trajectory()</span> function with <span class="literal">n</span> and the initial point, <em>P</em>, which is set to (1, 1) <span class="ent">➍</span>. The <span class="literal">build_trajectory()</span> function repeatedly calls the <span class="literal">transform()</span> function <span class="literal">n</span> times, using two lists, <span class="literal">x</span> and <span class="literal">y</span>, to store the <em>x</em>-coordinate and <em>y</em>-coordinate of all the transformed points. Finally, it returns the two lists, which are then plotted <span class="ent">➎</span>.</p>
<p class="indent"><a href="ch06.html#ch6fig6">Figures 6-6</a> and <a href="ch06.html#ch6fig7">6-7</a> show the trajectory of the point for 100 and 10,000 iterations, respectively. The zigzag motion is quite apparent in both figures. This zigzag path is usually referred to as a <em>random walk on a line</em>.</p>
<div class="image"><img src="images/f06-06.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig6"></a><em>Figure 6-6: The zigzag path traced by the point (1, 1) when subjected to one or the other of the two transformations randomly for 100 iterations</em></p>
<div class="image"><a id="page_163"></a><img src="images/f06-07.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig7"></a><em>Figure 6-7: The zigzag path traced by the point (1, 1) when subjected to one or the other of the two transformations randomly for 10,000 iterations.</em></p>
<p class="indent">This example demonstrates a basic idea in creating fractals—starting from an initial point and applying a transformation to that point repeatedly. Next, we’ll see an example of applying the same ideas to draw the <em>Barnsley fern</em>.</p>
<h4 class="h4" id="ch06lev2sec05"><strong><em>Drawing the Barnsley Fern</em></strong></h4>
<p class="noindent">The British mathematician Michael Barnsley described how to create fern-like structures using repeated applications of a simple transformation on a point (see <a href="ch06.html#ch6fig8">Figure 6-8</a>).</p>
<div class="image"><a id="page_164"></a><img src="images/f06-08.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig8"></a><em>Figure 6-8: Lady ferns<a id="fn_04" href="footnote.html#fn04"><sup>2</sup></a></em></p>
<p class="indentb">He proposed the following steps to create fern-like structures: start with the point (0, 0) and <em>randomly</em> select one of the following transformations with the assigned <em>probability</em>:</p>
<p class="itemlist"><strong>Transformation 1</strong> (0.85 probability):</p>
<p class="itemlist"><em>x</em><sub><em>n</em>+1</sub> = 0.85<em>x<sub>n</sub></em> + 0.04<em>y<sub>n</sub></em></p>
<p class="itemlist"><em>y</em><sub><em>n</em>+1</sub> = –0.04<em>y<sub>n</sub></em> + 0.85<em>y<sub>n</sub></em> + 1.6</p>
<p class="itemlist"><strong>Transformation 2</strong> (0.07 probability):</p>
<p class="itemlist"><em>x</em><sub><em>n</em>+1</sub> = 0.2<em>x<sub>n</sub></em> – 0.26<em>y<sub>n</sub></em></p>
<p class="itemlist"><em>y</em><sub><em>n</em>+1</sub> = 0.23<em>y<sub>n</sub></em> + 0.22<em>y<sub>n</sub></em> + 1.6</p>
<p class="itemlist"><strong>Transformation 3</strong> (0.07 probability):</p>
<p class="itemlist"><em>x</em><sub><em>n</em>+1</sub> = –0.15<em>x<sub>n</sub></em> – 0.28<em>x<sub>n</sub></em></p>
<p class="itemlist"><em>y</em><sub><em>n</em>+1</sub> = 0.26<em>y<sub>n</sub></em> + 0.24<em>y<sub>n</sub></em> + 0.44</p>
<p class="itemlist"><a id="page_165"></a><strong>Transformation 4</strong> (0.01 probability):</p>
<p class="itemlist"><em>x</em><sub><em>n</em>+1</sub> = 0</p>
<p class="itemlist"><em>y</em><sub><em>n</em>+1</sub> = 0.16<em>y<sub>n</sub></em></p>
<p class="indentt">Each of these transformations is responsible for creating a part of the fern. The first transformation selected with the highest probability—and hence the maximum number of times—creates the stem and the bottom fronds of the fern. The second and third transformations create the bottom frond on the left and the right, respectively, and the fourth transformation creates the stem of the fern.</p>
<p class="indent">This is an example of nonuniform probabilistic selection, which we first learned about in <a href="ch05.html#ch05">Chapter 5</a>. The following program draws the Barnsley fern for the specified number of points:</p>
<p class="programs">   '''<br/>   Draw a Barnsley Fern<br/>   '''<br/>   import random<br/>   import matplotlib.pyplot as plt<br/><br/>   def transformation_1(p):<br/>       x = p[0]<br/>       y = p[1]<br/>       x1 = 0.85*x + 0.04*y<br/>       y1 = -0.04*x + 0.85*y + 1.6<br/>       return x1, y1<br/><br/>   def transformation_2(p):<br/>       x = p[0]<br/>       y = p[1]<br/>       x1 = 0.2*x - 0.26*y<br/>       y1 = 0.23*x + 0.22*y + 1.6<br/>       return x1, y1<br/><br/>   def transformation_3(p):<br/>       x = p[0]<br/>       y = p[1]<br/>       x1 = -0.15*x + 0.28*y<br/>       y1 = 0.26*x + 0.24*y + 0.44<br/>       return x1, y1<br/><br/>   def transformation_4(p):<br/>       x = p[0]<br/>       y = p[1]<br/>       x1 = 0<br/>       y1 = 0.16*y<br/>       return x1, y1<br/><br/>   def get_index(probability):<br/>       r = random.random()<br/>       c_probability = 0<br/>       sum_probability = []<br/>       for p in probability:<br/>           c_probability += p<br/>           sum_probability.append(c_probability)<br/>       for item, sp in enumerate(sum_probability):<br/>           if r &lt;= sp:<br/>               return item<br/>       return len(probability)-1<br/><br/>   def transform(p):<br/>       # List of transformation functions<br/>       transformations = [transformation_1, transformation_2,<br/>                              transformation_3, transformation_4]<br/><span class="ent">➊</span>     probability = [0.85, 0.07, 0.07, 0.01]<br/>       # Pick a random transformation function and call it<br/>       tindex = get_index(probability)<br/><span class="ent">➋</span>     t = transformations[tindex]<br/>       x, y = t(p)<br/>       return x, y<br/><br/>   def draw_fern(n):<br/>       # We start with (0, 0)<br/>       x = [0]<br/>       y = [0]<br/><br/>       x1, y1 = 0, 0<br/>       for i in range(n):<br/>          x1, y1 = transform((x1, y1))<br/>          x.append(x1)<br/>          y.append(y1)<br/>       return x, y<br/><br/>   if __name__ == '__main__':<br/>       n = int(input('Enter the number of points in the Fern: '))<br/>       x, y = draw_fern(n)<br/>       # Plot the points<br/>       plt.plot(x, y, 'o')<br/>       plt.title('Fern with {0} points'.format(n))<br/>       plt.show()</p>
<p class="indent"><a id="page_166"></a>When you run this program, it asks for the number of points in the fern to be specified and then creates the fern. <a href="ch06.html#ch6fig9">Figures 6-9</a> and <a href="ch06.html#ch6fig10">6-10</a> show ferns with 1,000 and 10,000 points, respectively.</p>
<div class="image"><a id="page_167"></a><img src="images/f06-09.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig9"></a><em>Figure 6-9: A fern with 1,000 points</em></p>
<div class="image"><img src="images/f06-10.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig10"></a><em>Figure 6-10: A fern with 10,000 points</em></p>
<p class="indent"><a id="page_168"></a>The four transformation rules are defined in the <span class="literal">transformation_1()</span>, <span class="literal">transformation_2()</span>, <span class="literal">transformation_3()</span>, and <span class="literal">transformation_4()</span> functions. The probability of each being selected is declared in a list at <span class="ent">➊</span>, and then one of them is selected <span class="ent">➋</span> to be applied every time the <span class="literal">transform()</span> function is called by the <span class="literal">draw_fern()</span> function.</p>
<p class="indent">The number of times the initial point (0, 0) is transformed is the same as the number of points in the fern specified as input to the program.</p>
<h3 class="h3" id="ch06lev1sec03"><strong>What You Learned</strong></h3>
<p class="noindent">In this chapter, you started by learning how to draw basic geometric shapes and how to animate them. This process introduced you to a number of new matplotlib features. You then learned about geometric transformations and saw how repetitive simple transformations help you draw complex geometric shapes called <em>fractals</em>.</p>
<h3 class="h3" id="ch06lev1sec04"><strong><span class="bordera">Programming Challenges</span></strong></h3>
<p class="noindent">Here are a few programming challenges that should help you further apply what you’ve learned. You can find sample solutions at <em><a href="http://www.nostarch.com/doingmathwithpython/">http://www.nostarch.com/doingmathwithpython/</a></em>.</p>
<h4 class="h4" id="ch06lev2sec06"><strong><em>#1: Packing Circles into a Square</em></strong></h4>
<p class="noindent">I mentioned earlier that matplotlib supports the creation of other geometric shapes. The <span class="literal">Polygon</span> patch is especially interesting, as it allows you to draw polygons with different numbers of sides. Here’s how we can draw a square (each side of length 4):</p>
<p class="programs">'''<br/>Draw a square<br/>'''<br/><br/>from matplotlib import pyplot as plt<br/><br/>def draw_square():<br/>    ax = plt.axes(xlim = (0, 6), ylim = (0, 6))<br/>    square = plt.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)], closed = True)<br/>    ax.add_patch(square)<br/>    plt.show()<br/><br/>if __name__ == '__main__':<br/>    draw_square()</p>
<p class="indent">The <span class="literal">Polygon</span> object is created by passing the list of the vertices’ coordinates as the first argument. Because we’re drawing a square, we pass the coordinates of the four vertices: (1, 1), (5, 1), (5, 5), and (1, 5). Passing <span class="literal">closed=True</span> tells matplotlib that we want to draw a closed polygon, where the starting and the ending vertices are the same.</p>
<p class="indent"><a id="page_169"></a>In this challenge, you’ll attempt a very simplified version of the “circles packed into a square” problem. How many circles of radius 0.5 will fit in the square produced by this code? Draw and find out! <a href="ch06.html#ch6fig11">Figure 6-11</a> shows how the final image will look.</p>
<div class="image"><img src="images/f06-11.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig11"></a><em>Figure 6-11: Circles packed into a square</em></p>
<p class="indent">The trick here is to start from the lower-left corner of the square— that is, (1, 1)—and then continue adding circles until the entire square is filled. The following snippet shows how you can create the circles and add them to the figure:</p>
<p class="programs">y = 1.5<br/>while y &lt; 5:<br/>    x = 1.5<br/>    while x &lt; 5:<br/>        c = draw_circle(x, y)<br/>        ax.add_patch(c)<br/><br/>        x += 1.0<br/>    y += 1.0</p>
<p class="indent">A point worth noting here is that this is <em>not</em> the most optimal or, for that matter, the only way to pack circles into a square, and finding different ways of solving this problem is popular among mathematics enthusiasts.</p>
<h4 class="h4" id="ch06lev2sec07"><a id="page_170"></a><strong><em>#2: Drawing the Sierpiński Triangle</em></strong></h4>
<p class="noindent">The Sierpiński triangle, named after the Polish mathematician Wacław Sierpiński, is a fractal that is an equilateral triangle composed of smaller equilateral triangles embedded inside it. <a href="ch06.html#ch6fig12">Figure 6-12</a> shows a Sierpiński triangle composed of 10,000 points.</p>
<div class="image"><img src="images/f06-12.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig12"></a><em>Figure 6-12: Sierpiński triangle with 10,000 points</em></p>
<p class="indentb">The interesting thing here is that the same process that we used to draw a fern will also draw the Sierpiński triangle—only the transformation rules and their probability will change. Here’s how you can draw the Sierpiński triangle: start with the point (0, 0) and apply one of the following transformations:</p>
<p class="itemlist"><strong>Transformation 1:</strong></p>
<p class="itemlist"><em>x</em><sub><em>n</em>+1</sub> = 0.5<em>x<sub>n</sub></em></p>
<p class="itemlist"><em>y</em><sub><em>n</em>+1</sub> = 0.5<em>y<sub>n</sub></em></p>
<p class="itemlist"><strong>Transformation 2</strong>:</p>
<p class="itemlist"><em>x</em><sub><em>n</em>+1</sub> = 0.5<em>x<sub>n</sub></em> + 0.5</p>
<p class="itemlist"><em>y</em><sub><em>n</em>+1</sub> = 0.5<em>y<sub>n</sub></em> + 0.5</p>
<p class="itemlist"><a id="page_171"></a><strong>Transformation 3</strong>:</p>
<p class="itemlist"><em>x</em><sub><em>n</em>+1</sub> = 0.5<em>x<sub>n</sub></em> + 1</p>
<p class="itemlist"><em>y</em><sub><em>n</em>+1</sub> = 0.5<em>y<sub>n</sub></em></p>
<p class="indentt">Each of the transformations has an equal probability of being selected—1/3. Your challenge here is to write a program that draws the Sierpiński triangle composed of a certain number of points specified as input.</p>
<h4 class="h4" id="ch06lev2sec08"><strong><em>#3: Exploring Hénon’s Function</em></strong></h4>
<p class="noindentb">In 1976, Michel Hénon introduced the Hénon function, which describes a transformation rule for a point <em>P</em>(<em>x</em>, <em>y</em>) as follows:</p>
<p class="center"><em>P</em> (<em>x</em>, <em>y</em>) → <em>Q</em> (<em>y</em> + 1 – 1.4<em>x</em><sup>2</sup>, 0.3<em>x</em>)</p>
<p class="indentt">Irrespective of the initial point (provided it’s not very far from the origin), you’ll see that as you create more points, they start lying along curved lines, as shown in <a href="ch06.html#ch6fig13">Figure 6-13</a>.</p>
<div class="image"><img src="images/f06-13.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig13"></a><em>Figure 6-13: Hénon function with 10,000 points</em></p>
<p class="indent">Your challenge here is to write a program to create a graph showing 20,000 iterations of this transformation, starting with the point (1, 1).</p>
<p class="indent">Extra credit for writing another program to create an animated figure showing the points starting to lie along the curves! See <em><a href="https://www.youtube.com/watch?v=76ll818RlpQ">https://www.youtube.com/watch?v=76ll818RlpQ</a></em> for an example.</p>
<p class="indent"><a id="page_172"></a>This is an example of a dynamical system, and the curved lines that all the points seem attracted to are referred to as <em>attractors</em>. To learn more about this function, dynamical systems, and fractals in general, you may want to refer to <em>Fractals: A Very Short Introduction</em> by Kenneth Falconer (Oxford University Press, 2013).</p>
<h4 class="h4" id="ch06lev2sec09"><strong><em>#4: Drawing the Mandelbrot Set</em></strong></h4>
<p class="noindent">Your challenge here is to write a program to draw the <em>Mandelbrot set</em>—another example of the application of simple rules leading to a complicated-looking shape (see <a href="ch06.html#ch6fig14">Figure 6-14</a>). Before I lay down the steps to do that, however, we’ll first learn about matplotlib’s <span class="literal">imshow()</span> function.</p>
<div class="image"><img src="images/f06-14.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig14"></a><em>Figure 6-14: Mandelbrot set in the plane between (–2.5, –1.0) and (1.0, 1.0)</em></p>
<h5 class="h5" id="ch06lev3sec01"><strong>The imshow() Function</strong></h5>
<p class="noindent">The <span class="literal">imshow()</span> function is usually used to display an external image, such as a JPEG or PNG image. You can see an example at <em><a href="http://matplotlib.org/users/image_tutorial.html">http://matplotlib.org/users/image_tutorial.html</a></em>. Here, however, we’ll use the function to draw a new image of our own creation via matplotlib.</p>
<p class="indent">Consider the part of the Cartesian plane where <em>x</em> and <em>y</em> both range from 0 to 5. Now, consider six equidistant points along each axis: (0, 1, 2, 3, 4, 5) along the <em>x</em>-axis and the same set of points along the <em>y</em>-axis. If we take the Cartesian product of these points, we get 36 equally spaced points in the <em>x</em>-<em>y</em> plane with the coordinates (0, 0), (0, 1) ... (0, 5), (1, 0), (1, 1) ... (1, 5) ... (5, 5). Let’s now say that we want to color each of these <a id="page_173"></a>points with a shade of gray—that is, some of these points will be black, some will be white, and others will be colored with a shade in between, randomly chosen. <a href="ch06.html#ch6fig15">Figure 6-15</a> illustrates the scenario.</p>
<div class="image"><img src="images/f06-15.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig15"></a><em>Figure 6-15: Part of the</em> x-y <em>plane with</em> x <em>and</em> y <em>both ranging from 0 to 5. We’ve considered 36 points in the region equidistant from each other and colored each with a shade of gray.</em></p>
<p class="indent">To create this figure, we have to make a list of six lists. Each of these six lists will in turn consist of six integers ranging from 0 to 10. Each number will correspond to the color for each point, 0 standing for black and 10 standing for white. We’ll then pass this list to the <span class="literal">imshow()</span> function along with other necessary arguments.</p>
<h5 class="h5" id="ch06lev3sec02"><strong>Creating a List of Lists</strong></h5>
<p class="noindent">A list can also contain lists as its members:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">l1 = [1, 2, 3]</span><br/>&gt;&gt;&gt; <span class="codestrong">l2 = [4, 5, 6]</span><br/>&gt;&gt;&gt; <span class="codestrong">l = [l1, l2]</span></p>
<p class="indent">Here, we created a list, <span class="literal">l</span>, consisting of two lists, <span class="literal">l1</span> and <span class="literal">l2</span>. The first element of the list, <span class="literal">l[0]</span>, is thus the same as the <span class="literal">l1</span> list and the second element of the list, <span class="literal">l[1]</span>, is the same as the <span class="literal">l2</span> list:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">l[0]</span><br/>[1, 2, 3]<br/><a id="page_174"></a><br/>&gt;&gt;&gt; <span class="codestrong">l[1]</span><br/>[4, 5, 6]</p>
<p class="indent">To refer to an individual element within one of the member lists, we have to specify two indices—<span class="literal">l[0][1]</span> refers to the second element of the first list, <span class="literal">l[1][2]</span> refers to the third element of the second list, and so on.</p>
<p class="indent">Now that we know how to work with a list of lists, we can write the program to create a figure similar to <a href="ch06.html#ch6fig15">Figure 6-15</a>:</p>
<p class="programs">   import matplotlib.pyplot as plt<br/>   import matplotlib.cm as cm<br/>   import random<br/><br/><span class="ent">➊</span> def initialize_image(x_p, y_p):<br/>       image = []<br/>       for i in range(y_p):<br/>          x_colors = []<br/>           for j in range(x_p):<br/>               x_colors.append(0)<br/>           image.append(x_colors)<br/>       return image<br/><br/>   def color_points():<br/>       x_p = 6<br/>       y_p = 6<br/>       image = initialize_image(x_p, y_p)<br/>       for i in range(y_p):<br/>           for j in range(x_p):<br/><span class="ent">➋</span>             image[i][j] = random.randint(0, 10)<br/><span class="ent">➌</span>     plt.imshow(image, origin='lower', extent=(0, 5, 0, 5),<br/>                  cmap=cm.Greys_r, interpolation='nearest')<br/>       plt.colorbar()<br/>       plt.show()<br/><br/>   if __name__ == '__main__':<br/>       color_points()</p>
<p class="indent">The <span class="literal">initialize_image()</span> function at <span class="ent">➊</span> creates a list of lists with each of the elements initialized to 0. It accepts two arguments, <span class="literal">x_p</span> and <span class="literal">y_p</span>, which correspond to the number of points along the <em>x</em>-axis and <em>y</em>-axis, respectively. This effectively means that the initialized list image will consist of <span class="literal">x_p</span> lists with each list containing <span class="literal">y_p</span> zeros.</p>
<p class="indent">In the <span class="literal">color_points()</span> function, once you have the image list back from <span class="literal">initialize_image()</span>, assign a random integer between 0 and 10 to the element <span class="literal">image[i][j]</span> at <span class="ent">➋</span>. When we assign this random integer to the element, we are assigning a color to the point in the Cartesian plane that’s <em>i</em> steps along the <em>y</em>-axis and <em>j</em> steps along the <em>x</em>-axis from the origin. It’s important to note that the <span class="literal">imshow()</span> function automatically deduces the color of a point from its position in the <span class="literal">image</span> list and doesn’t care about its specific <em>x</em>- and <em>y</em>-coordinates.</p>
<p class="indent"><a id="page_175"></a>Then, call the <span class="literal">imshow()</span> function at <span class="ent">➌</span>, passing <span class="literal">image</span> as the first argument. The keyword argument <span class="literal">origin='lower'</span> specifies that the number in <span class="literal">image[0][0]</span> corresponds to the color of the point (0, 0). The keyword argument <span class="literal">extent=(0, 5, 0, 5)</span> sets the lower-left and upper-right corners of the image to (0, 0) and (5, 5), respectively. The keyword argument <span class="literal">cmap=cm.Greys_r</span> specifies that we’re going to create a grayscale image.</p>
<p class="indent">The last keyword argument, <span class="literal">interpolation='nearest'</span>, specifies that matplotlib should color a point for which the color wasn’t specified with the same color as the one nearest to it. What does this mean? Note that we consider and specify the color for only 36 points in the region (0, 5) and (5, 5). Because there is an infinite number of points in this region, we tell matplotlib to set the color of an unspecified point to that of its nearest point. This is the reason you see color “boxes” around each point in the figure.</p>
<p class="indent">Call the <span class="literal">colorbar()</span> function to display a color bar in the figure showing which integer corresponds to which color. Finally, call <span class="literal">show()</span> to display the image. Note that due to the use of the <span class="literal">random.randint()</span> function, your image will be colored differently than the one in <a href="ch06.html#ch6fig15">Figure 6-15</a>.</p>
<p class="indent">If you increase the number of points along each axis by setting <span class="literal">x_p</span> and <span class="literal">y_p</span> to, let’s say, <span class="literal">20</span> in <span class="literal">color_points()</span>, you’ll see a figure similar to the one shown in <a href="ch06.html#ch6fig16">Figure 6-16</a>. Note that the color boxes grow smaller in size. If you increase the number of points even more, you’ll see the size of the boxes shrink further, giving the illusion that each point has a different color.</p>
<div class="image"><img src="images/f06-16.jpg" alt="image" /></div>
<p class="figuret"><a id="ch6fig16"></a><em>Figure 6-16: Part of the</em> x-y <em>plane with</em> x <em>and</em> y <em>both ranging from 0 to 5. We’ve considered 400 points in the region equidistant from each other and colored each with a shade of gray.</em></p>
<h5 class="h5" id="ch06lev3sec03"><a id="page_176"></a><strong>Drawing the Mandelbrot Set</strong></h5>
<p class="noindent">We’ll consider the area of the <em>x</em>-<em>y</em> plane between (–2.5, –1.0) and (1.0, 1.0) and divide each axis into 400 equally spaced points. The Cartesian product of these points will give us 1,600 equally spaced points in this region. We’ll refer to these points as (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), (<em>x</em><sub>1</sub>, <em>y</em><sub>2</sub>) ... (<em>x</em><sub>400</sub>, <em>y</em><sub>400</sub>).</p>
<p class="indentb">Create a list, <span class="literal">image</span>, by calling the <span class="literal">initialize_image()</span> function we saw earlier with both <span class="literal">x_p</span> and <span class="literal">y_p</span> set to 400. Then, follow these steps for <em>each</em> of the generated points (<em>x<sub>i</sub></em>, <em>y<sub>k</sub></em>):</p>
<p class="order">1. First, create two complex numbers, <em>z</em><sub>1</sub> = 0 + 0<em>j</em> and <em>c</em> = <em>x<sub>i</sub></em> + <em>y<sub>k</sub> j</em>. (Recall that we use <em>j</em> for <img src="images/e0176-01.jpg" alt="image" />.)</p>
<p class="order">2. Create a label iteration and set it to 0—that is, <span class="literal">iteration=0</span>.</p>
<p class="order">3. Create a complex number, <img src="images/e0176-02.jpg" alt="image" />.</p>
<p class="order">4. Increment the value stored in <span class="literal">iteration</span> by 1—that is, <span class="literal">iteration = iteration + 1</span>.</p>
<p class="order">5. If <span class="literal">abs(z1) &lt; 2</span> and <span class="literal">iteration &lt; max_iteration</span>, then go back to step 3; otherwise, go to step 6. The larger the value of <span class="literal">max_iteration</span>, the more detailed the image, but the longer it’ll take to create the image. Set <span class="literal">max_iteration</span> to 1,000 here.</p>
<p class="order">6. Set the color of the point (<em>x<sub>i</sub></em>, <em>y<sub>k</sub></em>) to the value in <span class="literal">iteration</span>—that is, <span class="literal">image[k][i] = iteration</span>.</p>
<p class="indentt">Once you have the complete <span class="literal">image</span> list, call the <span class="literal">imshow()</span> function with the <span class="literal">extent</span> keyword argument changed to indicate the region bounded by (–2.5, –1.0) and (1.0, 1.0).</p>
<p class="indent">This algorithm is usually referred to as the <em>escape-time algorithm</em>. When the maximum number of iterations is reached before a point’s magnitude exceeds 2, that point belongs to the Mandelbrot set and is colored white. The points that exceed the magnitude within fewer iterations are said to “escape”; they don’t belong to the Mandelbrot set and are colored black. You can experiment by decreasing and increasing the number of points along each axis. Decreasing the number of points will lead to a grainy image, while increasing them will result in a more detailed image.</p>
</div>
</body>
</html>