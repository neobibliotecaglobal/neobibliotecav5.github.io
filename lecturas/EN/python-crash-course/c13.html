<!DOCTYPE html>

<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css"/>
<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_255" title="255"></span>13</span><br/>
<span class="ChapterTitle">Aliens!</span></h1>
</header>
<figure class="opener">
<img alt="" height="406" src="Images/chapterart.png" width="406"/>
</figure>
<p class="ChapterIntro">In this chapter, we’ll add aliens to <em>Alien Invasion</em>. We’ll add one alien near the top of the screen and then generate a whole fleet of aliens. We’ll make the fleet advance sideways and down, and we’ll get rid of any aliens hit by a bullet. Finally, we’ll limit the number of ships a player has and end the game when the player runs out of ships.</p>
<p>As you work through this chapter, you’ll learn more about Pygame and about managing a large project. You’ll also learn to detect collisions between game objects, like bullets and aliens. Detecting collisions helps you define interactions between elements in your games. For example, you can confine a character inside the walls of a maze or pass a ball between two characters. We’ll continue to work from a plan that we revisit occasionally to maintain the focus of our code-writing sessions.</p>
<p>Before we start writing new code to add a fleet of aliens to the screen, let’s look at the project and update our plan.</p>
<h2 id="h1-502703c13-0001"><span epub:type="pagebreak" id="Page_256" title="256"></span>Reviewing the Project</h2>
<p class="BodyFirst">When you’re beginning a new phase of development on a large project, it’s always a good idea to revisit your plan and clarify what you want to accomplish with the code you’re about to write. In this chapter, we’ll do the following:</p>
<ul>
<li>Add a single alien to the top-left corner of the screen, with appropriate spacing around it.</li>
<li>Fill the upper portion of the screen with as many aliens as we can fit horizontally. We’ll then create additional rows of aliens until we have a full fleet.</li>
<li>Make the fleet move sideways and down until the entire fleet is shot down, an alien hits the ship, or an alien reaches the ground. If the entire fleet is shot down, we’ll create a new fleet. If an alien hits the ship or the ground, we’ll destroy the ship and create a new fleet.</li>
<li>Limit the number of ships the player can use, and end the game when the player has used up the allotted number of ships.</li>
</ul>
<p>We’ll refine this plan as we implement features, but this is specific enough to start writing code.</p>
<p>You should also review your existing code when you begin working on a new series of features in a project. Because each new phase typically makes a project more complex, it’s best to clean up any cluttered or inefficient code. We’ve been refactoring as we go, so there isn’t any code that we need to refactor at this point.</p>
<h2 id="h1-502703c13-0002">Creating the First Alien</h2>
<p class="BodyFirst">Placing one alien on the screen is like placing a ship on the screen. Each alien’s behavior is controlled by a class called <code>Alien</code>, which we’ll structure like the <code>Ship</code> class. We’ll continue using bitmap images for simplicity. You can find your own image for an alien or use the one shown in <a href="#figure13-1" id="figureanchor13-1">Figure 13-1</a>, which is available in the book’s resources at <a class="LinkURL" href="https://ehmatthes.github.io/pcc_3e">https://ehmatthes.github.io/pcc_3e</a>. This image has a gray background, which matches the screen’s background color. Make sure you save the image file you choose in the <em>images</em> folder.</p>
<figure>
<img alt="" class="keyline" height="227" src="Images/f13001.png" width="236"/>
<figcaption><p><a id="figure13-1">Figure 13-1</a>: The alien we’ll use to build the fleet</p></figcaption>
</figure>
<h3 id="h2-502703c13-0001"><span epub:type="pagebreak" id="Page_257" title="257"></span>Creating the Alien Class</h3>
<p class="BodyFirst">Now we’ll write the <code>Alien</code> class and save it as <em>alien.py</em>:</p>
<p class="CodeLabel"><b>alien.py</b></p>
<pre><code>import pygame
from pygame.sprite import Sprite

class Alien(Sprite):
    """A class to represent a single alien in the fleet."""

    def __init__(self, ai_game):
        """Initialize the alien and set its starting position."""
        super().__init__()
        self.screen = ai_game.screen

        # Load the alien image and set its rect attribute.
        self.image = pygame.image.load('images/alien.bmp')
        self.rect = self.image.get_rect()

        # Start each new alien near the top left of the screen.
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         self.rect.x = self.rect.width
        self.rect.y = self.rect.height

        # Store the alien's exact horizontal position.
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         self.x = float(self.rect.x)</code></pre>
<p>Most of this class is like the <code>Ship</code> class, except for the alien’s placement on the screen. We initially place each alien near the top-left corner of the screen; we add a space to the left of it that’s equal to the alien’s width and a space above it equal to its height <span aria-label="annotation1" class="CodeAnnotation">❶</span>, so it’s easy to see. We’re mainly concerned with the aliens’ horizontal speed, so we’ll track the horizontal position of each alien precisely <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</p>
<p>This <code>Alien</code> class doesn’t need a method for drawing it to the screen; instead, we’ll use a Pygame group method that automatically draws all the elements of a group to the screen.</p>
<h3 id="h2-502703c13-0002">Creating an Instance of the Alien</h3>
<p class="BodyFirst">We want to create an instance of <code>Alien</code> so we can see the first alien on the screen. Because it’s part of our setup work, we’ll add the code for this instance at the end of the <code>__init__()</code> method in <code>AlienInvasion</code>. Eventually, we’ll create an entire fleet of aliens, which will be quite a bit of work, so we’ll make a new helper method called <code>_create_fleet()</code>.</p>
<p>The order of methods in a class doesn’t matter, as long as there’s some consistency to how they’re placed. I’ll place <code>_create_fleet()</code> just before the <code>_update_screen()</code> method, but anywhere in <code>AlienInvasion</code> will work. First, we’ll import the <code>Alien</code> class.</p>
<p>Here are the updated <code>import</code> statements for <em>alien_invasion.py</em>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">from bullet import Bullet</span>
from alien import Alien</code></pre>
<p><span epub:type="pagebreak" id="Page_258" title="258"></span>And here’s the updated <code>__init__()</code> method:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def __init__(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">        self.ship = Ship(self)</span>
<span class="LiteralGray">        self.bullets = pygame.sprite.Group()</span>
        self.aliens = pygame.sprite.Group()

        self._create_fleet()</code></pre>
<p>We create a group to hold the fleet of aliens, and we call <code>_create_fleet()</code>, which we’re about to write.</p>
<p>Here’s the new <code>_create_fleet()</code> method:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code>    def _create_fleet(self):
        """Create the fleet of aliens."""
        # Make an alien.
        alien = Alien(self)
        self.aliens.add(alien)</code></pre>
<p>In this method, we’re creating one instance of <code>Alien</code> and then adding it to the group that will hold the fleet. The alien will be placed in the default upper-left area of the screen.</p>
<p>To make the alien appear, we need to call the group’s <code>draw()</code> method in <code>_update_screen()</code>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _update_screen(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">        self.ship.blitme()</span>
<span class="LiteralGray">        </span>self.aliens.draw(self.screen)

<span class="LiteralGray">        pygame.display.flip()</span></code></pre>
<p>When you call <code>draw()</code> on a group, Pygame draws each element in the group at the position defined by its <code>rect</code> attribute. The <code>draw()</code> method requires one argument: a surface on which to draw the elements from the group. <a href="#figure13-2" id="figureanchor13-2">Figure 13-2</a> shows the first alien on the screen.</p>
<figure>
<img alt="" class="keyline" height="297" src="Images/f13002.png" width="430"/>
<figcaption><p><a id="figure13-2">Figure 13-2</a>: The first alien appears.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_259" title="259"></span>Now that the first alien appears correctly, we’ll write the code to draw an entire fleet.</p>
<h2 id="h1-502703c13-0003">Building the Alien Fleet</h2>
<p class="BodyFirst">To draw a fleet, we need to figure out how to fill the upper portion of the screen with aliens, without overcrowding the game window. There are a number of ways to accomplish this goal. We’ll approach it by adding aliens across the top of the screen, until there’s no space left for a new alien. Then we’ll repeat this process, as long as we have enough vertical space to add a new row.</p>
<h3 id="h2-502703c13-0003">Creating a Row of Aliens</h3>
<p class="BodyFirst">Now we’re ready to generate a full row of aliens. To make a full row, we’ll first make a single alien so we have access to the alien’s width. We’ll place an alien on the left side of the screen and then keep adding aliens until we run out of space:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _create_fleet(self):</span>
<span class="LiteralGray">        """Create the fleet of aliens."""</span>
        # Create an alien and keep adding aliens until there's no room left.
        # Spacing between aliens is one alien width.
<span class="LiteralGray">        alien = Alien(self)</span>
        alien_width = alien.rect.width

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         current_x = alien_width
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         while current_x &lt; (self.settings.screen_width - 2 * alien_width):
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>             new_alien = Alien(self)
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>             new_alien.x = current_x
            new_alien.rect.x = current_x
            self.aliens.add(new_alien)
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span>             current_x += 2 * alien_width</code></pre>
<p>We get the alien’s width from the first alien we created, and then define a variable called <code>current_x</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This refers to the horizontal position of the next alien we intend to place on the screen. We initially set this to one alien width, to offset the first alien in the fleet from the left edge of the screen.</p>
<p>Next, we begin the <code>while</code> loop <span aria-label="annotation2" class="CodeAnnotation">❷</span>; we’re going to keep adding aliens <em>while</em> there’s enough room to place one. To determine whether there’s room to place another alien, we’ll compare <code>current_x</code> to some maximum value. A first attempt at defining this loop might look like this:</p>
<pre><code>while current_x &lt; self.settings.screen_width:</code></pre>
<p>This seems like it might work, but it would place the final alien in the row at the far-right edge of the screen. So we add a little margin on the right side of the screen. As long as there’s at least two alien widths’ worth of space at the right edge of the screen, we enter the loop and add another alien to the fleet.</p>
<p><span epub:type="pagebreak" id="Page_260" title="260"></span>Whenever there’s enough horizontal space to continue the loop, we want to do two things: create an alien at the correct position, and define the horizontal position of the next alien in the row. We create an alien and assign it to <code>new_alien</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Then we set the precise horizontal position to the current value of <code>current_x</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span>. We also position the alien’s <code>rect</code> at this same <em>x</em>-value, and add the new alien to the group <code>self.aliens</code>.</p>
<p>Finally, we increment the value of <code>current_x</code> <span aria-label="annotation5" class="CodeAnnotation">❺</span>. We add two alien widths to the horizontal position, to move past the alien we just added and to leave some space between the aliens as well. Python will re-evaluate the condition at the start of the <code>while</code> loop and decide if there’s room for another alien. When there’s no room left, the loop will end, and we should have a full row of aliens.</p>
<p>When you run <em>Alien Invasion</em> now, you should see the first row of aliens appear, as in <a href="#figure13-3" id="figureanchor13-3">Figure 13-3</a>.</p>
<figure>
<img alt="" class="keyline" height="345" src="Images/f13003.png" width="500"/>
<figcaption><p><a id="figure13-3">Figure 13-3</a>: The first row of aliens</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	It’s not always obvious exactly how to construct a loop like the one shown in this section. One nice thing about programming is that your initial ideas for how to approach a problem like this don’t have to be correct. It’s perfectly reasonable to start a loop like this with the aliens positioned too far to the right, and then modify the loop until you have an appropriate amount of space on the screen.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502703c13-0004">Refactoring _create_fleet()</h3>
<p class="BodyFirst">If the code we’ve written so far was all we needed to create a fleet, we’d probably leave <code>_create_fleet()</code> as is. But we have more work to do, so let’s clean up the method a bit. We’ll add a new helper method, <code>_create_alien()</code>, and call it from <code>_create_fleet()</code>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _create_fleet(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">        while current_x &lt; (self.settings.screen_width - 2 * alien_width):</span>
            self._create_alien(current_x)
            current_x += 2 * alien_width

<span epub:type="pagebreak" id="Page_261" title="261"></span><span aria-label="annotation1" class="CodeAnnotationHang">❶</span>     def _create_alien(self, x_position):
        """Create an alien and place it in the row."""
<span class="LiteralGray">        new_alien = Alien(self)</span>
        new_alien.x = x_position
        new_alien.rect.x = x_position
<span class="LiteralGray">        self.aliens.add(new_alien)</span></code></pre>
<p>The method <code>_create_alien()</code> requires one parameter in addition to <code>self</code>: the <em>x</em>-value that specifies where the alien should be placed <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The code in the body of <code>_create_alien()</code> is the same code that was in <code>_create_fleet()</code>, except we use the parameter name <code>x_position</code> in place of <code>current_x</code>. This refactoring will make it easier to add new rows and create an entire fleet.</p>
<h3 id="h2-502703c13-0005">Adding Rows</h3>
<p class="BodyFirst">To finish the fleet, we’ll keep adding more rows until we run out of room. We’ll use a nested loop—we’ll wrap another <code>while</code> loop around the current one. The inner loop will place aliens horizontally in a row by focusing on the aliens’ <em>x</em>-values. The outer loop will place aliens vertically by focusing on the <em>y</em>-values. We’ll stop adding rows when we get near the bottom of the screen, leaving enough space for the ship and some room to start firing at the aliens.</p>
<p>Here’s how to nest the two <code>while</code> loops in <code>_create_fleet()</code>:</p>
<pre><code><span class="LiteralGray">    def _create_fleet(self):</span>
<span class="LiteralGray">        """Create the fleet of aliens."""</span>
<span class="LiteralGray">        # Create an alien and keep adding aliens until there's no room left.</span>
        # Spacing between aliens is one alien width and one alien height.
<span class="LiteralGray">        alien = Alien(self)</span>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         alien_width, alien_height = alien.rect.size

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         current_x, current_y = alien_width, alien_height
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>         while current_y &lt; (self.settings.screen_height - 3 * alien_height):
            <span class="LiteralGray">while current_x &lt; (self.settings.screen_width - 2 * alien_width):</span>
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>                 self._create_alien(current_x, current_y)
                <span class="LiteralGray">current_x += 2 * alien_width</span>

<span aria-label="annotation5" class="CodeAnnotationHang">❺</span>             # Finished a row; reset x value, and increment y value.
            current_x = alien_width
            current_y += 2 * alien_height</code></pre>
<p>We’ll need to know the alien’s height in order to place rows, so we grab the alien’s width and height using the <code>size</code> attribute of an alien <code>rect</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. A <code>rect</code>’s <code>size</code> attribute is a tuple containing its width and height.</p>
<p>Next, we set the initial <em>x</em>- and <em>y</em>-values for the placement of the first alien in the fleet <span aria-label="annotation2" class="CodeAnnotation">❷</span>. We place it one alien width in from the left and one alien height down from the top. Then we define the <code>while</code> loop that controls how many rows are placed onto the screen <span aria-label="annotation3" class="CodeAnnotation">❸</span>. As long as the <em>y</em>-value for the next row is less than the screen height, minus three alien heights, we’ll keep adding rows. (If this doesn’t leave the right amount of space, we can adjust it later.)</p>
<p><span epub:type="pagebreak" id="Page_262" title="262"></span>We call <code>_create_alien()</code>, and pass it the <em>y</em>-value as well as its <em>x</em>-position <span aria-label="annotation4" class="CodeAnnotation">❹</span>. We’ll modify <code>_create_alien()</code> in a moment.</p>
<p>Notice the indentation of the last two lines of code <span aria-label="annotation5" class="CodeAnnotation">❺</span>. They’re inside the outer <code>while</code> loop, but outside the inner <code>while</code> loop. This block runs after the inner loop is finished; it runs once after each row is created. After each row has been added, we reset the value of <code>current_x</code> so the first alien in the next row will be placed at the same position as the first alien in the previous rows. Then we add two alien heights to the current value of <code>current_y</code>, so the next row will be placed further down the screen. Indentation is really important here; if you don’t see the correct fleet when you run <em>alien_invasion.py</em> at the end of this section, check the indentation of all the lines in these nested loops.</p>
<p>We need to modify <code>_create_alien()</code> to set the vertical position of the alien correctly:</p>
<pre><code>    def _create_alien(self, x_position, y_position):
        """Create an alien and place it in the fleet."""
<span class="LiteralGray">        new_alien = Alien(self)</span>
<span class="LiteralGray">        new_alien.x = x_position</span>
<span class="LiteralGray">        new_alien.rect.x = x_position</span>
        new_alien.rect.y = y_position
<span class="LiteralGray">        self.aliens.add(new_alien)</span></code></pre>
<p>We modify the definition of the method to accept the <em>y</em>-value for the new alien, and we set the vertical position of the <code>rect</code> in the body of the method.</p>
<p>When you run the game now, you should see a full fleet of aliens, as shown in <a href="#figure13-4" id="figureanchor13-4">Figure 13-4</a>.</p>
<figure>
<img alt="" class="keyline" height="380" src="Images/f13004.png" width="550"/>
<figcaption><p><a id="figure13-4">Figure 13-4</a>: The full fleet appears.</p></figcaption>
</figure>
<p>In the next section, we’ll make the fleet move!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" id="Page_263" title="263"></span>Try It Yourself</h2>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c13-06">13-1.	Stars:</span> Find an image of a star. Make a grid of stars appear on the screen.</p>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c13-07">13-2.	Better Stars:</span> You can make a more realistic star pattern by introducing randomness when you place each star. Recall from <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> that you can get a random number like this:</p>
<pre><code>from random import randint
random_number = randint(-10, 10)</code></pre>
<p class="BoxBody">This code returns a random integer between −10 and 10. Using your code in Exercise 13-1, adjust each star’s position by a random amount.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502703c13-0004">Making the Fleet Move</h2>
<p class="BodyFirst">Now let’s make the fleet of aliens move to the right across the screen until it hits the edge, and then make it drop a set amount and move in the other direction. We’ll continue this movement until all aliens have been shot down, one collides with the ship, or one reaches the bottom of the screen. Let’s begin by making the fleet move to the right.</p>
<h3 id="h2-502703c13-0006">Moving the Aliens Right</h3>
<p class="BodyFirst">To move the aliens, we’ll use an <code>update()</code> method in <em>alien.py</em>, which we’ll call for each alien in the group of aliens. First, add a setting to control the speed of each alien:</p>
<p class="CodeLabel"><b>settings.py</b></p>
<pre><code><span class="LiteralGray">    def __init__(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
        # Alien settings
        self.alien_speed = 1.0</code></pre>
<p>Then use this setting to implement <code>update()</code> in <em>alien.py</em>:</p>
<p class="CodeLabel"><b>alien.py</b></p>
<pre><code><span class="LiteralGray">    def __init__(self, ai_game):</span>
<span class="LiteralGray">        """Initialize the alien and set its starting position."""</span>
<span class="LiteralGray">        super().__init__()</span>
<span class="LiteralGray">        self.screen = ai_game.screen</span>
        self.settings = ai_game.settings
        <em class="LiteralGrayItalic">--snip--</em>

<code>    </code>def update(self):
   <code>    </code> """Move the alien to the right."""
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>    <code>    </code> self.x += self.settings.alien_speed
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>    <code>    </code> self.rect.x = self.x</code></pre>
<p>We create a <code>settings</code> parameter in <code>__init__()</code> so we can access the alien’s speed in <code>update()</code>. Each time we update an alien’s position, we move it to the <span epub:type="pagebreak" id="Page_264" title="264"></span>right by the amount stored in <code>alien_speed</code>. We track the alien’s exact position with the <code>self.x</code> attribute, which can hold float values <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We then use the value of <code>self.x</code> to update the position of the alien’s <code>rect</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</p>
<p>In the main <code>while</code> loop, we already have calls to update the ship and bullet positions. Now we’ll add a call to update the position of each alien as well:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">        while True:</span>
<span class="LiteralGray">            self._check_events()</span>
<span class="LiteralGray">            self.ship.update()</span>
<span class="LiteralGray">            self._update_bullets()</span>
            self._update_aliens()
<span class="LiteralGray">            self._update_screen()</span>
<span class="LiteralGray">            self.clock.tick(60)</span></code></pre>
<p>We’re about to write some code to manage the movement of the fleet, so we create a new method called <code>_update_aliens()</code>. We update the aliens’ positions after the bullets have been updated, because we’ll soon be checking to see whether any bullets hit any aliens.</p>
<p>Where you place this method in the module is not critical. But to keep the code organized, I’ll place it just after <code>_update_bullets()</code> to match the order of method calls in the <code>while</code> loop. Here’s the first version of <code>_update_aliens()</code>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code>    def _update_aliens(self):
        """Update the positions of all aliens in the fleet."""
        self.aliens.update()</code></pre>
<p>We use the <code>update()</code> method on the <code>aliens</code> group, which calls each alien’s <code>update()</code> method. When you run <em>Alien Invasion</em> now, you should see the fleet move right and disappear off the side of the screen.</p>
<h3 id="h2-502703c13-0007">Creating Settings for Fleet Direction</h3>
<p class="BodyFirst">Now we’ll create the settings that will make the fleet move down the screen and to the left when it hits the right edge of the screen. Here’s how to implement this behavior:</p>
<p class="CodeLabel"><b>settings.py</b></p>
<pre><code><code>        </code><span class="LiteralGray"># Alien settings</span>
<code>        </code><span class="LiteralGray">self.alien_speed = 1.0</span>
<code>        </code>self.fleet_drop_speed = 10
<code>        </code># fleet_direction of 1 represents right; -1 represents left.
<code>        </code>self.fleet_direction = 1</code></pre>
<p>The setting <code>fleet_drop_speed</code> controls how quickly the fleet drops down the screen each time an alien reaches either edge. It’s helpful to separate this speed from the aliens’ horizontal speed so you can adjust the two speeds independently.</p>
<p>To implement the setting <code>fleet_direction</code>, we could use a text value such as <code>'left'</code> or <code>'right'</code>, but we’d end up with <code>if</code>-<code>elif</code> statements testing for the fleet direction. Instead, because we only have two directions to deal with, let’s use the values 1 and −1 and switch between them each time the fleet <span epub:type="pagebreak" id="Page_265" title="265"></span>changes direction. (Using numbers also makes sense because moving right involves adding to each alien’s <em>x</em>-coordinate value, and moving left involves subtracting from each alien’s <em>x</em>-coordinate value.)</p>
<h3 id="h2-502703c13-0008">Checking Whether an Alien Has Hit the Edge</h3>
<p class="BodyFirst">We need a method to check whether an alien is at either edge, and we need to modify <code>update()</code> to allow each alien to move in the appropriate direction. This code is part of the <code>Alien</code> class:</p>
<p class="CodeLabel"><b>alien.py</b></p>
<pre><code><code>    </code>def check_edges(self):
    <code>    </code>"""Return True if alien is at edge of screen."""
    <code>    </code>screen_rect = self.screen.get_rect()
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>     <code>    </code>return (self.rect.right &gt;= screen_rect.right) or (self.rect.left &lt;= 0)

<code>    </code><span class="LiteralGray">def update(self):</span>
    <code>    </code>"""Move the alien right or left."""
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>     <code>    </code>self.x += self.settings.alien_speed * self.settings.fleet_direction
<code>    </code><span class="LiteralGray">    self.rect.x = self.x</span></code></pre>
<p>We can call the new method <code>check_edges()</code> on any alien to see whether it’s at the left or right edge. The alien is at the right edge if the <code>right</code> attribute of its <code>rect</code> is greater than or equal to the <code>right</code> attribute of the screen’s <code>rect</code>. It’s at the left edge if its <code>left</code> value is less than or equal to 0 <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Rather than put this conditional test in an <code>if</code> block, we put the test directly in the <code>return</code> statement. This method will return <code>True</code> if the alien is at the right or left edge, and <code>False</code> if it is not at either edge.</p>
<p>We modify the method <code>update()</code> to allow motion to the left or right by multiplying the alien’s speed by the value of <code>fleet_direction</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If <code>fleet_direction</code> is 1, the value of <code>alien_speed</code> will be added to the alien’s current position, moving the alien to the right; if <code>fleet_direction</code> is −1, the value will be subtracted from the alien’s position, moving the alien to the left.</p>
<h3 id="h2-502703c13-0009">Dropping the Fleet and Changing Direction</h3>
<p class="BodyFirst">When an alien reaches the edge, the entire fleet needs to drop down and change direction. Therefore, we need to add some code to <code>AlienInvasion</code> because that’s where we’ll check whether any aliens are at the left or right edge. We’ll make this happen by writing the methods <code>_check_fleet_edges()</code> and <code>_change_fleet_direction()</code>, and then modifying <code>_update_aliens()</code>. I’ll put these new methods after <code>_create_alien()</code>, but again, the placement of these methods in the class isn’t critical.</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code>    def _check_fleet_edges(self):
        """Respond appropriately if any aliens have reached an edge."""
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         for alien in self.aliens.sprites():
            if alien.check_edges():
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>                 self._change_fleet_direction()
                break

    def _change_fleet_direction(self):
<span epub:type="pagebreak" id="Page_266" title="266"></span>        """Drop the entire fleet and change the fleet's direction."""
        for alien in self.aliens.sprites():
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>             alien.rect.y += self.settings.fleet_drop_speed
        self.settings.fleet_direction *= -1</code></pre>
<p>In <code>_check_fleet_edges()</code>, we loop through the fleet and call <code>check_edges()</code> on each alien <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If <code>check_edges()</code> returns <code>True</code>, we know an alien is at an edge and the whole fleet needs to change direction; so we call <code>_change_fleet_direction()</code> and break out of the loop <span aria-label="annotation2" class="CodeAnnotation">❷</span>. In <code>_change_fleet_direction()</code>, we loop through all the aliens and drop each one using the setting <code>fleet_drop_speed</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>; then we change the value of <code>fleet_direction</code> by multiplying its current value by −1. The line that changes the fleet’s direction isn’t part of the <code>for</code> loop. We want to change each alien’s vertical position, but we only want to change the direction of the fleet once.</p>
<p>Here are the changes to <code>_update_aliens()</code>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _update_aliens(self):</span>
        """Check if the fleet is at an edge, then update positions."""
        self._check_fleet_edges()
   <span class="LiteralGray">     self.aliens.update()</span></code></pre>
<p>We’ve modified the method by calling <code>_check_fleet_edges()</code> before updating each alien’s position.</p>
<p>When you run the game now, the fleet should move back and forth between the edges of the screen and drop down every time it hits an edge. Now we can start shooting down aliens and watch for any aliens that hit the ship or reach the bottom of the screen.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try It Yourself</h2>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c13-12">13-3.	Raindrops:</span> Find an image of a raindrop and create a grid of raindrops. Make the raindrops fall toward the bottom of the screen until they disappear.</p>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c13-13">13-4.	Steady Rain:</span> Modify your code in Exercise 13-3 so when a row of raindrops disappears off the bottom of the screen, a new row appears at the top of the screen and begins to fall.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502703c13-0005">Shooting Aliens</h2>
<p class="BodyFirst">We’ve built our ship and a fleet of aliens, but when the bullets reach the aliens, they simply pass through because we aren’t checking for collisions. In game programming, <em>collisions</em> happen when game elements overlap. To make the bullets shoot down aliens, we’ll use the function <code>sprite.groupcollide()</code> to look for collisions between members of two groups.</p>
<h3 id="h2-502703c13-0010"><span epub:type="pagebreak" id="Page_267" title="267"></span>Detecting Bullet Collisions</h3>
<p class="BodyFirst">We want to know right away when a bullet hits an alien so we can make an alien disappear as soon as it’s hit. To do this, we’ll look for collisions immediately after updating the position of all the bullets.</p>
<p>The <code>sprite.groupcollide()</code> function compares the <code>rect</code>s of each element in one group with the <code>rect</code>s of each element in another group. In this case, it compares each bullet’s <code>rect</code> with each alien’s <code>rect</code> and returns a dictionary containing the bullets and aliens that have collided. Each key in the dictionary will be a bullet, and the corresponding value will be the alien that was hit. (We’ll also use this dictionary when we implement a scoring system in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>.)</p>
<p>Add the following code to the end of <code>_update_bullets()</code> to check for collisions between bullets and aliens:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _update_bullets(self):</span>
<span class="LiteralGray">        """Update position of bullets and get rid of old bullets."""</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>

        # Check for any bullets that have hit aliens.
        #   If so, get rid of the bullet and the alien.
        collisions = pygame.sprite.groupcollide(
                self.bullets, self.aliens, True, True)</code></pre>
<p>The new code we added compares the positions of all the bullets in <code>self.bullets</code> and all the aliens in <code>self.aliens</code>, and identifies any that overlap. Whenever the <code>rect</code>s of a bullet and alien overlap, <code>groupcollide()</code> adds a key-value pair to the dictionary it returns. The two <code>True</code> arguments tell Pygame to delete the bullets and aliens that have collided. (To make a high-powered bullet that can travel to the top of the screen, destroying every alien in its path, you could set the first Boolean argument to <code>False</code> and keep the second Boolean argument set to <code>True</code>. The aliens hit would disappear, but all bullets would stay active until they disappeared off the top of the screen.)</p>
<p>When you run <em>Alien Invasion</em> now, aliens you hit should disappear. <a href="#figure13-5" id="figureanchor13-5">Figure 13-5</a> shows a fleet that has been partially shot down.</p>
<figure>
<img alt="" class="keyline" height="345" src="Images/f13005.png" width="500"/>
<figcaption><p><a id="figure13-5">Figure 13-5</a>: We can shoot aliens!</p></figcaption>
</figure>
<h3 id="h2-502703c13-0011"><span epub:type="pagebreak" id="Page_268" title="268"></span>Making Larger Bullets for Testing</h3>
<p class="BodyFirst">You can test many features of <em>Alien Invasion</em> simply by running the game, but some features are tedious to test in the normal version of the game. For example, it’s a lot of work to shoot down every alien on the screen multiple times to test whether your code responds to an empty fleet correctly.</p>
<p>To test particular features, you can change certain game settings to focus on a particular area. For example, you might shrink the screen so there are fewer aliens to shoot down or increase the bullet speed and give yourself lots of bullets at once.</p>
<p>My favorite change for testing <em>Alien Invasion</em> is to use really wide bullets that remain active even after they’ve hit an alien (see <a href="#figure13-6" id="figureanchor13-6">Figure 13-6</a>). Try setting <code>bullet_width</code> to 300, or even 3,000, to see how quickly you can shoot down the fleet!</p>
<figure>
<img alt="" class="keyline" height="380" src="Images/f13006.png" width="550"/>
<figcaption><p><a id="figure13-6">Figure 13-6</a>: Extra-powerful bullets make some aspects of the game easier to test.</p></figcaption>
</figure>
<p>Changes like these will help you test the game more efficiently and possibly spark ideas for giving players bonus powers. Just remember to restore the settings to normal when you’re finished testing a feature.</p>
<h3 id="h2-502703c13-0012">Repopulating the Fleet</h3>
<p class="BodyFirst">One key feature of <em>Alien Invasion</em> is that the aliens are relentless: every time the fleet is destroyed, a new fleet should appear.</p>
<p>To make a new fleet of aliens appear after a fleet has been destroyed, we first check whether the <code>aliens</code> group is empty. If it is, we make a call to <code>_create_fleet()</code>. We’ll perform this check at the end of <code>_update_bullets()</code>, because that’s where individual aliens are destroyed.</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _update_bullets(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         if not self.aliens:
<span epub:type="pagebreak" id="Page_269" title="269"></span>            # Destroy existing bullets and create new fleet.
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>             self.bullets.empty()
            self._create_fleet()</code></pre>
<p>We check whether the <code>aliens</code> group is empty <span aria-label="annotation1" class="CodeAnnotation">❶</span>. An empty group evaluates to <code>False</code>, so this is a simple way to check whether the group is empty. If it is, we get rid of any existing bullets by using the <code>empty()</code> method, which removes all the remaining sprites from a group <span aria-label="annotation2" class="CodeAnnotation">❷</span>. We also call <code>_create_fleet()</code>, which fills the screen with aliens again.</p>
<p>Now a new fleet appears as soon as you destroy the current fleet.</p>
<h3 id="h2-502703c13-0013">Speeding Up the Bullets</h3>
<p class="BodyFirst">If you’ve tried firing at the aliens in the game’s current state, you might find that the bullets aren’t traveling at the best speed for gameplay. They might be a little too slow or a little too fast. At this point, you can modify the settings to make the gameplay more interesting. Keep in mind that the game is going to get progressively faster, so don’t make the game too fast at the beginning.</p>
<p>We modify the speed of the bullets by adjusting the value of <code>bullet_speed</code> in <em>settings.py</em>. On my system, I’ll adjust the value of <code>bullet_speed</code> to 2.5, so the bullets travel a little faster:</p>
<p class="CodeLabel"><b>settings.py</b></p>
<pre><code><span class="LiteralGray">        # Bullet settings</span>
        self.bullet_speed = 2.5
    <span class="LiteralGray">    self.bullet_width = 3</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>The best value for this setting depends on your experience of the game, so find a value that works for you. You can adjust other settings as well.</p>
<h3 id="h2-502703c13-0014">Refactoring _update_bullets()</h3>
<p class="BodyFirst">Let’s refactor <code>_update_bullets()</code> so it’s not doing so many different tasks. We’ll move the code for dealing with bullet-alien collisions to a separate method:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">   def _update_bullets(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">        # Get rid of bullets that have disappeared.</span>
<span class="LiteralGray">        for bullet in self.bullets.copy():</span>
<span class="LiteralGray">            if bullet.rect.bottom &lt;= 0:</span>
<span class="LiteralGray">                 self.bullets.remove(bullet)</span>

<span class="LiteralGray">        </span>self._check_bullet_alien_collisions()

<span class="LiteralGray">    </span>def _check_bullet_alien_collisions(self):
        """Respond to bullet-alien collisions."""
        # Remove any bullets and aliens that have collided.
<span class="LiteralGray">        collisions = pygame.sprite.groupcollide(</span>
<span class="LiteralGray">                self.bullets, self.aliens, True, True)</span>

<span epub:type="pagebreak" id="Page_270" title="270"></span><span class="LiteralGray">        if not self.aliens:</span>
<span class="LiteralGray">            # Destroy existing bullets and create new fleet.</span>
<span class="LiteralGray">            self.bullets.empty()</span>
<span class="LiteralGray">            self._create_fleet()</span></code></pre>
<p>We’ve created a new method, <code>_check_bullet_alien_collisions()</code>, to look for collisions between bullets and aliens and to respond appropriately if the entire fleet has been destroyed. Doing so keeps <code>_update_bullets()</code> from growing too long and simplifies further development.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try It Yourself</h2>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c13-19">13-5.	Sideways Shooter Part 2:</span> We’ve come a long way since Exercise 12-6, <em>Sideways Shooter</em>. For this exercise, try to develop <em>Sideways Shooter</em> to the same point we’ve brought <em>Alien Invasion</em> to. Add a fleet of aliens, and make them move sideways toward the ship. Or, write code that places aliens at random positions along the right side of the screen and then sends them toward the ship. Also, write code that makes the aliens disappear when they’re hit.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502703c13-0006">Ending the Game</h2>
<p class="BodyFirst">What’s the fun and challenge in playing a game you can’t lose? If the player doesn’t shoot down the fleet quickly enough, we’ll have the aliens destroy the ship when they make contact. At the same time, we’ll limit the number of ships a player can use, and we’ll destroy the ship when an alien reaches the bottom of the screen. The game will end when the player has used up all their ships.</p>
<h3 id="h2-502703c13-0015">Detecting Alien-Ship Collisions</h3>
<p class="BodyFirst">We’ll start by checking for collisions between aliens and the ship so we can respond appropriately when an alien hits it. We’ll check for alien-ship collisions immediately after updating the position of each alien in <code>AlienInvasion</code>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _update_aliens(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">        self.aliens.update()</span>

        # Look for alien-ship collisions.
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         if pygame.sprite.spritecollideany(self.ship, self.aliens):
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>             print("Ship hit!!!")</code></pre>
<p>The <code>spritecollideany()</code> function takes two arguments: a sprite and a group. The function looks for any member of the group that has collided with the sprite and stops looping through the group as soon as it finds one member that has collided with the sprite. Here, it loops through the group <code>aliens</code> and returns the first alien it finds that has collided with <code>ship</code>.</p>
<p><span epub:type="pagebreak" id="Page_271" title="271"></span>If no collisions occur, <code>spritecollideany()</code> returns <code>None</code> and the <code>if</code> block won’t execute <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If it finds an alien that has collided with the ship, it returns that alien and the <code>if</code> block executes: it prints <code>Ship hit!!!</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. When an alien hits the ship, we’ll need to do a number of tasks: delete all remaining aliens and bullets, recenter the ship, and create a new fleet. Before we write code to do all this, we want to know that our approach to detecting alien-ship collisions works correctly. Writing a <code>print()</code> call is a simple way to ensure we’re detecting these collisions properly.</p>
<p>Now when you run <em>Alien Invasion,</em> the message <em>Ship hit!!!</em> should appear in the terminal whenever an alien runs into the ship. When you’re testing this feature, set <code>fleet_drop_speed</code> to a higher value, such as 50 or 100, so the aliens reach your ship faster.</p>
<h3 id="h2-502703c13-0016">Responding to Alien-Ship Collisions</h3>
<p class="BodyFirst">Now we need to figure out exactly what will happen when an alien collides with the ship. Instead of destroying the <code>ship</code> instance and creating a new one, we’ll count how many times the ship has been hit by tracking statistics for the game. Tracking statistics will also be useful for scoring.</p>
<p>Let’s write a new class, <code>GameStats</code>, to track game statistics, and let’s save it as <em>game_stats.py</em>:</p>
<p class="CodeLabel"><b>game_stats.py</b></p>
<pre><code>class GameStats:
    """Track statistics for Alien Invasion."""

    def __init__(self, ai_game):
        """Initialize statistics."""
        self.settings = ai_game.settings
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         self.reset_stats()

    def reset_stats(self):
        """Initialize statistics that can change during the game."""
        self.ships_left = self.settings.ship_limit</code></pre>
<p>We’ll make one <code>GameStats</code> instance for the entire time <em>Alien Invasion</em> is running, but we’ll need to reset some statistics each time the player starts a new game. To do this, we’ll initialize most of the statistics in the <code>reset_stats()</code> method, instead of directly in <code>__init__()</code>. We’ll call this method from <code>__init__()</code> so the statistics are set properly when the <code>GameStats</code> instance is first created <span aria-label="annotation1" class="CodeAnnotation">❶</span>. But we’ll also be able to call <code>reset_stats()</code> anytime the player starts a new game. Right now we have only one statistic, <code>ships_left</code>, the value of which will change throughout the game.</p>
<p>The number of ships the player starts with should be stored in <em>settings.py</em> as <code>ship_limit</code>:</p>
<p class="CodeLabel"><b>settings.py</b></p>
<pre><code><code>        </code><span class="LiteralGray"># Ship settings</span>
        <span class="LiteralGray">self.ship_speed = 1.5</span>
        self.ship_limit = 3</code></pre>
<p><span epub:type="pagebreak" id="Page_272" title="272"></span>We also need to make a few changes in <em>alien_invasion.py</em> to create an instance of <code>GameStats</code>. First, we’ll update the <code>import</code> statements at the top of the file:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">import sys</span>
from time import sleep

<span class="LiteralGray">import pygame</span>

<span class="LiteralGray">from settings import Settings</span>
from game_stats import GameStats
<span class="LiteralGray">from ship import Ship</span>
<em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>We import the <code>sleep()</code> function from the <code>time</code> module in the Python standard library, so we can pause the game for a moment when the ship is hit. We also import <code>GameStats</code>.</p>
<p>We’ll create an instance of <code>GameStats</code> in <code>__init__()</code>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def __init__(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">        self.screen = pygame.display.set_mode(</span>
<span class="LiteralGray">            (self.settings.screen_width, self.settings.screen_height))</span>
<span class="LiteralGray">        pygame.display.set_caption("Alien Invasion")</span>

        # Create an instance to store game statistics.
        self.stats = GameStats(self)

<span class="LiteralGray">        self.ship = Ship(self)</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>We make the instance after creating the game window but before defining other game elements, such as the ship.</p>
<p>When an alien hits the ship, we’ll subtract 1 from the number of ships left, destroy all existing aliens and bullets, create a new fleet, and reposition the ship in the middle of the screen. We’ll also pause the game for a moment so the player can notice the collision and regroup before a new fleet appears.</p>
<p>Let’s put most of this code in a new method called <code>_ship_hit()</code>. We’ll call this method from <code>_update_aliens()</code> when an alien hits the ship:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code>    def _ship_hit(self):
        """Respond to the ship being hit by an alien."""
        # Decrement ships_left.
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         self.stats.ships_left -= 1

        # Get rid of any remaining bullets and aliens.
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         self.bullets.empty()
        self.aliens.empty()

        # Create a new fleet and center the ship.
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>         self._create_fleet()
        self.ship.center_ship()

<span epub:type="pagebreak" id="Page_273" title="273"></span>        # Pause.
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>         sleep(0.5)</code></pre>
<p>The new method <code>_ship_hit()</code> coordinates the response when an alien hits a ship. Inside <code>_ship_hit()</code>, the number of ships left is reduced by 1 <span aria-label="annotation1" class="CodeAnnotation">❶</span>, after which we empty the groups <code>bullets</code> and <code>aliens</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</p>
<p>Next, we create a new fleet and center the ship <span aria-label="annotation3" class="CodeAnnotation">❸</span>. (We’ll add the method <code>center_ship()</code> to <code>Ship</code> in a moment.) Then we add a pause after the updates have been made to all the game elements but before any changes have been drawn to the screen, so the player can see that their ship has been hit <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The <code>sleep()</code> call pauses program execution for half a second, long enough for the player to see that the alien has hit the ship. When the <code>sleep()</code> function ends, code execution moves on to the <code>_update_screen()</code> method, which draws the new fleet to the screen.</p>
<p>In <code>_update_aliens()</code>, we replace the <code>print()</code> call with a call to <code>_ship_hit()</code> when an alien hits the ship:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code>    <span class="LiteralGray">def _update_aliens(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">        if pygame.sprite.spritecollideany(self.ship, self.aliens):</span>
            self._ship_hit()</code></pre>
<p>Here’s the new method <code>center_ship()</code>, which belongs in <em>ship.py</em>:</p>
<p class="CodeLabel"><b>ship.py</b></p>
<pre><code><code>    </code>def center_ship(self):
        """Center the ship on the screen."""
        self.rect.midbottom = self.screen_rect.midbottom
        self.x = float(self.rect.x)</code></pre>
<p>We center the ship the same way we did in <code>__init__()</code>. After centering it, we reset the <code>self.x</code> attribute, which allows us to track the ship’s exact position.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Notice that we never make more than one ship; we make only one ship instance for the whole game and recenter it whenever the ship has been hit. The statistic <code>ships_left</code> will tell us when the player has run out of ships.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Run the game, shoot a few aliens, and let an alien hit the ship. The game should pause, and a new fleet should appear with the ship centered at the bottom of the screen again.</p>
<h3 id="h2-502703c13-0017">Aliens That Reach the Bottom of the Screen</h3>
<p class="BodyFirst">If an alien reaches the bottom of the screen, we’ll have the game respond the same way it does when an alien hits the ship. To check when this happens, add a new method in <em>alien_invasion.py</em>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code>    def _check_aliens_bottom(self):
        """Check if any aliens have reached the bottom of the screen."""
        for alien in self.aliens.sprites():
<span epub:type="pagebreak" id="Page_274" title="274"></span><span aria-label="annotation1" class="CodeAnnotationHang">❶</span>             if alien.rect.bottom &gt;= self.settings.screen_height:
                # Treat this the same as if the ship got hit.
                self._ship_hit()
                break</code></pre>
<p>The method <code>_check_aliens_bottom()</code> checks whether any aliens have reached the bottom of the screen. An alien reaches the bottom when its <code>rect.bottom</code> value is greater than or equal to the screen’s height <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If an alien reaches the bottom, we call <code>_ship_hit()</code>. If one alien hits the bottom, there’s no need to check the rest, so we break out of the loop after calling <code>_ship_hit()</code>.</p>
<p>We’ll call this method from <code>_update_aliens()</code>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _update_aliens(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">        # Look for alien-ship collisions.</span>
<span class="LiteralGray">        if pygame.sprite.spritecollideany(self.ship, self.aliens):</span>
<span class="LiteralGray">            self._ship_hit()</span>

        # Look for aliens hitting the bottom of the screen.
        self._check_aliens_bottom()</code></pre>
<p>We call <code>_check_aliens_bottom()</code> after updating the positions of all the aliens and after looking for alien-ship collisions. Now a new fleet will appear every time the ship is hit by an alien or an alien reaches the bottom of the screen.</p>
<h3 id="h2-502703c13-0018">Game Over!</h3>
<p class="BodyFirst"><em>Alien Invasion</em> feels more complete now, but the game never ends. The value of <code>ships_left</code> just grows increasingly negative. Let’s add a <code>game_active</code> flag, so we can end the game when the player runs out of ships. We’ll set this flag at the end of the <code>__init__()</code> method in <code>AlienInvasion</code>:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def __init__(self):</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em>
   <span class="LiteralGray">    </span> # Start Alien Invasion in an active state.
   <span class="LiteralGray">    </span> self.game_active = True</code></pre>
<p>Now we add code to <code>_ship_hit()</code> that sets <code>game_active</code> to <code>False</code> when the player has used up all their ships:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def _ship_hit(self):</span>
<span class="LiteralGray">        """Respond to ship being hit by alien."""</span>
        if self.stats.ships_left &gt; 0:
           <span class="LiteralGray"> # Decrement ships_left.</span>
<span class="LiteralGray">            self.stats.ships_left -= 1</span>
<span class="LiteralGray">            </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">            # Pause.</span>
<span class="LiteralGray">            sleep(0.5)</span>
        else:
           <span class="LiteralGray"> </span>self.game_active = False</code></pre>
<p><span epub:type="pagebreak" id="Page_275" title="275"></span>Most of <code>_ship_hit()</code> is unchanged. We’ve moved all the existing code into an <code>if</code> block, which tests to make sure the player has at least one ship remaining. If so, we create a new fleet, pause, and move on. If the player has no ships left, we set <code>game_active</code> to <code>False</code>.</p>
<h3 id="h2-502703c13-0019">Identifying When Parts of the Game Should Run</h3>
<p class="BodyFirst">We need to identify the parts of the game that should always run and the parts that should run only when the game is active:</p>
<p class="CodeLabel"><b>alien_invasion.py</b></p>
<pre><code><span class="LiteralGray">    def run_game(self):</span>
<span class="LiteralGray">        """Start the main loop for the game."""</span>
<span class="LiteralGray">        while True:</span>
<span class="LiteralGray">            self._check_events()</span>

<span class="LiteralGray">      </span>      if self.game_active:
<span class="LiteralGray">                self.ship.update()</span>
<span class="LiteralGray">                self._update_bullets()</span>
<span class="LiteralGray">                self._update_aliens()</span>

<span class="LiteralGray">            self._update_screen()</span>
<span class="LiteralGray">            self.clock.tick(60)</span></code></pre>
<p>In the main loop, we always need to call <code>_check_events()</code>, even if the game is inactive. For example, we still need to know if the user presses Q to quit the game or clicks the button to close the window. We also continue updating the screen so we can make changes to the screen while waiting to see whether the player chooses to start a new game. The rest of the function calls need to happen only when the game is active, because when the game is inactive, we don’t need to update the positions of game elements.</p>
<p>Now when you play <em>Alien Invasion</em>, the game should freeze when you’ve used up all your ships.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try It Yourself</h2>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c13-25">13-6.	Game Over:</span> In <em>Sideways Shooter</em>, keep track of the number of times the ship is hit and the number of times an alien is hit by the ship. Decide on an appropriate condition for ending the game, and stop the game when this situation occurs.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502703c13-0007">Summary</h2>
<p class="BodyFirst">In this chapter, you learned how to add a large number of identical elements to a game by creating a fleet of aliens. You used nested loops to create a grid of elements, and you made a large set of game elements move by calling each element’s <code>update()</code> method. You learned to control the direction of <span epub:type="pagebreak" id="Page_276" title="276"></span>objects on the screen and to respond to specific situations, such as when the fleet reaches the edge of the screen. You detected and responded to collisions when bullets hit aliens and aliens hit the ship. You also learned how to track statistics in a game and use a <code>game_active</code> flag to determine when the game is over.</p>
<p>In the next and final chapter of this project, we’ll add a Play button so the player can choose when to start their first game and whether to play again when the game ends. We’ll speed up the game each time the player shoots down the entire fleet, and we’ll add a scoring system. The final result will be a fully playable game!</p>
</section>
</div></body>
</html>