<!DOCTYPE html>

<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css"/>
<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_403" title="403"></span>19</span><br/>
<span class="ChapterTitle">User Accounts</span></h1>
</header>
<figure class="opener">
<img alt="" height="406" src="Images/chapterart.png" width="406"/>
</figure>
<p class="ChapterIntro">At the heart of a web application is the ability for any user, anywhere in the world, to register an account with your app and start using it. In this chapter, you’ll build forms so users can add their own topics and entries, and edit existing entries. You’ll also learn how Django guards against common attacks against form-based pages, so you won’t have to spend much time thinking about securing your apps.</p>
<p>You’ll also implement a user authentication system. You’ll build a registration page for users to create accounts, and then restrict access to certain pages to logged-in users only. Then you’ll modify some of the view functions so users can only see their own data. You’ll learn to keep your users’ data safe and secure.</p>
<h2 id="h1-502703c19-0001"><span epub:type="pagebreak" id="Page_404" title="404"></span>Allowing Users to Enter Data</h2>
<p class="BodyFirst">Before we build an authentication system for creating accounts, we’ll first add some pages that allow users to enter their own data. We’ll give users the ability to add a new topic, add a new entry, and edit their previous entries.</p>
<p>Currently, only a superuser can enter data through the admin site. We don’t want users to interact with the admin site, so we’ll use Django’s form-building tools to build pages that allow users to enter data.</p>
<h3 id="h2-502703c19-0001">Adding New Topics</h3>
<p class="BodyFirst">Let’s start by allowing users to add a new topic. Adding a form-based page works in much the same way as adding the pages we’ve already built: we define a URL, write a view function, and write a template. The one significant difference is the addition of a new module called <em>forms.py</em>, which will contain the forms.</p>
<h4 id="h3-502703c19-0001">The Topic ModelForm</h4>
<p class="BodyFirst">Any page that lets a user enter and submit information on a web page involves an HTML element called a <em>form</em>. When users enter information, we need to <em>validate</em> that the information provided is the right kind of data and is not malicious, such as code designed to interrupt our server. We then need to process and save valid information to the appropriate place in the database. Django automates much of this work.</p>
<p>The simplest way to build a form in Django is to use a <code>ModelForm</code>, which uses the information from the models we defined in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span> to build a form automatically. Write your first form in the file <em>forms.py</em>, which should be created in the same directory as <em>models.py</em>:</p>
<p class="CodeLabel"><b>forms.py</b></p>
<pre><code>from django import forms

from .models import Topic

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> class TopicForm(forms.ModelForm):
    class Meta:
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         model = Topic
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>         fields = ['text']
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>         labels = {'text': ''}</code></pre>
<p>We first import the <code>forms</code> module and the model we’ll work with, <code>Topic</code>. We then define a class called <code>TopicForm</code>, which inherits from <code>forms.ModelForm</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>
<p>The simplest version of a <code>ModelForm</code> consists of a nested <code>Meta</code> class telling Django which model to base the form on and which fields to include in the form. Here we specify that the form should be based on the <code>Topic</code> model <span aria-label="annotation2" class="CodeAnnotation">❷</span>, and that it should only include the <code>text</code> field <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The empty string in the labels dictionary tells Django not to generate a label for the <code>text</code> field <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</p>
<h4 id="h3-502703c19-0002"><span epub:type="pagebreak" id="Page_405" title="405"></span>The new_topic URL</h4>
<p class="BodyFirst">The URL for a new page should be short and descriptive. When the user wants to add a new topic, we’ll send them to <em>http://localhost:8000/new_topic/</em>. Here’s the URL pattern for the <code>new_topic</code> page; add this to <em>learning_logs/urls.py</em>:</p>
<p class="CodeLabel"><b>learning_logs/urls.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">urlpatterns = [</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">    </span># Page for adding a new topic.
    path('new_topic/', views.new_topic, name='new_topic'),
<span class="LiteralGray">]</span></code></pre>
<p>This URL pattern sends requests to the view function <code>new_topic()</code>, which we’ll write next.</p>
<h4 id="h3-502703c19-0003">The new_topic() View Function</h4>
<p class="BodyFirst">The <code>new_topic()</code> function needs to handle two different situations: initial requests for the <code>new_topic</code> page, in which case it should show a blank form; and the processing of any data submitted in the form. After data from a submitted form is processed, it needs to redirect the user back to the <code>topics</code> page:</p>
<p class="CodeLabel"><b>views.py</b></p>
<pre><code>from django.shortcuts import render, redirect

<span class="LiteralGray">from .models import Topic</span>
from .forms import TopicForm

<em class="LiteralGrayItalic">--snip--</em>
def new_topic(request):
    """Add a new topic."""
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>     if request.method != 'POST':
        # No data submitted; create a blank form.
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         form = TopicForm()
    else:
        # POST data submitted; process data.
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>         form = TopicForm(data=request.POST)
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>         if form.is_valid():
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span>             form.save()
<span aria-label="annotation6" class="CodeAnnotationHang">❻</span>             return redirect('learning_logs:topics')

    # Display a blank or invalid form.
<span aria-label="annotation7" class="CodeAnnotationHang">❼</span>     context = {'form': form}
    return render(request, 'learning_logs/new_topic.html', context)</code></pre>
<p>We import the function <code>redirect</code>, which we’ll use to redirect the user back to the <code>topics</code> page after they submit their topic. We also import the form we just wrote, <code>TopicForm</code>.</p>
<h4 id="h3-502703c19-0004"><span epub:type="pagebreak" id="Page_406" title="406"></span>GET and POST Requests</h4>
<p class="BodyFirst">The two main types of requests you’ll use when building apps are GET and POST. You use <em>GET</em> requests for pages that only read data from the server. You usually use <em>POST</em> requests when the user needs to submit information through a form. We’ll be specifying the POST method for processing all of our forms. (A few other kinds of requests exist, but we won’t use them in this project.)</p>
<p>The <code>new_topic()</code> function takes in the <code>request</code> object as a parameter. When the user initially requests this page, their browser will send a GET request. Once the user has filled out and submitted the form, their browser will submit a POST request. Depending on the request, we’ll know whether the user is requesting a blank form (GET) or asking us to process a completed form (POST).</p>
<p>We use an <code>if</code> test to determine whether the request method is GET or POST <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If the request method isn’t POST, the request is probably GET, so we need to return a blank form. (If it’s another kind of request, it’s still safe to return a blank form.) We make an instance of <code>TopicForm</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, assign it to the variable <code>form</code>, and send the form to the template in the <code>context</code> dictionary <span aria-label="annotation7" class="CodeAnnotation">❼</span>. Because we included no arguments when instantiating <code>TopicForm</code>, Django creates a blank form that the user can fill out.</p>
<p>If the request method is POST, the <code>else</code> block runs and processes the data submitted in the form. We make an instance of <code>TopicForm</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span> and pass it the data entered by the user, which is assigned to <code>request.POST</code>. The <code>form</code> object that’s returned contains the information submitted by the user.</p>
<p>We can’t save the submitted information in the database until we’ve checked that it’s valid <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The <code>is_valid()</code> method checks that all required fields have been filled in (all fields in a form are required by default) and that the data entered matches the field types expected—for example, that the length of <code>text</code> is less than 200 characters, as we specified in <em>models.py</em> in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>. This automatic validation saves us a lot of work. If everything is valid, we can call <code>save()</code> <span aria-label="annotation5" class="CodeAnnotation">❺</span>, which writes the data from the form to the database.</p>
<p>Once we’ve saved the data, we can leave this page. The <code>redirect()</code> function takes in the name of a view and redirects the user to the page associated with that view. Here we use <code>redirect()</code> to redirect the user’s browser to the <code>topics</code> page <span aria-label="annotation6" class="CodeAnnotation">❻</span>, where the user should see the topic they just entered in the list of topics.</p>
<p>The <code>context</code> variable is defined at the end of the view function, and the page is rendered using the template <em>new_topic.html</em>, which we’ll create next. This code is placed outside of any <code>if</code> block; it will run if a blank form was created, and it will run if a submitted form is determined to be invalid. An invalid form will include some default error messages to help the user submit acceptable data.</p>
<h4 id="h3-502703c19-0005"><span epub:type="pagebreak" id="Page_407" title="407"></span>The new_topic Template</h4>
<p class="BodyFirst">Now we’ll make a new template called <em>new_topic.html</em> to display the form we just created:</p>
<p class="CodeLabel"><b>new_topic.html</b></p>
<pre><code>{% extends "learning_logs/base.html" %}

{% block content %}
  &lt;p&gt;Add a new topic:&lt;/p&gt;

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>   &lt;form action="{% url 'learning_logs:new_topic' %}" method='post'&gt;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>     {% csrf_token %}
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>     {{ form.as_div }}
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>     &lt;button name="submit"&gt;Add topic&lt;/button&gt;
  &lt;/form&gt;

{% endblock content %}</code></pre>
<p>This template extends <em>base.html</em>, so it has the same base structure as the rest of the pages in Learning Log. We use the <code>&lt;form&gt;&lt;/form&gt;</code> tags to define an HTML form <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The <code>action</code> argument tells the browser where to send the data submitted in the form; in this case, we send it back to the view function <code>new_topic()</code>. The <code>method</code> argument tells the browser to submit the data as a POST request.</p>
<p>Django uses the template tag <code>{% csrf_token %}</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span> to prevent attackers from using the form to gain unauthorized access to the server. (This kind of attack is called a <em>cross-site request forgery</em>.) Next, we display the form; here you can see how simple Django can make certain tasks, such as displaying a form. We only need to include the template variable <code>{{ form.as_div }}</code> for Django to create all the fields necessary to display the form automatically <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The <code>as_div</code> modifier tells Django to render all the form elements as HTML <code>&lt;div&gt;&lt;/div&gt;</code> elements; this is a simple way to display the form neatly.</p>
<p>Django doesn’t create a submit button for forms, so we define one before closing the form <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</p>
<h4 id="h3-502703c19-0006">Linking to the new_topic Page</h4>
<p class="BodyFirst">Next, we include a link to the <code>new_topic</code> page on the <code>topics</code> page:</p>
<p class="CodeLabel"><b>topics.html</b></p>
<pre><code><span class="LiteralGray">{% extends "learning_logs/base.html" %}</span>

<span class="LiteralGray">{% block content %}</span>

<span class="LiteralGray">  &lt;p&gt;Topics&lt;/p&gt;</span>

<span class="LiteralGray">  &lt;ul&gt;</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">  &lt;/ul&gt;</span>

<span class="LiteralGray">  </span>&lt;a href="{% url 'learning_logs:new_topic' %}"&gt;Add a new topic&lt;/a&gt;

<span class="LiteralGray">{% endblock content %}</span></code></pre>
<p><span epub:type="pagebreak" id="Page_408" title="408"></span>Place the link after the list of existing topics. <a href="#figure19-1" id="figureanchor19-1">Figure 19-1</a> shows the resulting form; try using the form to add a few new topics of your own.</p>
<figure>
<img alt="" class="keyline" height="342" src="Images/f19001.png" width="581"/>
<figcaption><p><a id="figure19-1">Figure 19-1</a>: The page for adding a new topic</p></figcaption>
</figure>
<h3 id="h2-502703c19-0002">Adding New Entries</h3>
<p class="BodyFirst">Now that the user can add a new topic, they’ll want to add new entries too. We’ll again define a URL, write a view function and a template, and link to the page. But first, we’ll add another class to <em>forms.py</em>.</p>
<h4 id="h3-502703c19-0007">The Entry ModelForm</h4>
<p class="BodyFirst">We need to create a form associated with the <code>Entry</code> model, but this time, with a bit more customization than <code>TopicForm</code>:</p>
<p class="CodeLabel"><b>forms.py</b></p>
<pre><code><span class="LiteralGray">from django import forms</span>

from .models import Topic, Entry

<span class="LiteralGray">class TopicForm(forms.ModelForm):</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>

class EntryForm(forms.ModelForm):
    class Meta:
        model = Entry
        fields = ['text']
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         labels = {'text': ''}
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         widgets = {'text': forms.Textarea(attrs={'cols': 80})}</code></pre>
<p>We update the <code>import</code> statement to include <code>Entry</code> as well as <code>Topic</code>. We make a new class called <code>EntryForm</code> that inherits from <code>forms.ModelForm</code>. The <code>EntryForm</code> class has a nested <code>Meta</code> class listing the model it’s based on, and the field to include in the form. We again give the field <code>'text'</code> a blank label <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>
<p>For <code>EntryForm</code>, we include the <code>widgets</code> attribute <span aria-label="annotation2" class="CodeAnnotation">❷</span>. A <em>widget</em> is an HTML form element, such as a single-line text box, multiline text area, or drop-down list. By including the <code>widgets</code> attribute, you can override Django’s <span epub:type="pagebreak" id="Page_409" title="409"></span>default widget choices. Here we’re telling Django to use a <code>forms.Textarea</code> element with a width of 80 columns, instead of the default 40 columns. This gives users enough room to write a meaningful entry.</p>
<h4 id="h3-502703c19-0008">The new_entry URL</h4>
<p class="BodyFirst">New entries must be associated with a particular topic, so we need to include a <code>topic_id</code> argument in the URL for adding a new entry. Here’s the URL, which you add to <em>learning_logs/urls.py</em>:</p>
<p class="CodeLabel"><b>learning_logs/urls.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">urlpatterns = [</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>
    # Page for adding a new entry.
    path('new_entry/&lt;int:topic_id&gt;/', views.new_entry, name='new_entry'),
<span class="LiteralGray">]</span></code></pre>
<p>This URL pattern matches any URL with the form <em>http://localhost:8000/new_entry/id/</em>, where <var>id</var> is a number matching the topic ID. The code <code>&lt;int:topic_id&gt;</code> captures a numerical value and assigns it to the variable <code>topic_id</code>. When a URL matching this pattern is requested, Django sends the request and the topic’s ID to the <code>new_entry()</code> view function.</p>
<h4 id="h3-502703c19-0009">The new_entry() View Function</h4>
<p class="BodyFirst">The view function for <code>new_entry</code> is much like the function for adding a new topic. Add the following code to your <em>views.py</em> file:</p>
<p class="CodeLabel"><b>views.py</b></p>
<pre><code><span class="LiteralGray">from django.shortcuts import render, redirect</span>

<span class="LiteralGray">from .models import Topic</span>
from .forms import TopicForm, EntryForm

<em class="LiteralGrayItalic">--snip--</em>
def new_entry(request, topic_id):
    """Add a new entry for a particular topic."""
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>     topic = Topic.objects.get(id=topic_id)

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>     if request.method != 'POST':
        # No data submitted; create a blank form.
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>         form = EntryForm()
    else:
        # POST data submitted; process data.
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>         form = EntryForm(data=request.POST)
        if form.is_valid():
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span>             new_entry = form.save(commit=False)
<span aria-label="annotation6" class="CodeAnnotationHang">❻</span>             new_entry.topic = topic
            new_entry.save()
<span aria-label="annotation7" class="CodeAnnotationHang">❼</span>             return redirect('learning_logs:topic', topic_id=topic_id)

    # Display a blank or invalid form.
    context = {'topic': topic, 'form': form}
    return render(request, 'learning_logs/new_entry.html', context)</code></pre>
<p><span epub:type="pagebreak" id="Page_410" title="410"></span>We update the <code>import</code> statement to include the <code>EntryForm</code> we just made. The definition of <code>new_entry()</code> has a <code>topic_id</code> parameter to store the value it receives from the URL. We’ll need the topic to render the page and process the form’s data, so we use <code>topic_id</code> to get the correct topic object <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>
<p>Next, we check whether the request method is POST or GET <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The <code>if</code> block executes if it’s a GET request, and we create a blank instance of <code>EntryForm</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p>If the request method is POST, we process the data by making an instance of <code>EntryForm</code>, populated with the POST data from the <code>request</code> object <span aria-label="annotation4" class="CodeAnnotation">❹</span>. We then check whether the form is valid. If it is, we need to set the entry object’s <code>topic</code> attribute before saving it to the database. When we call <code>save()</code>, we include the argument <code>commit=False</code> <span aria-label="annotation5" class="CodeAnnotation">❺</span> to tell Django to create a new entry object and assign it to <code>new_entry</code>, without saving it to the database yet. We set the <code>topic</code> attribute of <code>new_entry</code> to the topic we pulled from the database at the beginning of the function <span aria-label="annotation6" class="CodeAnnotation">❻</span>. Then we call <code>save()</code> with no arguments, saving the entry to the database with the correct associated topic.</p>
<p>The <code>redirect()</code> call requires two arguments: the name of the view we want to redirect to and the argument that view function requires <span aria-label="annotation7" class="CodeAnnotation">❼</span>. Here, we’re redirecting to <code>topic()</code>, which needs the argument <code>topic_id</code>. This view then renders the topic page that the user made an entry for, and they should see their new entry in the list of entries.</p>
<p>At the end of the function, we create a <code>context</code> dictionary and render the page using the <em>new_entry.html</em> template. This code will execute for a blank form, or for a form that’s been submitted but turns out to be invalid.</p>
<h4 id="h3-502703c19-0010">The new_entry Template</h4>
<p class="BodyFirst">As you can see in the following code, the template for <code>new_entry</code> is similar to the template for <code>new_topic</code>:</p>
<p class="CodeLabel"><b>new_entry.html</b></p>
<pre><code>{% extends "learning_logs/base.html" %}

{% block content %}

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>   &lt;p&gt;&lt;a href="{% url 'learning_logs:topic' topic.id %}"&gt;{{ topic }}&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Add a new entry:&lt;/p&gt;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>   &lt;form action="{% url 'learning_logs:new_entry' topic.id %}" method='post'&gt;
    {% csrf_token %}
    {{ form.as_div }}
    &lt;button name='submit'&gt;Add entry&lt;/button&gt;
  &lt;/form&gt;

{% endblock content %}</code></pre>
<p>We show the topic at the top of the page <span aria-label="annotation1" class="CodeAnnotation">❶</span>, so the user can see which topic they’re adding an entry to. The topic also acts as a link back to the main page for that topic.</p>
<p><span epub:type="pagebreak" id="Page_411" title="411"></span>The form’s <code>action</code> argument includes the <code>topic.id</code> value in the URL, so the view function can associate the new entry with the correct topic <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Other than that, this template looks just like <em>new_topic.html</em>.</p>
<h4 id="h3-502703c19-0011">Linking to the new_entry Page</h4>
<p class="BodyFirst">Next, we need to include a link to the <code>new_entry</code> page from each topic page, in the topic template:</p>
<p class="CodeLabel"><b>topic.html</b></p>
<pre><code><span class="LiteralGray">{% extends "learning_logs/base.html" %}</span>

<span class="LiteralGray">{% block content %}</span>

<span class="LiteralGray">  &lt;p&gt;Topic: {{ topic }}&lt;/p&gt;</span>

<span class="LiteralGray">  &lt;p&gt;Entries:&lt;/p&gt;</span>
  &lt;p&gt;
    &lt;a href="{% url 'learning_logs:new_entry' topic.id %}"&gt;Add new entry&lt;/a&gt;
  &lt;/p&gt;

<span class="LiteralGray">  &lt;ul&gt;</span>
<span class="LiteralGray">  </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">  &lt;/ul&gt;</span>

<span class="LiteralGray">{% endblock content %}</span></code></pre>
<p>We place the link to add entries just before showing the entries, because adding a new entry will be the most common action on this page. <a href="#figure19-2" id="figureanchor19-2">Figure 19-2</a> shows the <code>new_entry</code> page. Now users can add new topics and as many entries as they want for each topic. Try out the <code>new_entry</code> page by adding a few entries to some of the topics you’ve created.</p>
<figure>
<img alt="" class="keyline" height="399" src="Images/f19002.png" width="679"/>
<figcaption><p><a id="figure19-2">Figure 19-2</a>: The <span class="LiteralInCaption"><code>new_entry</code></span> page</p></figcaption>
</figure>
<h3 id="h2-502703c19-0003"><span epub:type="pagebreak" id="Page_412" title="412"></span>Editing Entries</h3>
<p class="BodyFirst">Now we’ll make a page so users can edit the entries they’ve added.</p>
<h4 id="h3-502703c19-0012">The edit_entry URL</h4>
<p class="BodyFirst">The URL for the page needs to pass the ID of the entry to be edited. Here’s <em>learning_logs/urls.py</em>:</p>
<p class="CodeLabel"><b>urls.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">urlpatterns = [</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>
    # Page for editing an entry.
    path('edit_entry/&lt;int:entry_id&gt;/', views.edit_entry, name='edit_entry'),
<span class="LiteralGray">]</span></code></pre>
<p>This URL pattern matches URLs like <em>http://localhost:8000/edit_entry/id/</em>. Here the value of <var>id</var> is assigned to the parameter <code>entry_id</code>. Django sends requests that match this format to the view function <code>edit_entry()</code>.</p>
<h4 id="h3-502703c19-0013">The edit_entry() View Function</h4>
<p class="BodyFirst">When the <code>edit_entry</code> page receives a GET request, the <code>edit_entry()</code> function returns a form for editing the entry. When the page receives a POST request with revised entry text, it saves the modified text into the database:</p>
<p class="CodeLabel"><b>views.py</b></p>
<pre><code><span class="LiteralGray">from django.shortcuts import render, redirect</span>

from .models import Topic, Entry
<span class="LiteralGray">from .forms import TopicForm, EntryForm</span>
<em class="LiteralGrayItalic">--snip--</em>

def edit_entry(request, entry_id):
    """Edit an existing entry."""
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>     entry = Entry.objects.get(id=entry_id)
    topic = entry.topic

    if request.method != 'POST':
        # Initial request; pre-fill form with the current entry.
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         form = EntryForm(instance=entry)
    else:
        # POST data submitted; process data.
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>         form = EntryForm(instance=entry, data=request.POST)
        if form.is_valid():
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>             form.save()
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span>             return redirect('learning_logs:topic', topic_id=topic.id)

    context = {'entry': entry, 'topic': topic, 'form': form}
    return render(request, 'learning_logs/edit_entry.html', context)</code></pre>
<p>We first import the <code>Entry</code> model. We then get the entry object that the user wants to edit <span aria-label="annotation1" class="CodeAnnotation">❶</span> and the topic associated with this entry. In the <code>if</code> <span epub:type="pagebreak" id="Page_413" title="413"></span>block, which runs for a GET request, we make an instance of <code>EntryForm</code> with the argument <code>instance=entry</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. This argument tells Django to create the form, prefilled with information from the existing entry object. The user will see their existing data and be able to edit that data.</p>
<p>When processing a POST request, we pass both the <code>instance=entry</code> and the <code>data=request.POST</code> arguments <span aria-label="annotation3" class="CodeAnnotation">❸</span>. These arguments tell Django to create a form instance based on the information associated with the existing entry object, updated with any relevant data from <code>request.POST</code>. We then check whether the form is valid; if it is, we call <code>save()</code> with no arguments because the entry is already associated with the correct topic <span aria-label="annotation4" class="CodeAnnotation">❹</span>. We then redirect to the <code>topic</code> page, where the user should see the updated version of the entry they edited <span aria-label="annotation5" class="CodeAnnotation">❺</span>.</p>
<p>If we’re showing an initial form for editing the entry or if the submitted form is invalid, we create the <code>context</code> dictionary and render the page using the <em>edit_entry.html</em> template.</p>
<h4 id="h3-502703c19-0014">The edit_entry Template</h4>
<p class="BodyFirst">Next, we create an <em>edit_entry.html </em>template, which is similar to <em>new_entry.html</em>:</p>
<p class="CodeLabel"><b>edit_entry.html</b></p>
<pre><code>{% extends "learning_logs/base.html" %}

{% block content %}

  &lt;p&gt;&lt;a href="{% url 'learning_logs:topic' topic.id %}"&gt;{{ topic }}&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Edit entry:&lt;/p&gt;

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>   &lt;form action="{% url 'learning_logs:edit_entry' entry.id %}" method='post'&gt;
    {% csrf_token %}
    {{ form.as_div }}
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>     &lt;button name="submit"&gt;Save changes&lt;/button&gt;
  &lt;/form&gt;

{% endblock content %}</code></pre>
<p>The <code>action</code> argument sends the form back to the <code>edit_entry()</code> function for processing <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We include the <code>entry.id</code> as an argument in the <code>{% url %}</code> tag, so the view function can modify the correct entry object. We label the submit button as <code>Save changes</code> to remind the user they’re saving edits, not creating a new entry <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</p>
<h4 id="h3-502703c19-0015">Linking to the edit_entry Page</h4>
<p class="BodyFirst">Now we need to include a link to the <code>edit_entry</code> page for each entry on the topic page:</p>
<p class="CodeLabel"><b>topic.html</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">    {% for entry in entries %}</span>
<span class="LiteralGray">      &lt;li&gt;</span>
<span epub:type="pagebreak" id="Page_414" title="414"></span><span class="LiteralGray">        &lt;p&gt;{{ entry.date_added|date:'M d, Y H:i' }}&lt;/p&gt;</span>
<span class="LiteralGray">        &lt;p&gt;{{ entry.text|linebreaks }}&lt;/p&gt;</span>
<span class="LiteralGray">        </span>&lt;p&gt;
          &lt;a href="{% url 'learning_logs:edit_entry' entry.id %}"&gt;
           Edit entry&lt;/a&gt;&lt;/p&gt;
<span class="LiteralGray">      &lt;/li&gt;</span>
<em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>We include the edit link after each entry’s date and text has been displayed. We use the <code>{% url %}</code> template tag to determine the URL for the named URL pattern <code>edit_entry</code>, along with the ID attribute of the current entry in the loop (<code>entry.id</code>). The link text <code>Edit entry</code> appears after each entry on the page. <a href="#figure19-3" id="figureanchor19-3">Figure 19-3</a> shows what the topic page looks like with these links.</p>
<figure>
<img alt="" class="keyline" height="522" src="Images/f19003.png" width="694"/>
<figcaption><p><a id="figure19-3">Figure 19-3</a>: Each entry now has a link for editing that entry.</p></figcaption>
</figure>
<p>Learning Log now has most of the functionality it needs. Users can add topics and entries, and they can read through any set of entries they want. In the next section, we’ll implement a user registration system so anyone can make an account with Learning Log and create their own set of topics and entries.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" id="Page_415" title="415"></span>Try It Yourself</h2>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c19-04">19-1.	Blog:</span> Start a new Django project called <em>Blog</em>. Create an app called <em>blogs</em>, with one model that represents an overall blog, and one model that represents an individual blog post. Give each model an appropriate set of fields. Create a superuser for the project, and use the admin site to make a blog and a couple of short posts. Make a home page that shows all posts in an appropriate order.</p>
<p class="BoxBody">Create pages for making a blog, for making new posts, and for editing existing posts. Use your pages to make sure they work.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502703c19-0002">Setting Up User Accounts</h2>
<p class="BodyFirst">In this section, we’ll set up a user registration and authorization system so people can register an account, log in, and log out. We’ll create a new app to contain all the functionality related to working with users. We’ll use the default user authentication system included with Django to do as much of the work as possible. We’ll also modify the <code>Topic</code> model slightly so every topic belongs to a certain user.</p>
<h3 id="h2-502703c19-0004">The accounts App</h3>
<p class="BodyFirst">We’ll start by creating a new app called <code>accounts</code>, using the <code>startapp</code> command:</p>
<pre><code>(ll_env)learning_log$ <b>python manage.py startapp accounts</b>
(ll_env)learning_log$ <b>ls</b>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> accounts db.sqlite3 learning_logs ll_env ll_project manage.py
(ll_env)learning_log$ <b>ls accounts</b>
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> __init__.py admin.py apps.py migrations models.py tests.py views.py</code></pre>
<p>The default authentication system is built around the concept of user accounts, so using the name <code>accounts</code> makes integration with the default system easier. The <code>startapp</code> command shown here makes a new directory called <em>accounts</em> <span aria-label="annotation1" class="CodeAnnotation">❶</span> with a structure identical to the <code>learning_logs</code> app <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</p>
<h4 id="h3-502703c19-0016">Adding accounts to settings.py</h4>
<p class="BodyFirst">We need to add our new app to <code>INSTALLED_APPS</code> in <em>settings.py</em>, like so:</p>
<p class="CodeLabel"><b>settings.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">INSTALLED_APPS = [</span>
<span class="LiteralGray">    # My apps</span>
<span class="LiteralGray">    'learning_logs',</span>
    'accounts',

<span epub:type="pagebreak" id="Page_416" title="416"></span><span class="LiteralGray">    # Default django apps.</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">]</span>
<em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>Now Django will include the <code>accounts</code> app in the overall project.</p>
<h4 id="h3-502703c19-0017">Including the URLs from accounts</h4>
<p class="BodyFirst">Next, we need to modify the root <em>urls.py</em> so it includes the URLs we’ll write for the <code>accounts</code> app:</p>
<p class="CodeLabel"><b>ll_project/urls.py</b></p>
<pre><code><span class="LiteralGray">from django.contrib import admin</span>
<span class="LiteralGray">from django.urls import path, include</span>

<span class="LiteralGray">urlpatterns = [</span>
<span class="LiteralGray">    path('admin/', admin.site.urls),</span>
    path('accounts/', include('accounts.urls')),
<span class="LiteralGray">    path('', include('learning_logs.urls')),</span>
<span class="LiteralGray">]</span></code></pre>
<p>We add a line to include the file <em>urls.py</em> from <code>accounts</code>. This line will match any URL that starts with the word <em>accounts</em>, such as <em>http://localhost:8000/accounts/login/</em>.</p>
<h3 id="h2-502703c19-0005">The Login Page</h3>
<p class="BodyFirst">We’ll first implement a login page. We’ll use the default <code>login</code> view Django provides, so the URL pattern for this app looks a little different. Make a new <em>urls.py</em> file in the directory <em>ll_project/accounts/</em> and add the following to it:</p>
<p class="CodeLabel"><b>accounts/urls.py</b></p>
<pre><code>"""Defines URL patterns for accounts."""

from django.urls import path, include

app_name = 'accounts'
urlpatterns = [
    # Include default auth urls.
    path('', include('django.contrib.auth.urls')),
]</code></pre>
<p>We import the <code>path</code> function, and then import the <code>include</code> function so we can include some default authentication URLs that Django has defined. These default URLs include named URL patterns, such as <code>'login'</code> and <code>'logout'</code>. We set the variable <code>app_name</code> to <code>'accounts'</code> so Django can distinguish these URLs from URLs belonging to other apps. Even default URLs provided by Django, when included in the <code>accounts</code> app’s <em>urls.py</em> file, will be accessible through the <code>accounts</code> namespace.</p>
<p><span epub:type="pagebreak" id="Page_417" title="417"></span>The login page’s pattern matches the URL <em>http://localhost:8000/accounts/login/</em>. When Django reads this URL, the word <em>accounts</em> tells Django to look in <em>accounts/urls.py</em>, and <em>login</em> tells it to send requests to Django’s default <code>login</code> view.</p>
<h4 id="h3-502703c19-0018">The login Template</h4>
<p class="BodyFirst">When the user requests the login page, Django will use a default view function, but we still need to provide a template for the page. The default authentication views look for templates inside a folder called <em>registration</em>, so we’ll need to make that folder. Inside the <em>ll_project/accounts/</em> directory, make a directory called <em>templates</em>; inside that, make another directory called <em>registration</em>. Here’s the <em>login.html</em> template, which should be saved in <em>ll_project/accounts/templates/registration</em>:</p>
<p class="CodeLabel"><b>login.html</b></p>
<pre><code>{% extends 'learning_logs/base.html' %}

{% block content %}

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>   {% if form.errors %}
    &lt;p&gt;Your username and password didn't match. Please try again.&lt;/p&gt;
  {% endif %}

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>   &lt;form action="{% url 'accounts:login' %}" method='post'&gt;
    {% csrf_token %}
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>     {{ form.as_div }}

<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>     &lt;button name="submit"&gt;Log in&lt;/button&gt;
  &lt;/form&gt;

{% endblock content %}</code></pre>
<p>This template extends <em>base.html</em> to ensure that the login page will have the same look and feel as the rest of the site. Note that a template in one app can inherit from a template in another app.</p>
<p>If the form’s <code>errors</code> attribute is set, we display an error message <span aria-label="annotation1" class="CodeAnnotation">❶</span>, reporting that the username and password combination doesn’t match anything stored in the database.</p>
<p>We want the login view to process the form, so we set the <code>action</code> argument as the URL of the login page <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The login view sends a <code>form</code> object to the template, and it’s up to us to display the form <span aria-label="annotation3" class="CodeAnnotation">❸</span> and add a submit button <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</p>
<h4 id="h3-502703c19-0019">The LOGIN_REDIRECT_URL Settting</h4>
<p class="BodyFirst">Once a user logs in successfully, Django needs to know where to send that user. We control this in the settings file.</p>
<p><span epub:type="pagebreak" id="Page_418" title="418"></span>Add the following code to the end of <em>settings.py</em>:</p>
<p class="CodeLabel"><b>settings.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
# My settings.
LOGIN_REDIRECT_URL = 'learning_logs:index'</code></pre>
<p>With all the default settings in <em>settings.py</em>, it’s helpful to mark off the section where we’re adding new settings. The first new setting we’ll add is <code>LOGIN_REDIRECT_URL</code>, which tells Django which URL to redirect to after a successful login attempt.</p>
<h4 id="h3-502703c19-0020">Linking to the Login Page</h4>
<p class="BodyFirst">Let’s add the login link to <em>base.html</em> so it appears on every page. We don’t want the link to display when the user is already logged in, so we nest it inside an <code>{% if %}</code> tag:</p>
<p class="CodeLabel"><b>base.html</b></p>
<pre><code><span class="LiteralGray">&lt;p&gt;</span>
<span class="LiteralGray">  &lt;a href="{% url 'learning_logs:index' %}"&gt;Learning Log&lt;/a&gt; -</span>
<span class="LiteralGray">  </span>&lt;a href="{% url 'learning_logs:topics' %}"&gt;Topics&lt;/a&gt; -
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>   {% if user.is_authenticated %}
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>     Hello, {{ user.username }}.
  {% else %}
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>     &lt;a href="{% url 'accounts:login' %}"&gt;Log in&lt;/a&gt;
  {% endif %}
<span class="LiteralGray">&lt;/p&gt;</span>

<span class="LiteralGray">{% block content %}{% endblock content %}</span></code></pre>
<p>In Django’s authentication system, every template has a <code>user</code> object available that always has an <code>is_authenticated</code> attribute set: the attribute is <code>True</code> if the user is logged in and <code>False</code> if they aren’t. This attribute allows you to display one message to authenticated users and another to unauthenticated users.</p>
<p>Here we display a greeting to users currently logged in <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Authenticated users have an additional <code>username</code> attribute set, which we use to personalize the greeting and remind the user they’re logged in <span aria-label="annotation2" class="CodeAnnotation">❷</span>. For users who haven’t been authenticated, we display a link to the login page <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<h4 id="h3-502703c19-0021">Using the Login Page</h4>
<p class="BodyFirst">We’ve already set up a user account, so let’s log in to see if the page works. Go to <em>http://localhost:8000/admin/</em>. If you’re still logged in as an admin, look for a <b>logout</b> link in the header and click it.</p>
<p>When you’re logged out, go to <em>http://localhost:8000/accounts/login/</em>. You should see a login page similar to the one shown in <a href="#figure19-4" id="figureanchor19-4">Figure 19-4</a>. Enter the username and password you set up earlier, and you should be brought back to the home page. The header on the home page should display a greeting personalized with your username.</p>
<span epub:type="pagebreak" id="Page_419" title="419"></span><figure>
<img alt="" class="keyline" height="368" src="Images/f19004.png" width="624"/>
<figcaption><p><a id="figure19-4">Figure 19-4</a>: The login page</p></figcaption>
</figure>
<h3 id="h2-502703c19-0006">Logging Out</h3>
<p class="BodyFirst">Now we need to provide a way for users to log out. Logout requests should be submitted as POST requests, so we’ll add a small logout form to <em>base.html</em>. When users click the logout button, they’ll go to a page confirming that they’ve been logged out.</p>
<h4 id="h3-502703c19-0022">Adding a Logout Form to base.html</h4>
<p class="BodyFirst">We’ll add the form for logging out to <em>base.html</em> so it’s available on every page. We’ll include it in another <code>if</code> block, so only users who are already logged in can see it:</p>
<p class="CodeLabel"><b>base.html</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">{% block content %}{% endblock content %}</span>

{% if user.is_authenticated %}
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>   &lt;hr /&gt;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>   &lt;form action="{% url 'accounts:logout' %}" method='post'&gt;
    {% csrf_token %}
    &lt;button name='submit'&gt;Log out&lt;/button&gt;
  &lt;/form&gt;
{% endif %}</code></pre>
<p>The default URL pattern for logging out is <code>'accounts/logout/'</code>. However, the request has to be sent as a POST request; otherwise, attackers can easily force logout requests. To make the logout request use POST, we define a simple form.</p>
<p>We place the form at the bottom of the page, below a horizontal rule element (<code>&lt;hr /&gt;</code>) <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This is an easy way to always keep the logout button in a <span epub:type="pagebreak" id="Page_420" title="420"></span>consistent position below any other content on the page. The form itself has the logout URL as its <code>action</code> argument, and <code>'post'</code> as the request method <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Every form in Django needs to include the <code>{% csrf_token %}</code>, even a simple form like this one. This form is empty except for the submit button.</p>
<h4 id="h3-502703c19-0023">The LOGOUT_REDIRECT_URL Setting</h4>
<p class="BodyFirst">When the user clicks the logout button, Django needs to know where to send them. We control this behavior in <em>settings.py</em>:</p>
<p class="CodeLabel"><b>settings.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray"># My settings.</span>
<span class="LiteralGray">LOGIN_REDIRECT_URL = 'learning_logs:index'</span>
LOGOUT_REDIRECT_URL = 'learning_logs:index'</code></pre>
<p>The <code>LOGOUT_REDIRECT_URL</code> setting shown here tells Django to redirect logged-out users back to the home page. This is a simple way to confirm that they were logged out, because they should no longer see their username after logging out.</p>
<h3 id="h2-502703c19-0007">The Registration Page</h3>
<p class="BodyFirst">Next, we’ll build a page so new users can register. We’ll use Django’s default <code>UserCreationForm</code>, but write our own view function and template.</p>
<h4 id="h3-502703c19-0024">The register URL</h4>
<p class="BodyFirst">The following code provides the URL pattern for the registration page, which should be placed in <em>accounts/urls.py</em>:</p>
<p class="CodeLabel"><b>accounts/urls.py</b></p>
<pre><code><span class="LiteralGray">"""Defines URL patterns for accounts."""</span>

<span class="LiteralGray">from django.urls import path, include</span>

from . import views

<span class="LiteralGray">app_name = accounts</span>
<span class="LiteralGray">urlpatterns = [</span>
<span class="LiteralGray">    # Include default auth urls.</span>
<span class="LiteralGray">    path('', include('django.contrib.auth.urls')),</span>
    # Registration page.
    path('register/', views.register, name='register'),
<span class="LiteralGray">]</span></code></pre>
<p>We import the <code>views</code> module from <code>accounts</code>, which we need because we’re writing our own view for the registration page. The pattern for the registration page matches the URL <em>http://localhost:8000/accounts/register/</em> and sends requests to the <code>register()</code> function we’re about to write.</p>
<h4 id="h3-502703c19-0025"><span epub:type="pagebreak" id="Page_421" title="421"></span>The register() View Function</h4>
<p class="BodyFirst">The <code>register()</code> view function needs to display a blank registration form when the registration page is first requested, and then process completed registration forms when they’re submitted. When a registration is successful, the function also needs to log the new user in. Add the following code to<em> accounts/views.py</em>:</p>
<p class="CodeLabel"><b>accounts/views.py</b></p>
<pre><code>from django.shortcuts import render, redirect
from django.contrib.auth import login
from django.contrib.auth.forms import UserCreationForm

def register(request):
    """Register a new user."""
    if request.method != 'POST':
        # Display blank registration form.
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>         form = UserCreationForm()
    else:
        # Process completed form.
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>         form = UserCreationForm(data=request.POST)

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>         if form.is_valid():
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span>             new_user = form.save()
            # Log the user in and then redirect to home page.
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span>             login(request, new_user)
<span aria-label="annotation6" class="CodeAnnotationHang">❻</span>             return redirect('learning_logs:index')

    # Display a blank or invalid form.
    context = {'form': form}
    return render(request, 'registration/register.html', context)</code></pre>
<p>We import the <code>render()</code> and <code>redirect()</code> functions, and then we import the <code>login()</code> function to log the user in if their registration information is correct. We also import the default <code>UserCreationForm</code>. In the <code>register()</code> function, we check whether we’re responding to a POST request. If we’re not, we make an instance of <code>UserCreationForm</code> with no initial data <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>
<p>If we’re responding to a POST request, we make an instance of <code>UserCreationForm</code> based on the submitted data <span aria-label="annotation2" class="CodeAnnotation">❷</span>. We check that the data is valid <span aria-label="annotation3" class="CodeAnnotation">❸</span>—in this case, that the username has the appropriate characters, the passwords match, and the user isn’t trying to do anything malicious in their submission.</p>
<p>If the submitted data is valid, we call the form’s <code>save()</code> method to save the username and the hash of the password to the database <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The <code>save()</code> method returns the newly created user object, which we assign to <code>new_user</code>. When the user’s information is saved, we log them in by calling the <code>login()</code> function with the <code>request</code> and <code>new_user</code> objects <span aria-label="annotation5" class="CodeAnnotation">❺</span>, which creates a valid session for the new user. Finally, we redirect the user to the home page <span aria-label="annotation6" class="CodeAnnotation">❻</span>, <span epub:type="pagebreak" id="Page_422" title="422"></span>where a personalized greeting in the header tells them their registration was successful.</p>
<p>At the end of the function, we render the page, which will be either a blank form or a submitted form that’s invalid.</p>
<h4 id="h3-502703c19-0026">The register Template</h4>
<p class="BodyFirst">Now create a template for the registration page, which will be similar to the login page. Be sure to save it in the same directory as <em>login.html</em>:</p>
<p class="CodeLabel"><b>register.html</b></p>
<pre><code>{% extends "learning_logs/base.html" %}

{% block content %}

  &lt;form action="{% url 'accounts:register' %}" method='post'&gt;
    {% csrf_token %}
    {{ form.as_div }}

    &lt;button name="submit"&gt;Register&lt;/button&gt;
  &lt;/form&gt;

{% endblock content %}</code></pre>
<p>This should look like the other form-based templates we’ve been writing. We use the <code>as_div</code> method again so Django will display all the fields in the form appropriately, including any error messages if the form isn’t filled out correctly.</p>
<h4 id="h3-502703c19-0027">Linking to the Registration Page</h4>
<p class="BodyFirst">Next, we’ll add code to show the registration page link to any user who isn’t currently logged in:</p>
<p class="CodeLabel"><b>base.html</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">  {% if user.is_authenticated %}</span>
<span class="LiteralGray">    Hello, {{ user.username }}.</span>
<span class="LiteralGray">  {% else %}</span>
<span class="LiteralGray">    </span>&lt;a href="{% url 'accounts:register' %}"&gt;Register&lt;/a&gt; -
<span class="LiteralGray">    &lt;a href="{% url 'accounts:login' %}"&gt;Log in&lt;/a&gt;</span>
<span class="LiteralGray">  {% endif %}</span>
<em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>Now users who are logged in see a personalized greeting and a logout button. Users who aren’t logged in see a registration link and a login link. Try out the registration page by making several user accounts with different usernames.</p>
<p>In the next section, we’ll restrict some of the pages so they’re available only to registered users, and we’ll make sure every topic belongs to a specific user.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_423" title="423"></span><h2><span class="NoteHead">Note</span></h2>
<p>	The registration system we’ve set up allows anyone to make any number of accounts for Learning Log. Some systems require users to confirm their identity by sending a confirmation email that users must reply to. By doing so, the system generates fewer spam accounts than the simple system we’re using here. However, when you’re learning to build apps, it’s perfectly appropriate to practice with a simple user registration system like the one we’re using.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try It Yourself</h2>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c19-09">19-2.	Blog Accounts:</span> Add a user authentication and registration system to the Blog project you started in Exercise 19-1 (<span class="xref" itemid="xref_target_page 415">page 415</span>). Make sure logged-in users see their username somewhere on the screen and unregistered users see a link to the registration page.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502703c19-0003">Allowing Users to Own Their Data</h2>
<p class="BodyFirst">Users should be able to enter private data in their learning logs, so we’ll create a system to figure out which data belongs to which user. Then we’ll restrict access to certain pages so users can only work with their own data.</p>
<p>We’ll modify the <code>Topic</code> model so every topic belongs to a specific user. This will also take care of entries, because every entry belongs to a specific topic. We’ll start by restricting access to certain pages.</p>
<h3 id="h2-502703c19-0008">Restricting Access with @login_required</h3>
<p class="BodyFirst">Django makes it easy to restrict access to certain pages through the <code>@login_required</code> decorator. Recall from <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> that a <em>decorator</em> is a directive placed just before a function definition, which modifies how the function behaves. Let’s look at an example.</p>
<h4 id="h3-502703c19-0028">Restricting Access to the Topics Page</h4>
<p class="BodyFirst">Each topic will be owned by a user, so only registered users can request the topics page. Add the following code to <em>learning_logs/views.py</em>:</p>
<p class="CodeLabel"><b>learning_logs/views.py</b></p>
<pre><code><span class="LiteralGray">from django.shortcuts import render, redirect</span>
from django.contrib.auth.decorators import login_required

<span class="LiteralGray">from .models import Topic, Entry</span>
<em class="LiteralGrayItalic">--snip--</em>

@login_required
<span class="LiteralGray">def topics(request):</span>
<span class="LiteralGray">    """Show all topics."""</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em></code></pre>
<p><span epub:type="pagebreak" id="Page_424" title="424"></span>We first import the <code>login_required()</code> function. We apply <code>login_required()</code> as a decorator to the <code>topics()</code> view function by prepending <code>login_required</code> with the <code>@</code> symbol. As a result, Python knows to run the code in <code>login_required()</code> before the code in <code>topics()</code>.</p>
<p>The code in <code>login_required()</code> checks whether a user is logged in, and Django runs the code in <code>topics()</code> only if they are. If the user isn’t logged in, they’re redirected to the login page.</p>
<p>To make this redirect work, we need to modify <em>settings.py</em> so Django knows where to find the login page. Add the following at the end of <em>settings.py</em>:</p>
<p class="CodeLabel"><b>settings.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray"># My settings.</span>
<span class="LiteralGray">LOGIN_REDIRECT_URL = 'learning_logs:index'</span>
<span class="LiteralGray">LOGOUT_REDIRECT_URL = 'learning_logs:index'</span>
LOGIN_URL = 'accounts:login'</code></pre>
<p>Now when an unauthenticated user requests a page protected by the <code>@login_required</code> decorator, Django will send the user to the URL defined by <code>LOGIN_URL</code> in <em>settings.py</em>.</p>
<p>You can test this setting by logging out of any user accounts and going to the home page. Click the <b>Topics</b> link, which should redirect you to the login page. Then log in to any of your accounts, and from the home page, click the <b>Topics</b> link again. You should be able to access the topics page.</p>
<h4 id="h3-502703c19-0029">Restricting Access Throughout Learning Log</h4>
<p class="BodyFirst">Django makes it easy to restrict access to pages, but you have to decide which pages to protect. It’s best to think about which pages need to be unrestricted first, and then restrict all the other pages in the project. You can easily correct over-restricted access, and it’s less dangerous than leaving sensitive pages unrestricted.</p>
<p>In Learning Log, we’ll keep the home page and the registration page unrestricted. We’ll restrict access to every other page.</p>
<p>Here’s <em>learning_logs/views.py</em> with <code>@login_required</code> decorators applied to every view except <code>index()</code>:</p>
<p class="CodeLabel"><b>learning_logs/views.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">@login_required</span>
<span class="LiteralGray">def topics(request):</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>

@login_required
<span class="LiteralGray">def topic(request, topic_id):</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>

@login_required
<span class="LiteralGray">def new_topic(request):</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>

<span epub:type="pagebreak" id="Page_425" title="425"></span>@login_required
<span class="LiteralGray">def new_entry(request, topic_id):</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>

@login_required
<span class="LiteralGray">def edit_entry(request, entry_id):</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>Try accessing each of these pages while logged out; you should be redirected back to the login page. You’ll also be unable to click links to pages such as <code>new_topic</code>. But if you enter the URL <em>http://localhost:8000/new_topic/</em>, you’ll be redirected to the login page. You should restrict access to any URL that’s publicly accessible and relates to private user data.</p>
<h3 id="h2-502703c19-0009">Connecting Data to Certain Users</h3>
<p class="BodyFirst">Next, we need to connect the data to the user who submitted it. We only need to connect the data highest in the hierarchy to a user, and the lower-level data will follow. In Learning Log, topics are the highest level of data in the app, and all entries are connected to a topic. As long as each topic belongs to a specific user, we can trace the ownership of each entry in the database.</p>
<p>We’ll modify the <code>Topic</code> model by adding a foreign key relationship to a user. We’ll then have to migrate the database. Finally, we’ll modify some of the views so they only show the data associated with the currently logged-in user.</p>
<h4 id="h3-502703c19-0030">Modifying the Topic Model</h4>
<p class="BodyFirst">The modification to <em>models.py</em> is just two lines:</p>
<p class="CodeLabel"><b>models.py</b></p>
<pre><code><span class="LiteralGray">from django.db import models</span>
from django.contrib.auth.models import User

<span class="LiteralGray">class Topic(models.Model):</span>
<span class="LiteralGray">   """A topic the user is learning about."""</span>
<span class="LiteralGray">    Text = models.CharField(max_length=200)</span>
<span class="LiteralGray">    date_added = models.DateTimeField(auto_now_add=True)</span>
    owner = models.ForeignKey(User, on_delete=models.CASCADE)

<span class="LiteralGray">    def __str__(self):</span>
<span class="LiteralGray">        """Return a string representing the topic."""</span>
<span class="LiteralGray">        Return self.text</span>

<span class="LiteralGray">class Entry(models.Model):</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>We import the <code>User</code> model from <code>django.contrib.auth</code>. Then we add an <code>owner</code> field to <code>Topic</code>, which establishes a foreign key relationship to the <code>User</code> model. If a user is deleted, all the topics associated with that user will be deleted as well.</p>
<h4 id="h3-502703c19-0031"><span epub:type="pagebreak" id="Page_426" title="426"></span>Identifying Existing Users</h4>
<p class="BodyFirst">When we migrate the database, Django will modify the database so it can store a connection between each topic and a user. To make the migration, Django needs to know which user to associate with each existing topic. The simplest approach is to start by assigning all existing topics to one user—for example, the superuser. But first, we need to know that user’s ID.</p>
<p>Let’s look at the IDs of all users created so far. Start a Django shell session and issue the following commands:</p>
<pre><code>(ll_env)learning_log$ <b>python manage.py shell</b>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> &gt;&gt;&gt; <b>from django.contrib.auth.models import User</b>
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> &gt;&gt;&gt; <b>User.objects.all()</b>
&lt;QuerySet [&lt;User: ll_admin&gt;, &lt;User: eric&gt;, &lt;User: willie&gt;]&gt;
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> &gt;&gt;&gt; <b>for user in User.objects.all():</b>
...     <b>print(user.username, user.id)</b>
...
ll_admin 1
eric 2
willie 3
&gt;&gt;&gt;</code></pre>
<p>We first import the <code>User</code> model into the shell session <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We then look at all the users that have been created so far <span aria-label="annotation2" class="CodeAnnotation">❷</span>. The output shows three users for my version of the project: <code>ll_admin</code>, <code>eric</code>, and <code>willie</code>.</p>
<p>Next, we loop through the list of users and print each user’s username and ID <span aria-label="annotation3" class="CodeAnnotation">❸</span>. When Django asks which user to associate the existing topics with, we’ll use one of these ID values.</p>
<h4 id="h3-502703c19-0032">Migrating the Database</h4>
<p class="BodyFirst">Now that we know the IDs, we can migrate the database. When we do this, Python will ask us to connect the <code>Topic</code> model to a particular owner temporarily or to add a default to our <em>models.py</em> file to tell it what to do. Choose option <b>1</b>:</p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> (ll_env)learning_log$ <b>python manage.py makemigrations learning_logs</b>
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> It is impossible to add a non-nullable field 'owner' to topic without
specifying a default. This is because...
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a
    null value for this column)
 2) Quit and manually define a default value in models.py.
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> Select an option: <b>1</b>
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span> Please enter the default value now, as valid Python
The datetime and django.utils.timezone modules are available...
Type 'exit' to exit this prompt
<span aria-label="annotation6" class="CodeAnnotationHang">❻</span> &gt;&gt;&gt; <b>1</b>
Migrations for 'learning_logs':
  learning_logs/migrations/0003_topic_owner.py
- Add field owner to topic
(ll_env)learning_log$</code></pre>
<p><span epub:type="pagebreak" id="Page_427" title="427"></span>We start by issuing the <code>makemigrations</code> command <span aria-label="annotation1" class="CodeAnnotation">❶</span>. In the output, Django indicates that we’re trying to add a required (<em>non-nullable</em>) field to an existing model (<code>topic</code>) with no default value specified <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Django gives us two options: we can provide a default right now, or we can quit and add a default value in <em>models.py</em> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Here I’ve chosen the first option <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Django then asks us to enter the default value <span aria-label="annotation5" class="CodeAnnotation">❺</span>.</p>
<p>To associate all existing topics with the original admin user, <code>ll_admin</code>, I entered the user ID of <code>1</code> <span aria-label="annotation6" class="CodeAnnotation">❻</span>. You can use the ID of any user you’ve created; it doesn’t have to be a superuser. Django then migrates the database using this value and generates the migration file <em>0003_topic_owner.py</em>, which adds the field <code>owner</code> to the <code>Topic</code> model.</p>
<p>Now we can execute the migration. Enter the following in an active virtual environment:</p>
<pre><code>(ll_env)learning_log$ <b>python manage.py migrate</b>
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, learning_logs, sessions
Running migrations:
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span>   Applying learning_logs.0003_topic_owner... OK
(ll_env)learning_log$</code></pre>
<p>Django applies the new migration, and the result is <code>OK</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>
<p>We can verify that the migration worked as expected in a shell session, like this:</p>
<pre><code>&gt;&gt;&gt; <b>from learning_logs.models import Topic</b>
&gt;&gt;&gt; <b>for topic in Topic.objects.all():</b>
...     <b>print(topic, topic.owner)</b>
...
Chess ll_admin
Rock Climbing ll_admin
&gt;&gt;&gt;</code></pre>
<p>We import <code>Topic</code> from <code>learning_logs.models</code> and then loop through all existing topics, printing each topic and the user it belongs to. You can see that each topic now belongs to the user <code>ll_admin</code>. (If you get an error when you run this code, try exiting the shell and starting a new shell.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	You can simply reset the database instead of migrating, but that will lose all existing data. It’s good practice to learn how to migrate a database while maintaining the integrity of users’ data. If you do want to start with a fresh database, issue the command <code class="bold">python manage.py flush</code> to rebuild the database structure. You’ll have to create a new superuser, and all of your data will be gone.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502703c19-0010">Restricting Topics Access to Appropriate Users</h3>
<p class="BodyFirst">Currently, if you’re logged in, you’ll be able to see all the topics, no matter which user you’re logged in as. We’ll change that by showing users only the topics that belong to them.</p>
<p><span epub:type="pagebreak" id="Page_428" title="428"></span>Make the following change to the <code>topics()</code> function in <em>views.py</em>:</p>
<p class="CodeLabel"><b>learning_logs/views.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">@login_required</span>
<span class="LiteralGray">def topics(request):</span>
<span class="LiteralGray">    """Show all topics."""</span>
    topics = Topic.objects.filter(owner=request.user).order_by('date_added')
<span class="LiteralGray">    context = {'topics': topics}</span>
<span class="LiteralGray">    return render(request, 'learning_logs/topics.html', context)</span>
<em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>When a user is logged in, the <code>request</code> object has a <code>request.user</code> attribute set, which contains information about the user. The query <code>Topic.objects.filter(owner=request.user)</code> tells Django to retrieve only the <code>Topic</code> objects from the database whose <code>owner</code> attribute matches the current user. Because we’re not changing how the topics are displayed, we don’t need to change the template for the topics page at all.</p>
<p>To see if this works, log in as the user you connected all existing topics to, and go to the topics page. You should see all the topics. Now log out and log back in as a different user. You should see the message “No topics have been added yet.”</p>
<h3 id="h2-502703c19-0011">Protecting a User’s Topics</h3>
<p class="BodyFirst">We haven’t restricted access to the topic pages yet, so any registered user could try a bunch of URLs (like <em>http://localhost:8000/topics/1/</em>) and retrieve topic pages that happen to match.</p>
<p>Try it yourself. While logged in as the user that owns all topics, copy the URL or note the ID in the URL of a topic, and then log out and log back in as a different user. Enter that topic’s URL. You should be able to read the entries, even though you’re logged in as a different user.</p>
<p>We’ll fix this now by performing a check before retrieving the requested entries in the <code>topic()</code> view function:</p>
<p class="CodeLabel"><b>learning_logs/views.py</b></p>
<pre><code><span class="LiteralGray">from django.shortcuts import render, redirect</span>
<span class="LiteralGray">from django.contrib.auth.decorators import login_required</span>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> from django.http import Http404

<em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">@login_required</span>
<span class="LiteralGray">def topic(request, topic_id):</span>
<span class="LiteralGray">    """Show a single topic and all its entries."""</span>
<span class="LiteralGray">    topic = Topic.objects.get(id=topic_id)</span>
    # Make sure the topic belongs to the current user.
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>     if topic.owner != request.user:
        raise Http404

<span class="LiteralGray">    entries = topic.entry_set.order_by('-date_added')</span>
<span class="LiteralGray">    context = {'topic': topic, 'entries': entries}</span>
<span class="LiteralGray">    return render(request, 'learning_logs/topic.html', context)</span>
<em class="LiteralGrayItalic">--snip--</em></code></pre>
<p><span epub:type="pagebreak" id="Page_429" title="429"></span>A 404 response is a standard error response that’s returned when a requested resource doesn’t exist on a server. Here we import the <code>Http404</code> exception <span aria-label="annotation1" class="CodeAnnotation">❶</span>, which we’ll raise if the user requests a topic they shouldn’t have access to. After receiving a topic request, we make sure the topic’s user matches the currently logged-in user before rendering the page. If the requested topic’s owner is not the same as the current user, we raise the <code>Http404</code> exception <span aria-label="annotation2" class="CodeAnnotation">❷</span>, and Django returns a 404-error page.</p>
<p>Now if you try to view another user’s topic entries, you’ll see a “Page Not Found” message from Django. In <span class="xref" itemid="xref_target_Chapter 20">Chapter 20</span>, we’ll configure the project so users will see a proper error page instead of a debugging page.</p>
<h3 id="h2-502703c19-0012">Protecting the edit_entry Page</h3>
<p class="BodyFirst">The <code>edit_entry</code> pages have URLs of the form <em>http://localhost:8000/edit_entry/entry_id/</em>, where the <var>entry_id</var> is a number. Let’s protect this page so no one can use the URL to gain access to someone else’s entries:</p>
<p class="CodeLabel"><b>learning_logs/views.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">@login_required</span>
<span class="LiteralGray">def edit_entry(request, entry_id):</span>
<span class="LiteralGray">    """Edit an existing entry."""</span>
<span class="LiteralGray">    entry = Entry.objects.get(id=entry_id)</span>
<span class="LiteralGray">    topic = entry.topic</span>
    if topic.owner != request.user:
        raise Http404

    <span class="LiteralGray">if request.method != 'POST':</span>
<span class="LiteralGray">        </span><em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>We retrieve the entry and the topic associated with this entry. We then check whether the owner of the topic matches the currently logged-in user; if they don’t match, we raise an <code>Http404</code> exception.</p>
<h3 id="h2-502703c19-0013">Associating New Topics with the Current User</h3>
<p class="BodyFirst">Currently, the page for adding new topics is broken because it doesn’t associate new topics with any particular user. If you try adding a new topic, you’ll see the message <code>IntegrityError</code> along with <code>NOT NULL constraint failed: learning_logs_topic.owner_id</code>. Django is saying you can’t create a new topic without specifying a value for the topic’s <code>owner</code> field.</p>
<p>There’s a straightforward fix for this problem, because we have access to the current user through the <code>request</code> object. Add the following code, which associates the new topic with the current user:</p>
<p class="CodeLabel"><b>learning_logs/views.py</b></p>
<pre><code><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">@login_required</span>
<span class="LiteralGray">def new_topic(request):</span>
<span class="LiteralGray">    </span><em class="LiteralGrayItalic">--snip--</em>
<span class="LiteralGray">    else:</span>
<span class="LiteralGray">        # POST data submitted; process data.</span>
<span class="LiteralGray">        form = TopicForm(data=request.POST)</span>
<span class="LiteralGray">        if form.is_valid():</span>
<span epub:type="pagebreak" id="Page_430" title="430"></span><span aria-label="annotation1" class="CodeAnnotationHang">❶</span>             new_topic = form.save(commit=False)
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span>             new_topic.owner = request.user
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span>             new_topic.save()
<span class="LiteralGray">            return redirect('learning_logs:topics')</span>

<span class="LiteralGray">    # Display a blank or invalid form.</span>
<span class="LiteralGray">    context = {'form': form}</span>
<span class="LiteralGray">    return render(request, 'learning_logs/new_topic.html', context)</span>
<span class="LiteralGray"> </span><em class="LiteralGrayItalic">--snip--</em></code></pre>
<p>When we first call <code>form.save()</code>, we pass the <code>commit=False</code> argument because we need to modify the new topic before saving it to the database <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We then set the new topic’s <code>owner</code> attribute to the current user <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Finally, we call <code>save()</code> on the topic instance we just defined <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Now the topic has all the required data and will save successfully.</p>
<p>You should be able to add as many new topics as you want for as many different users as you want. Each user will only have access to their own data, whether they’re viewing data, entering new data, or modifying old data.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try It Yourself</h2>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c19-16">19-3.	Refactoring:</span> There are two places in <em>views.py</em> where we make sure the user associated with a topic matches the currently logged-in user. Put the code for this check in a function called <code>check_topic_owner()</code>, and call this function where appropriate.</p>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c19-17">19-4.	Protecting new_entry:</span> Currently, a user can add a new entry to another user’s learning log by entering a URL with the ID of a topic belonging to another user. Prevent this attack by checking that the current user owns the entry’s topic before saving the new entry.</p>
<p class="BoxBodyCustom"><span class="BoxNumber" id="h2-502703c19-18">19-5.	Protected Blog:</span> In your Blog project, make sure each blog post is connected to a particular user. Make sure all posts are publicly accessible but only registered users can add posts and edit existing posts. In the view that allows users to edit their posts, make sure the user is editing their own post before processing the form.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502703c19-0004">Summary</h2>
<p class="BodyFirst">In this chapter, you learned how forms allow users to add new topics and entries, and edit existing entries. You then learned how to implement user accounts. You gave existing users the ability to log in and out, and used Django’s default <code>UserCreationForm</code> to let people create new accounts.</p>
<p><span epub:type="pagebreak" id="Page_431" title="431"></span>After building a simple user authentication and registration system, you restricted access to logged-in users for certain pages using the <code>@login_required</code> decorator. You then assigned data to specific users through a foreign key relationship. You also learned to migrate the database when the migration requires you to specify some default data.</p>
<p>Finally, you learned how to make sure a user can only see data that belongs to them by modifying the view functions. You retrieved appropriate data using the <code>filter()</code> method, and compared the owner of the requested data to the currently logged-in user.</p>
<p>It might not always be immediately obvious what data you should make available and what data you should protect, but this skill will come with practice. The decisions we’ve made in this chapter to secure our users’ data also illustrate why working with others is a good idea when building a project: having someone else look over your project makes it more likely that you’ll spot vulnerable areas.</p>
<p>You now have a fully functioning project running on your local machine. In the final chapter, you’ll style Learning Log to make it visually appealing, and you’ll deploy the project to a server so anyone with internet access can register and make an account.</p>
</section>
</div></body>
</html>