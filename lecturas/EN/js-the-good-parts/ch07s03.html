<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Elements</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="Elements"><div class="titlepage"><div><div><h1 class="title"><a id="elements"/>Elements</h1></div></div></div><p>Let's look more closely at the elements that make up regular
                    expressions.<a id="IDX-CHP-7-0359" class="indexterm"/><a id="IDX-CHP-7-0358" class="indexterm"/></p><div class="sect2" title="Regexp Choice"><div class="titlepage"><div><div><h2 class="title"><a id="regexp_choice"/>Regexp Choice</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e5496"/><img src="httpatomoreillycomsourceoreillyimages238826.png" alt="image with no caption"/></div></div><p>A <span class="emphasis"><em>regexp choice</em></span> contains one or more <span class="emphasis"><em>regexp
                        sequences</em></span>. The sequences are separated by the <code class="literal">|</code> (vertical bar) character. The choice matches if
                    any of the sequences match. It attempts to match each of the sequences in order.
                        So:<a id="IDX-CHP-7-0360" class="indexterm"/></p><a id="I_programlisting7_d1e5519"/><pre class="programlisting">"into".match(/in|int/)</pre><p>matches the <code class="literal">in</code> in <code class="literal">into</code>. It wouldn't match <code class="literal">int</code>
                    because the match of <code class="literal">in</code> was
                    successful.</p></div><div class="sect2" title="Regexp Sequence"><div class="titlepage"><div><div><h2 class="title"><a id="regexp_sequence"/>Regexp Sequence</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e5539"/><img src="httpatomoreillycomsourceoreillyimages238722.png" alt="image with no caption"/></div></div><p>A <span class="emphasis"><em>regexp sequence</em></span> contains one or more <span class="emphasis"><em>regexp
                        factors</em></span>. Each factor can optionally be followed by a quantifier
                    that determines how many times the factor is allowed to appear. If there is no
                    quantifier, then the factor will be matched one time.<a id="IDX-CHP-7-0361" class="indexterm"/></p></div><div class="sect2" title="Regexp Factor"><div class="titlepage"><div><div><h2 class="title"><a id="regexp_factor"/>Regexp Factor</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e5563"/><img src="httpatomoreillycomsourceoreillyimages238754.png" alt="image with no caption"/></div></div><p>A <span class="emphasis"><em>regexp factor</em></span> can be a character, a parenthesized
                    group, a character class, or an escape sequence. All characters are treated
                    literally except for the control characters and the special
                        characters:<a id="IDX-CHP-7-0362" class="indexterm"/><a id="IDX-CHP-7-0363" class="indexterm"/><a id="IDX-CHP-7-0364" class="indexterm"/><a id="IDX-CHP-7-0365" class="indexterm"/><a id="IDX-CHP-7-0366" class="indexterm"/><a id="IDX-CHP-7-0367" class="indexterm"/><a id="IDX-CHP-7-0368" class="indexterm"/><a id="IDX-CHP-7-0369" class="indexterm"/><a id="IDX-CHP-7-0370" class="indexterm"/><a id="IDX-CHP-7-0371" class="indexterm"/><a id="IDX-CHP-7-0372" class="indexterm"/><a id="IDX-CHP-7-0373" class="indexterm"/><a id="IDX-CHP-7-0374" class="indexterm"/><a id="IDX-CHP-7-0375" class="indexterm"/><a id="IDX-CHP-7-0376" class="indexterm"/><a id="IDX-CHP-7-0377" class="indexterm"/></p><a id="I_programlisting7_d1e5658"/><pre class="programlisting">\ / [ ] ( ) { } ? + * | . ^ $</pre><p>which must be escaped with a <code class="literal">\</code> prefix if
                    they are to be matched literally. When in doubt, any special character can be
                    given a <code class="literal">\</code> prefix to make it literal. The
                        <code class="literal">\</code> prefix <span class="emphasis"><em>does not</em></span>
                    make letters or digits literal.</p><p>An unescaped <code class="literal">.</code> matches any character except
                    a line-ending character.</p><p>An unescaped <code class="literal">^</code> matches the beginning of the
                    text when the <code class="literal">lastIndex</code> property is zero. It
                    can also match line-ending characters when the <code class="literal">m</code> flag is specified.</p><p>An unescaped <code class="literal">$</code> matches the end of the text.
                    It can also match line-ending characters when the <code class="literal">m</code> flag is specified.</p></div><div class="sect2" title="Regexp Escape"><div class="titlepage"><div><div><h2 class="title"><a id="regexp_escape"/>Regexp Escape</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e5702"/><img src="httpatomoreillycomsourceoreillyimages238782.png" alt="image with no caption"/></div></div><p>The backslash character indicates escapement in regexp factors as well as in
                    strings, but in regexp factors, it works a little differently.<a id="IDX-CHP-7-0378" class="indexterm"/></p><p>As in strings, <code class="literal">\f</code> is the formfeed
                    character, <code class="literal">\n</code> is the newline character,
                        <code class="literal">\r</code> is the carriage return character,
                        <code class="literal">\t</code> is the tab character, and <code class="literal">\u</code> allows for specifying a Unicode character as a
                    16-bit hex constant. In regexp factors, <code class="literal">\b</code>
                    <span class="emphasis"><em>is not</em></span> the backspace character.<a id="IDX-CHP-7-0379" class="indexterm"/><a id="IDX-CHP-7-0380" class="indexterm"/><a id="IDX-CHP-7-0381" class="indexterm"/><a id="IDX-CHP-7-0382" class="indexterm"/></p><p><code class="literal">\d</code> is the same as <code class="literal">[0-9]</code>. It matches a digit. <code class="literal">\D</code>
                    is the opposite: <code class="literal">[^0-9]</code>.</p><p><code class="literal">\s</code> is the same as <code class="literal">[\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</code>. This is a partial set
                    of Unicode whitespace characters. <code class="literal">\S</code> is the
                    opposite: <code class="literal">[^\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</code>.</p><p><code class="literal">\w</code> is the same as <code class="literal">[0-9A-Z_a-z]</code>. <code class="literal">\W</code> is the
                    opposite: <code class="literal">[^0-9A-Z_a-z]</code>. This is supposed to
                    represent the characters that appear in words. Unfortunately, the class it
                    defines is useless for working with virtually any real language. If you need to
                    match a class of letters, you must specify your own class.</p><p>A simple letter class is <code class="literal">[A-Za-z\u00C0-\u1FFF\u2800-\uFFFD]</code>. It includes all of Unicode's
                    letters, but it also includes thousands of characters that are not letters.
                    Unicode is large and complex. An exact letter class of the Basic Multilingual
                    Plane is possible, but would be huge and inefficient. JavaScript's regular
                    expressions provide extremely poor support for internationalization.<a id="IDX-CHP-7-0383" class="indexterm"/></p><p><code class="literal">\b</code> was intended to be a word-boundary
                    anchor that would make it easier to match text on word boundaries.
                    Unfortunately, it uses <code class="literal">\w</code> to find word
                    boundaries, so it is completely useless for multilingual applications. This is
                    not a good part.</p><p><code class="literal">\1</code> is a reference to the text that was
                    captured by group 1 so that it can be matched again. For example, you could
                    search text for duplicated words with:</p><a id="I_programlisting7_d1e5816"/><pre class="programlisting">var doubled_words = /([A-Za-z\u00C0-\u1FFF\u2800-\uFFFD]+)\s+\1/gi;</pre><p><code class="literal">doubled_words</code> looks for occurrences of
                    words (strings containing 1 or more letters) followed by whitespace followed by
                    the same word.</p><p><code class="literal">\2</code> is a reference to group 2, <code class="literal">\3</code> is a reference to group 3, and so on.</p></div><div class="sect2" title="Regexp Group"><div class="titlepage"><div><div><h2 class="title"><a id="regexp_group"/>Regexp Group</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e5834"/><img src="httpatomoreillycomsourceoreillyimages238708.png" alt="image with no caption"/></div></div><p>There are four kinds of groups:<a id="IDX-CHP-7-0384" class="indexterm"/><a id="IDX-CHP-7-0385" class="indexterm"/><a id="IDX-CHP-7-0386" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                            <span class="emphasis"><em>Capturing</em></span>
                        </span></dt><dd><p>A capturing group is a regexp choice wrapped in parentheses. The
                                characters that match the group will be captured. Every capture
                                group is given a number. The first capturing <code class="literal">(</code> in the regular expression is group
                                1. The second capturing <code class="literal">(</code> in the
                                regular expression is group 2.<a id="IDX-CHP-7-0387" class="indexterm"/></p></dd><dt><span class="term">
                            <span class="emphasis"><em>Noncapturing</em></span>
                        </span></dt><dd><p>A noncapturing group has a <code class="literal">(?:</code>
                                prefix. A noncapturing group simply matches; it does not capture the
                                matched text. This has the advantage of slight faster performance.
                                Noncapturing groups do not interfere with the numbering of capturing
                                    groups.<a id="IDX-CHP-7-0388" class="indexterm"/></p></dd><dt><span class="term">
                            <span class="emphasis"><em>Positive lookahead</em></span>
                        </span></dt><dd><p>A positive lookahead group has a <code class="literal">(?=</code> prefix. It is like a noncapturing group except
                                that after the group matches, the text is rewound to where the group
                                started, effectively matching nothing. This is not a good
                                    part.<a id="IDX-CHP-7-0389" class="indexterm"/></p></dd><dt><span class="term">
                            <span class="emphasis"><em>Negative lookahead</em></span>
                        </span></dt><dd><p>A negative lookahead group has a <code class="literal">(?!</code> prefix. It is like a positive lookahead group,
                                except that it matches only if it fails to match. This is not a good
                                    part.<a id="IDX-CHP-7-0390" class="indexterm"/></p></dd></dl></div></div><div class="sect2" title="Regexp Class"><div class="titlepage"><div><div><h2 class="title"><a id="regexp_class"/>Regexp Class</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e5926"/><img src="httpatomoreillycomsourceoreillyimages238834.png" alt="image with no caption"/></div></div><p>A <span class="emphasis"><em>regexp class</em></span> is a convenient way of specifying one of a
                    set of characters. For example, if we wanted to match a vowel, we could write
                        <code class="literal">(?:a|e|i|o|u)</code>, but it is more
                    conveniently written as the class <code class="literal">[aeiou]</code>.<a id="IDX-CHP-7-0391" class="indexterm"/><a id="IDX-CHP-7-0392" class="indexterm"/><a id="IDX-CHP-7-0393" class="indexterm"/><a id="IDX-CHP-7-0394" class="indexterm"/></p><p>Classes provide two other conveniences. The first is that ranges of characters
                    can be specified. So, the set of 32 ASCII special characters:</p><a id="I_programlisting7_d1e5966"/><pre class="programlisting">! " # $ % &amp; ' ( ) * +, - . / :
; &lt; = &gt; ? @ [ \ ] ^ _ ` { | } ˜</pre><p>could be written as:</p><a id="I_programlisting7_d1e5970"/><pre class="programlisting">(?:!|"|#|\$|%|&amp;|'|\(|\)|\*|\+|,|-|\.|\/|:|;|&lt;|=|&gt;|@|\[|\\|]|\^|_|` |\{|\||\}|˜)</pre><p>but is slightly more nicely written as:</p><a id="I_programlisting7_d1e5974"/><pre class="programlisting">[!-\/:-@\[-`{-˜]</pre><p>which includes the characters from <code class="literal">!</code>
                    through <code class="literal">/</code> and <code class="literal">:</code> through <code class="literal">@</code> and <code class="literal">[</code> through <code class="literal">`</code> and
                        <code class="literal">{</code> through <code class="literal">˜</code>. It is still pretty nasty looking.</p><p>The other convenience is the complementing of a class. If the first character
                    after the <code class="literal">[</code> is <code class="literal">^</code>, then the class excludes the specified characters.</p><p>So <code class="literal">[^!-\/:-@\[-`{-˜]</code> matches any character
                    that is <span class="emphasis"><em>not</em></span> one of the ASCII special characters.</p></div><div class="sect2" title="Regexp Class Escape"><div class="titlepage"><div><div><h2 class="title"><a id="regexp_class_escape"/>Regexp Class Escape</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e6024"/><img src="httpatomoreillycomsourceoreillyimages238786.png" alt="image with no caption"/></div></div><p>The rules of escapement within a character class are slightly different than
                    those for a regexp factor. <code class="literal">[\b]</code> is the
                    backspace character. Here are the special characters that should be escaped in a
                    character class:<a id="IDX-CHP-7-0395" class="indexterm"/><a id="IDX-CHP-7-0396" class="indexterm"/></p><a id="I_programlisting7_d1e6048"/><pre class="programlisting">- / [ \ ] ^</pre></div><div class="sect2" title="Regexp Quantifier"><div class="titlepage"><div><div><h2 class="title"><a id="regexp_quantifier"/>Regexp Quantifier</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e6054"/><img src="httpatomoreillycomsourceoreillyimages238862.png" alt="image with no caption"/></div></div><p>A <span class="emphasis"><em>regexp factor</em></span> may have a <span class="emphasis"><em>regexp
                        quantifier</em></span> suffix that determines how many times the factor
                    should match. A number wrapped in curly braces means that the factor should
                    match that many times. So, <code class="literal">/www/</code> matches the
                    same as <code class="literal">/w{3}/</code>. <code class="literal">{3,6}</code> will match 3, 4, 5, or 6 times. <code class="literal">{3,}</code> will match 3 or more times.<a id="IDX-CHP-7-0397" class="indexterm"/><a id="IDX-CHP-7-0398" class="indexterm"/><a id="IDX-CHP-7-0399" class="indexterm"/><a id="IDX-CHP-7-0400" class="indexterm"/><a id="IDX-CHP-7-0401" class="indexterm"/><a id="IDX-CHP-7-0402" class="indexterm"/><a id="IDX-CHP-7-0403" class="indexterm"/><a id="IDX-CHP-7-0404" class="indexterm"/><a id="IDX-CHP-7-0405" class="indexterm"/><a id="IDX-CHP-7-0406" class="indexterm"/><a id="IDX-CHP-7-0407" class="indexterm"/><a id="IDX-CHP-7-0408" class="indexterm"/><a id="IDX-CHP-7-0409" class="indexterm"/><a id="IDX-CHP-7-0410" class="indexterm"/><a id="IDX-CHP-7-0411" class="indexterm"/><a id="IDX-CHP-7-0412" class="indexterm"/><a id="IDX-CHP-7-0413" class="indexterm"/><a id="IDX-CHP-7-0414" class="indexterm"/><a id="IDX-CHP-7-0415" class="indexterm"/><a id="IDX-CHP-7-0416" class="indexterm"/><a id="IDX-CHP-7-0417" class="indexterm"/><a id="IDX-CHP-7-0418" class="indexterm"/><a id="IDX-CHP-7-0419" class="indexterm"/><a id="IDX-CHP-7-0420" class="indexterm"/><a id="IDX-CHP-7-0421" class="indexterm"/><a id="IDX-CHP-7-0422" class="indexterm"/><a id="IDX-CHP-7-0423" class="indexterm"/><a id="IDX-CHP-7-0424" class="indexterm"/><a id="IDX-CHP-7-0425" class="indexterm"/><a id="IDX-CHP-7-0426" class="indexterm"/><a id="IDX-CHP-7-0427" class="indexterm"/><a id="IDX-CHP-7-0428" class="indexterm"/><a id="IDX-CHP-7-0429" class="indexterm"/><a id="IDX-CHP-7-0430" class="indexterm"/><a id="IDX-CHP-7-0431" class="indexterm"/><a id="IDX-CHP-7-0432" class="indexterm"/><a id="IDX-CHP-7-0433" class="indexterm"/><a id="IDX-CHP-7-0434" class="indexterm"/><a id="IDX-CHP-7-0435" class="indexterm"/><a id="IDX-CHP-7-0436" class="indexterm"/><a id="IDX-CHP-7-0437" class="indexterm"/><a id="IDX-CHP-7-0438" class="indexterm"/><a id="IDX-CHP-7-0439" class="indexterm"/><a id="IDX-CHP-7-0440" class="indexterm"/><a id="IDX-CHP-7-0441" class="indexterm"/><a id="IDX-CHP-7-0442" class="indexterm"/><a id="IDX-CHP-7-0443" class="indexterm"/><a id="IDX-CHP-7-0444" class="indexterm"/><a id="IDX-CHP-7-0445" class="indexterm"/><a id="IDX-CHP-7-0446" class="indexterm"/><a id="IDX-CHP-7-0447" class="indexterm"/><a id="IDX-CHP-7-0448" class="indexterm"/><a id="IDX-CHP-7-0449" class="indexterm"/><a id="IDX-CHP-7-0450" class="indexterm"/><a id="IDX-CHP-7-0451" class="indexterm"/><a id="IDX-CHP-7-0452" class="indexterm"/><a id="IDX-CHP-7-0453" class="indexterm"/><a id="IDX-CHP-7-0454" class="indexterm"/><a id="IDX-CHP-7-0455" class="indexterm"/><a id="IDX-CHP-7-0456" class="indexterm"/><a id="IDX-CHP-7-0457" class="indexterm"/><a id="IDX-CHP-7-0458" class="indexterm"/><a id="IDX-CHP-7-0459" class="indexterm"/><a id="IDX-CHP-7-0460" class="indexterm"/><a id="IDX-CHP-7-0461" class="indexterm"/><a id="IDX-CHP-7-0462" class="indexterm"/><a id="IDX-CHP-7-0463" class="indexterm"/><a id="IDX-CHP-7-0464" class="indexterm"/><a id="IDX-CHP-7-0465" class="indexterm"/><a id="IDX-CHP-7-0466" class="indexterm"/><a id="IDX-CHP-7-0467" class="indexterm"/><a id="IDX-CHP-7-0468" class="indexterm"/><a id="IDX-CHP-7-0469" class="indexterm"/><a id="IDX-CHP-7-0470" class="indexterm"/><a id="IDX-CHP-7-0471" class="indexterm"/><a id="IDX-CHP-7-0472" class="indexterm"/><a id="IDX-CHP-7-0473" class="indexterm"/><a id="IDX-CHP-7-0474" class="indexterm"/></p><p><code class="literal">?</code> is the same as <code class="literal">{0,1}</code>. <code class="literal">*</code> is the same as
                        <code class="literal">{0,}</code>. <code class="literal">+</code> is the same as <code class="literal">{1,}</code>.</p><p>Matching tends to be greedy, matching as many repetitions as possible up to
                    the limit, if there is one. If the quantifier has an extra <code class="literal">?</code> suffix, then matching tends to be lazy,
                    attempting to match as few repetitions as possible. It is usually best to stick
                    with the greedy matching.</p></div></div></body></html>
