<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 10. Beautiful Features</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 10. Beautiful Features"><div class="titlepage"><div><div><h1 class="title"><a id="beautiful_features"/>Chapter 10. Beautiful Features</h1></div></div></div><div class="epigraph"><p>Thus, expecting thy reply, I profane my lips on thy foot, my eyes on thy picture,
                and my heart on thy every part. Thine, in the dearest design of industry. . .</p><div class="attribution"><span>—<span class="attribution">William Shakespeare, <span class="emphasis"><em>Love's Labor's Lost</em></span></span></span></div></div><p>I was invited last year to contribute a chapter to Andy Oram's and Greg Wilson's
                <span class="emphasis"><em>Beautiful Code</em></span> (O'Reilly), an anthology on the theme of beauty
            as expressed in computer programs. I wanted to write my chapter in JavaScript. I wanted
            to use it to present something abstract, powerful, and useful to show that the language
            was up to it. And I wanted to avoid the browser and other venues in which JavaScript is
            typecast. I wanted to show something respectable with some heft to it.</p><p>I immediately thought of Vaughn Pratt's Top Down Operator Precedence parser, which I
            use in JSLint (see <a class="xref" href="apc.html" title="Appendix C. JSLint">Appendix C</a>). Parsing is an important topic in
            computing. The ability to write a compiler for a language in itself is still a test for
            the completeness of a language.<a id="IDX-CHP-10-0497" class="indexterm"/></p><p>I wanted to include all of the code for a parser in JavaScript that parses JavaScript.
            But my chapter was just one of 30 or 40, so I felt constrained in the number of pages I
            could consume. A further complication was that most of my readers would have no
            experience with JavaScript, so I also would have to introduce the language and its
            peculiarities.</p><p>So, I decided to subset the language. That way, I wouldn't have to parse the whole
            language, and I wouldn't have to describe the whole language. I called the subset
            Simplified JavaScript. Selecting the subset was easy: it included just the features that
            I needed to write a parser. This is how I described it in <span class="emphasis"><em>Beautiful
                Code</em></span>:<a id="IDX-CHP-10-0498" class="indexterm"/></p><div class="blockquote"><blockquote class="blockquote"><p>Simplified JavaScript is just the good stuff, including:</p></blockquote></div><div class="variablelist"><dl><dt><span class="term">
                    <span class="emphasis"><em>Functions as first class objects</em></span>
                </span></dt><dd><p>Functions in Simplified JavaScript are lambdas with lexical
                        scoping.</p></dd><dt><span class="term">
                    <span class="emphasis"><em>Dynamic objects with prototypal inheritance</em></span>
                </span></dt><dd><p>Objects are class-free. We can add a new member to any object by ordinary
                        assignment. An object can inherit members from another object.</p></dd><dt><span class="term">
                    <span class="emphasis"><em>Object literals and array literals</em></span>
                </span></dt><dd><p>This is a very convenient notation for creating new objects and arrays.
                        JavaScript literals were the inspiration for the JSON data interchange
                        format.</p></dd></dl></div><p>The subset contained the best of the Good Parts. Even though it was a small language,
            it was very expressive and powerful. JavaScript has lots of additional features that
            really don't add very much, and as you'll find in the appendixes that follow, it has a
            lot of features with negative value. There was nothing ugly or bad in the subset. All of
            that fell away.</p><p>Simplified JavaScript isn't strictly a subset. I added a few new features. The
            simplest was adding <code class="literal">pi</code> as a simple constant. I did
            that to demonstrate a feature of the parser. I also demonstrated a better reserved word
            policy and showed that reserved words are unnecessary. In a function, a word cannot be
            used as both a variable or parameter name and a language feature. You can use a word for
            one or the other, and the programmer gets to choose. That makes a language easier to
            learn because you don't need to be aware of features you don't use. And it makes the
            language easier to extend because it isn't necessary to reserve more words to add new
            features.</p><p>I also added block scope. Block scope is not a necessary feature, but not having it
            confuses experienced programmers. I included block scope because I anticipated that my
            parser would be used to parse languages that are not JavaScript, and those languages
            would do scoping correctly. The code I wrote for the parser is written in a style that
            doesn't care if block scope is available or not. I recommend that you write that way,
                too.<a id="IDX-CHP-10-0499" class="indexterm"/></p><p>When I started thinking about this book, I wanted to take the subset idea further, to
            show how to take an existing programming language and make significant improvements to
            it by making no changes except to exclude the low-value features.</p><p>We see a lot of feature-driven product design in which the cost of features is not
            properly accounted. Features can have a negative value to consumers because they make
            the products more difficult to understand and use. We are finding that people like
            products that just work. It turns out that designs that just work are much harder to
            produce than designs that assemble long lists of features.</p><p>Features have a specification cost, a design cost, and a development cost. There is a
            testing cost and a reliability cost. The more features there are, the more likely one
            will develop problems or will interact badly with another. In software systems, there is
            a storage cost, which was becoming negligible, but in mobile applications is becoming
            significant again. There are ascending performance costs because Moore's Law doesn't
            apply to batteries.</p><p>Features have a documentation cost. Every feature adds pages to the manual, increasing
            training costs. Features that offer value to a minority of users impose a cost on all
            users. So, in designing products and programming languages, we want to get the core
            features—the good parts—right because that is where we create most of the value.</p><p>We all find the good parts in the products that we use. We value simplicity, and when
            simplicity isn't offered to us, we make it ourselves. My microwave oven has tons of
            features, but the only ones I use are cook and the clock. And setting the clock is a
            struggle. We cope with the complexity of feature-driven design by finding and sticking
            with the good parts.</p><p>It would be nice if products and programming languages were designed to have only good
            parts.</p></div></body></html>
